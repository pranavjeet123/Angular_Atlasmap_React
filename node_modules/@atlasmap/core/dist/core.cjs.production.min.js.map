{"version":3,"file":"core.cjs.production.min.js","sources":["../src/contracts/common.ts","../src/common/config.types.ts","../src/contracts/documents/java.ts","../src/contracts/field-action.ts","../src/contracts/mapping.ts","../src/contracts/mapping-preview.ts","../src/utils/common-util.ts","../src/models/field.model.ts","../src/models/error.model.ts","../src/models/document-definition.model.ts","../src/models/config.model.ts","../src/models/examples.ts","../src/models/expression.model.ts","../src/models/transition.model.ts","../src/models/field-action.model.ts","../src/models/inspect/document-inspection.model.ts","../src/models/inspect/csv-inspection.model.ts","../src/models/inspect/java-inspection.model.ts","../src/models/inspect/json-inspection.model.ts","../src/contracts/documents/json.ts","../src/models/inspect/xml-inspection.model.ts","../src/contracts/documents/xml.ts","../src/models/lookup-table.model.ts","../src/models/mapping-definition.model.ts","../src/models/mapping.model.ts","../../../node_modules/babel-plugin-transform-async-to-promises/helpers.js","../src/utils/document-inspection-util.ts","../src/services/file-management.service.ts","../src/utils/guid.ts","../src/utils/lookup-table-util.ts","../src/utils/mapping-digest-util.ts","../src/utils/mapping-util.ts","../src/utils/mapping-serializer.ts","../src/services/document-management.service.ts","../src/services/error-handler.service.ts","../src/services/field-action.service.ts","../src/services/mapping-expression.service.ts","../src/services/mapping-management.service.ts","../src/services/mapping-preview.service.ts","../src/services/initialization.service.ts","../src/contracts/documents/csv.ts"],"sourcesContent":["/*\n    Copyright (C) 2017 Red Hat, Inc.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n            http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n*/\n\nexport const FIELD_PATH_SEPARATOR = '/';\n\nexport const MODEL_PACKAGE_PREFIX = 'io.atlasmap.v2';\nexport const DATA_SOURCE_JSON_TYPE = MODEL_PACKAGE_PREFIX + '.DataSource';\n\n/** SOURCE or TARGET. */\nexport enum DataSourceType {\n  SOURCE = 'SOURCE',\n  TARGET = 'TARGET',\n}\n\n/**\n * The type of collection, such as {@link ARRAY} and {@link LIST}.\n */\nexport enum CollectionType {\n  ALL = 'ALL',\n  ARRAY = 'ARRAY',\n  LIST = 'LIST',\n  MAP = 'MAP',\n  NONE = 'NONE',\n}\n\n/**\n * The field status held by {@link IField}.\n */\nexport enum FieldStatus {\n  SUPPORTED = 'SUPPORTED',\n  UNSUPPORTED = 'UNSUPPORTED',\n  CACHED = 'CACHED',\n  ERROR = 'ERROR',\n  NOT_FOUND = 'NOT_FOUND',\n  EXCLUDED = 'EXCLUDED',\n}\n\n/**\n * The field type held by {@link IField}.\n */\nexport enum FieldType {\n  ANY = 'ANY',\n  ANY_DATE = 'ANY_DATE',\n  BIG_INTEGER = 'BIG_INTEGER',\n  BOOLEAN = 'BOOLEAN',\n  BYTE = 'BYTE',\n  BYTE_ARRAY = 'BYTE_ARRAY',\n  CHAR = 'CHAR',\n  COMPLEX = 'COMPLEX',\n  DATE = 'DATE',\n  DATE_TIME = 'DATE_TIME',\n  DATE_TIME_TZ = 'DATE_TIME_TZ',\n  DATE_TZ = 'DATE_TZ',\n  DECIMAL = 'DECIMAL',\n  DOUBLE = 'DOUBLE',\n  FLOAT = 'FLOAT',\n  INTEGER = 'INTEGER',\n  LONG = 'LONG',\n  NONE = 'NONE',\n  NUMBER = 'NUMBER',\n  SHORT = 'SHORT',\n  STRING = 'STRING',\n  TIME = 'TIME',\n  TIME_TZ = 'TIME_TZ',\n  UNSIGNED_BYTE = 'UNSIGNED_BYTE',\n  UNSIGNED_INTEGER = 'UNSIGNED_INTEGER',\n  UNSIGNED_LONG = 'UNSIGNED_LONG',\n  UNSIGNED_SHORT = 'UNSIGNED_SHORT',\n  UNSUPPORTED = 'UNSUPPORTED',\n}\n\nexport enum DocumentType {\n  JAVA = 'JAVA',\n  XML = 'XML',\n  XSD = 'XSD',\n  JSON = 'JSON',\n  CORE = 'Core',\n  CSV = 'CSV',\n  CONSTANT = 'Constants',\n  PROPERTY = 'Property',\n}\n\nexport enum InspectionType {\n  JAVA_CLASS = 'JAVA_CLASS',\n  SCHEMA = 'SCHEMA',\n  INSTANCE = 'INSTANCE',\n  UNKNOWN = 'UNKNOWN',\n}\n\n/** The serialized DataSource held by {@link IAtlasMapping}. */\nexport interface IDataSource {\n  id: string;\n  name?: string;\n  description?: string;\n  uri: string;\n  dataSourceType: DataSourceType;\n  characterEncoding?: string;\n  locale?: string;\n  jsonType: string;\n}\n\n/**\n * The serialized CSV document inspection result.\n */\nexport interface IDocument {\n  fields: IFields;\n}\n\n/**\n * The container of {@link IField}.\n */\nexport interface IFields {\n  field: IField[];\n}\n\n/**\n * The field in the mapping.\n */\nexport interface IField {\n  actions?: IFieldAction[];\n  value?: string;\n  arrayDimensions?: number;\n  arraySize?: number;\n  collectionType?: CollectionType;\n  docId?: string;\n  index?: number;\n  path?: string;\n  required?: boolean;\n  status?: FieldStatus;\n  fieldType?: FieldType;\n  format?: string;\n  name?: string;\n  jsonType: string;\n}\n\n/**\n * The field action, aka transformation in the mapping.\n */\nexport interface IFieldAction {\n  '@type'?: string;\n  displayName?: string;\n  [x: string]: any;\n}\n\nexport interface IStringList {\n  string: string[];\n}\n\nexport interface IParameterOption {\n  label: string;\n  value: string;\n}\n\nexport interface IParameter {\n  name: string;\n  label: string;\n  value: string;\n  boolean?: boolean;\n  options?: IParameterOption[];\n  enabled?: boolean;\n  required?: boolean;\n}\n\nexport interface IStringContainer {\n  String: string;\n}\n","/*\n    Copyright (C) 2017 Red Hat, Inc.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n            http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n*/\n\nimport { CollectionType } from '../contracts/common';\n\nexport enum DocumentDefaultName {\n  CONSTANTS = 'Constants',\n  PROPERTIES = 'Properties',\n}\n\nexport const enum FieldMode {\n  CREATE,\n  EDIT,\n}\n\nexport const collectionTypes = [\n  [CollectionType[CollectionType.ARRAY], 'Array'],\n  [CollectionType[CollectionType.LIST], 'List'],\n  [CollectionType[CollectionType.MAP], 'Map'],\n  [CollectionType[CollectionType.NONE], 'None'],\n];\n\nexport const constantTypes = [\n  ['STRING', 'String'], // default type\n  ['BOOLEAN', 'Boolean'],\n  ['BIG_INTEGER', 'Big Integer'],\n  ['BYTE', 'Byte'],\n  ['BYTE_ARRAY', 'ByteArray'],\n  ['CHAR', 'Char'],\n  ['COMPLEX', 'Complex'],\n  ['DECIMAL', 'Decimal'],\n  ['DOUBLE', 'Double'],\n  ['FLOAT', 'Float'],\n  ['INTEGER', 'Integer'],\n  ['LONG', 'Long'],\n  ['SHORT', 'Short'],\n  ['TIME', 'Time'],\n  ['DATE', 'Date'],\n  ['DATE_TIME', 'DateTime'],\n  ['DATE_TZ', 'DateTZ'],\n  ['TIME_TZ', 'TimeTZ'],\n  ['DATE_TIME_TZ', 'DateTimeTZ'],\n  ['UNSIGNED_BYTE', 'Unsigned Byte'],\n  ['UNSIGNED_INTEGER', 'Unsigned Integer'],\n  ['UNSIGNED_LONG', 'Unsigned Long'],\n  ['UNSIGNED_SHORT', 'Unsigned Short'],\n];\n\nexport const propertyTypes = [\n  ['STRING', 'String'], // default type\n  ['ANY', 'Any'],\n  ['BOOLEAN', 'Boolean'],\n  ['BIG_INTEGER', 'Big Integer'],\n  ['BYTE', 'Byte'],\n  ['BYTE_ARRAY', 'ByteArray'],\n  ['CHAR', 'Char'],\n  ['COMPLEX', 'Complex'],\n  ['DECIMAL', 'Decimal'],\n  ['DOUBLE', 'Double'],\n  ['FLOAT', 'Float'],\n  ['INTEGER', 'Integer'],\n  ['LONG', 'Long'],\n  ['SHORT', 'Short'],\n  ['TIME', 'Time'],\n  ['DATE', 'Date'],\n  ['DATE_TIME', 'DateTime'],\n  ['DATE_TZ', 'DateTZ'],\n  ['TIME_TZ', 'TimeTZ'],\n  ['DATE_TIME_TZ', 'DateTimeTZ'],\n  ['UNSIGNED_BYTE', 'Unsigned Byte'],\n  ['UNSIGNED_INTEGER', 'Unsigned Integer'],\n  ['UNSIGNED_LONG', 'Unsigned Long'],\n  ['UNSIGNED_SHORT', 'Unsigned Short'],\n];\n\nexport const HTTP_STATUS_OK = 200;\nexport const HTTP_STATUS_NO_CONTENT = 204;\n","/*\n    Copyright (C) 2017 Red Hat, Inc.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n            http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n*/\nimport { CollectionType, IField, IStringList } from '../common';\n\n/**\n * The Java class inspection data model contracts between frontend and backend.\n */\nexport const JAVA_MODEL_PACKAGE_PREFIX = 'io.atlasmap.java.v2';\nexport const JAVA_INSPECTION_REQUEST_JSON_TYPE =\n  JAVA_MODEL_PACKAGE_PREFIX + '.ClassInspectionRequest';\nexport const JAVA_CLASS_JSON_TYPE = JAVA_MODEL_PACKAGE_PREFIX + '.JavaClass';\nexport const JAVA_ENUM_FIELD_JSON_TYPE =\n  JAVA_MODEL_PACKAGE_PREFIX + '.JavaEnumField';\n\n/**\n * The root object that carries {@link IClassInspectionRequest}\n * when it's sent to backend.\n */\nexport interface IClassInspectionRequestContainer {\n  ClassInspectionRequest: IClassInspectionRequest;\n}\n\n/**\n * The serialized Java class inspection request.\n */\nexport interface IClassInspectionRequest {\n  jsonType: string;\n  fieldNameExclusions?: IStringList;\n  classNameExclusions?: IStringList;\n  classpath?: string;\n  className: string;\n  collectionType?: CollectionType;\n  collectionClassName?: string;\n  disablePrivateOnlyFields?: boolean;\n  disableProtectedOnlyFields?: boolean;\n  disablePublicOnlyFields?: boolean;\n  disablePublicGetterSetterFields?: boolean;\n}\n\n/**\n * The root object that carries {@link IClassInspectionResponse}\n * when it's received from backend.\n */\nexport interface IClassInspectionResponseContainer {\n  ClassInspectionResponse: IClassInspectionResponse;\n}\n\n/**\n * The serialized Java class inspection response.\n */\nexport interface IClassInspectionResponse {\n  javaClass: IJavaClass;\n  errorMessage: string;\n  executionTime: number;\n}\n\n/**\n * The root object that carries {@link IJavaClass}\n * when it's read from Java offline inspection (maven plugin).\n */\nexport interface IJavaClassContainer {\n  JavaClass: IJavaClass;\n}\n\n/**\n * The serialized Java class inspection result.\n */\nexport interface IJavaClass extends IJavaField {\n  javaEnumFields: IJavaEnumFields;\n  javaFields: IJavaFields;\n  packageName: string;\n  annotation: boolean;\n  annonymous: boolean;\n  enumeration: boolean;\n  isInterface: boolean;\n  localClass: boolean;\n  memberClass: boolean;\n  uri: string;\n}\n\n/**\n * The serialized Java field.\n */\nexport interface IJavaField extends IField {\n  annotations?: IStringList;\n  modifiers?: { modifier: Modifier[] };\n  parameterizedTypes?: IStringList;\n  className?: string;\n  canonicalClassName?: string;\n  collectionClassName?: string;\n  getMethod?: string;\n  setMethod?: string;\n  primitive?: boolean;\n  synthetic?: boolean;\n}\n\n/**\n * The serialized Java modifier.\n */\nexport enum Modifier {\n  ALL = 'ALL',\n  ABSTRACT = 'ABSTRACT',\n  FINAL = 'FINAL',\n  INTERFACE = 'INTERFACE',\n  NATIVE = 'NATIVE',\n  PACKAGE_PRIVATE = 'Package Private',\n  PUBLIC = 'PUBLIC',\n  PROTECTED = 'PROTECTED',\n  PRIVATE = 'PRIVATE',\n  STATIC = 'STATIC',\n  STRICT = 'STRICT',\n  SYNCHRONIZED = 'SYNCHRONIZED',\n  TRANSIENT = 'TRANSIENT',\n  VOLATILE = 'VOLATILE',\n  NONE = 'NONE',\n}\n\n/**\n * The container of serialized {@link IJavaEnumField}.\n */\nexport interface IJavaEnumFields {\n  javaEnumField: IJavaEnumField[];\n}\n\n/**\n * The serialized Java enum field.\n */\nexport interface IJavaEnumField extends IField {\n  name: string;\n  ordinal: number;\n  className: string;\n}\n\n/**\n * The container of serialized {@link IJavaField}.\n */\nexport interface IJavaFields {\n  javaField: IJavaField[];\n}\n","/*\n    Copyright (C) 2017 Red Hat, Inc.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n            http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n*/\n\nimport { CollectionType, FieldType } from './common';\n\n/**\n * The field action Data model contracts between frontend and backend.\n */\n\n/**\n * The root object that carries {@link IAActionDetails}\n * when it's received from backend.\n */\nexport interface IActionDetailsContainer {\n  ActionDetails: IActionDetails;\n}\n\n/**\n * The container of serialized {@link IActionDetail}.\n */\nexport interface IActionDetails {\n  actionDetail: IActionDetail[];\n}\n\n/**\n * The serialized field action detail.\n */\nexport interface IActionDetail {\n  parameters?: IActionParameters;\n  name: string;\n  custom: boolean;\n  className: string;\n  method: string;\n  sourceType: FieldType;\n  targetType: FieldType;\n  multiplicity: Multiplicity;\n  actionSchema: IActionSchema;\n}\n\n/**\n * The container of serialized field action parameter in old style.\n */\nexport interface IActionParameters {\n  actionParameter: IActionParameter[];\n}\n\n/**\n * The serialized field action parameter in old style.\n */\nexport interface IActionParameter {\n  values: string[];\n  name: string;\n  displayName: string;\n  description: string;\n  fieldType: FieldType;\n}\n\n/**\n * The multiplicity of the field action.\n */\nexport enum Multiplicity {\n  ONE_TO_ONE = 'ONE_TO_ONE',\n  ONE_TO_MANY = 'ONE_TO_MANY',\n  MANY_TO_ONE = 'MANY_TO_ONE',\n  ZERO_TO_ONE = 'ZERO_TO_ONE',\n  MANY_TO_MANY = 'MANY_TO_MANY',\n}\n\n/**\n * The newer style of field action metadata.\n */\nexport interface IActionSchema {\n  type: string;\n  id: string;\n  properties: IActionSchemaProperties;\n}\n\n/**\n * The newer style of field action parameter metadata.\n */\nexport interface IActionSchemaProperties {\n  [key: string]: {\n    type: string;\n    const: string;\n    description: string;\n    title: string;\n    enum?: string[];\n    'atlas-field-type'?: FieldType;\n    'atlas-collection-type'?: CollectionType;\n  };\n}\n","/*\n    Copyright (C) 2017 Red Hat, Inc.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n            http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n*/\nimport {\n  CollectionType,\n  DataSourceType,\n  FieldType,\n  IDataSource,\n  IField,\n  MODEL_PACKAGE_PREFIX,\n} from './common';\n\n/**\n * The mapping Data model contracts between frontend and backend.\n */\n\nexport const ATLAS_MAPPING_JSON_TYPE = MODEL_PACKAGE_PREFIX + '.AtlasMapping';\nexport const MAPPING_JSON_TYPE = MODEL_PACKAGE_PREFIX + '.Mapping';\nexport const COLLECTION_JSON_TYPE = MODEL_PACKAGE_PREFIX + '.Collection';\nexport const FIELD_GROUP_JSON_TYPE = MODEL_PACKAGE_PREFIX + '.FieldGroup';\nexport const PROPERTY_FIELD_JSON_TYPE = MODEL_PACKAGE_PREFIX + '.PropertyField';\nexport const CONSTANT_FIELD_JSON_TYPE = MODEL_PACKAGE_PREFIX + '.ConstantField';\n\n/**\n * The root object that carries {@link IAtlasMapping}\n * when it's sent/received to/from backend.\n */\nexport interface IAtlasMappingContainer {\n  AtlasMapping: IAtlasMapping;\n}\n\n/**\n * The serialized AtlasMap mapping definition.\n */\nexport interface IAtlasMapping {\n  dataSource?: IDataSource[];\n  mappings?: IMappings;\n  lookupTables?: ILookupTables;\n  constants?: IConstants;\n  properties?: IProperties;\n  name?: string;\n  jsonType: string;\n}\n\n/**\n * The container of serialized {@link IBaseMapping} held by {@link IAtlasMapping}\n */\nexport interface IMappings {\n  mapping: IBaseMapping[];\n}\n\n/**\n * The base interface of serialized mapping entry held by {@link IMappings}.\n * @see IMapping\n * @see ICollection\n */\nexport interface IBaseMapping {\n  alias?: string;\n  description?: string;\n  mappingType?: MappingType;\n  jsonType: string;\n}\n\n/**\n * The serialized mapping entry held by {@link IMappings}.\n * @see IBaseMapping\n */\nexport interface IMapping extends IBaseMapping {\n  expression?: string;\n  inputFieldGroup?: IFieldGroup;\n  inputField?: IField[];\n  outputField: IField[];\n  id: string;\n  delimiter?: string;\n  delimiterString?: string;\n  lookupTableName?: string;\n  strategy?: string;\n  strategyClassName?: string;\n}\n\n/**\n * The serialized collection mapping entry held by {@link IMappings}.\n * @see IBaseMapping\n * This is no longer used ATM, but the one-to-many/many-to-one for each COMPLEX collection\n * might want to resurrect it - https://github.com/atlasmap/atlasmap/issues/1236\n */\nexport interface ICollection extends IBaseMapping {\n  mappings: IMappings;\n  collectionSize: number;\n  collectionType: CollectionType;\n}\n\n/**\n * The mapping mode, such as {@link LOOKUP}, {@link COLLECTION}, etc.\n * @deprecated {@link COMBINE}, {@link MAP}, {@link SEPARATE}\n */\nexport enum MappingType {\n  ALL = 'ALL',\n  COLLECTION = 'COLLECTION',\n  COMBINE = 'COMBINE',\n  LOOKUP = 'LOOKUP',\n  MAP = 'MAP',\n  SEPARATE = 'SEPARATE',\n  NONE = 'NONE',\n}\n\n/**\n * The group of fields in the mapping.\n */\nexport interface IFieldGroup extends IField {\n  field?: IField[];\n}\n\n/**\n * The container of serialized {@link ILookupTable}.\n */\nexport interface ILookupTables {\n  lookupTable?: ILookupTable[];\n}\n\n/**\n * The container of serialized LookupTable.\n * @see ILookupEntry\n */\nexport interface ILookupTable {\n  lookupEntry: ILookupEntry[];\n  name: string;\n  description?: string;\n}\n\n/**\n * The serialized lookup table entry.\n * @see {@link ILookupTable}\n */\nexport interface ILookupEntry {\n  sourceValue: string;\n  sourceType: FieldType;\n  targetValue: string;\n  targetType: FieldType;\n}\n\n/**\n * The container of serialized Constant.\n * @see IConstant\n */\nexport interface IConstants {\n  constant?: IConstant[];\n}\n\n/**\n * The serialized Constant.\n */\nexport interface IConstant {\n  name: string;\n  value: string;\n  fieldType: FieldType;\n}\n\n/**\n * The container of serialized Property.\n */\nexport interface IProperties {\n  property?: IProperty[];\n}\n\n/**\n * The serialized Property.\n */\nexport interface IProperty {\n  name: string;\n  value?: string;\n  fieldType: FieldType;\n  scope?: string;\n  dataSourceType?: DataSourceType;\n}\n\n/**\n * The serialized JSON DataSource.\n * @see IDataSource\n */\nexport interface IJsonDataSource extends IDataSource {\n  template?: string;\n}\n\n/**\n * The serialized property field in the mapping.\n */\nexport interface IPropertyField extends IField {\n  scope?: string;\n}\n\n/**\n * The root object that carries {@link IValidation}\n * when it's received from backend as a result of\n * mapping validation.\n */\nexport interface IValidationsContainer {\n  Validations: IValidations;\n}\n\n/**\n * THe container of serialized validation result.\n */\nexport interface IValidations {\n  validation: IValidation[];\n}\n\n/**\n * The validation result.\n */\nexport interface IValidation {\n  message?: string;\n  id?: string;\n  docId?: string;\n  docName?: string;\n  scope?: ValidationScope;\n  status?: ValidationStatus;\n}\n\n/**\n * The validation scope.\n */\nexport enum ValidationScope {\n  DATA_SOURCE = 'DATA_SOURCE',\n  MAPPING = 'MAPPING',\n  LOOKUP_TABLE = 'LOOKUP_TABLE',\n  CONSTANT = 'CONSTANT',\n  PROPERTY = 'PROPERTY',\n}\n\n/**\n * The validation status.\n */\nexport enum ValidationStatus {\n  INFO = 'INFO',\n  WARN = 'WARN',\n  ERROR = 'ERROR',\n}\n\n/**\n * The root object that carries {@link IStringMap}\n * when it's received from backend.\n */\nexport interface IStringMapContainer {\n  StringMap: IStringMap;\n}\n\n/**\n * The serialized string map, used for deliverying\n * a list of mapping name.\n */\nexport interface IStringMap {\n  stringMapEntry: IStringMapEntry[];\n}\n\n/**\n * The string map entry with name and value.\n */\nexport interface IStringMapEntry {\n  name: string;\n  value: string;\n}\n","/*\n    Copyright (C) 2017 Red Hat, Inc.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n            http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n*/\nimport { IMapping } from './mapping';\nimport { MODEL_PACKAGE_PREFIX } from './common';\n\n/**\n * The mapping Data model contracts between frontend and backend.\n */\n\nexport const PROCESS_MAPPING_REQUEST_JSON_TYPE =\n  MODEL_PACKAGE_PREFIX + '.ProcessMappingRequest';\n\n/**\n * The root object that carries {@link IProcessMappingRequest}\n * when it's sent to backend.\n */\nexport interface IProcessMappingRequestContainer {\n  ProcessMappingRequest: IProcessMappingRequest;\n}\n\n/**\n * The serialized process mapping request object.\n */\nexport interface IProcessMappingRequest {\n  jsonType: string;\n  mapping: IMapping;\n}\n\n/**\n * The root object that carries {@link IProcessMappingResponse}\n * when it's received from backend.\n */\nexport interface IProcessMappingResponseContainer {\n  ProcessMappingResponse: IProcessMappingResponse;\n}\n\n/**\n * The serialized process mapping response object.\n */\nexport interface IProcessMappingResponse {\n  jsonType: string;\n  mapping: IMapping;\n  audits: IAudits;\n}\n\n/**\n * The container of serialized {@link IAudit}.\n */\nexport interface IAudits {\n  audit: IAudit[];\n}\n\n/**\n * The serialized audit object which is logged during processing a mapping.\n */\nexport interface IAudit {\n  message?: string;\n  docId?: string;\n  docName?: string;\n  path?: string;\n  value?: string;\n  status: AuditStatus;\n}\n\nexport enum AuditStatus {\n  INFO = 'INFO',\n  WARN = 'WARN',\n  ERROR = 'ERROR',\n}\n","/*\n    Copyright (C) 2017 Red Hat, Inc.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n            http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n*/\nimport { saveAs } from 'file-saver';\n\nexport class CommonUtil {\n  static removeItemFromArray(item: any, items: any[]): boolean {\n    if (item == null || items == null || items.length === 0) {\n      return false;\n    }\n    let i = 0;\n    let itemWasRemoved = false;\n    while (i < items.length) {\n      if (items[i] === item) {\n        items.splice(i, 1);\n        itemWasRemoved = true;\n      } else {\n        i++;\n      }\n    }\n    return itemWasRemoved;\n  }\n\n  /**\n   * Split a source string by the specified substring into a string array.\n   *\n   * @param inStr\n   * @param splitMarker\n   */\n  static splitByString(inStr: string, splitMarker: string): string[] {\n    let splitLoc = 0;\n    let splitLocEnd = 0;\n    let fragment = null;\n    const splitMarkerLen = splitMarker.length;\n    const result: string[] = [];\n\n    if (\n      inStr === null ||\n      inStr.length === 0 ||\n      splitMarker === null ||\n      splitMarkerLen === 0\n    ) {\n      return [];\n    }\n    while (splitLoc !== -1) {\n      splitLoc = inStr.indexOf(splitMarker);\n      splitLocEnd = inStr.indexOf(splitMarker, splitLoc + 1);\n      fragment = inStr.substring(splitLoc, splitLocEnd);\n      result.push(fragment);\n      inStr = inStr.substring(splitLocEnd + splitMarkerLen);\n    }\n    return result;\n  }\n\n  /**\n   * Turn a string into a byte array.\n   *\n   * @param str\n   */\n  static str2bytes(str: string): Uint8Array {\n    const bytes = new Uint8Array(str.length);\n    for (let i = 0; i < str.length; i++) {\n      bytes[i] = str.charCodeAt(i);\n    }\n    return bytes;\n  }\n\n  /**\n   * Asynchronously read from the specified file and return as a string.\n   *\n   * @param fileName\n   * @param reader\n   */\n  static async readFile(file: File, reader: FileReader): Promise<string> {\n    return new Promise<string>((resolve) => {\n      reader.onload = () => {\n        const fileBody = reader.result;\n        resolve(fileBody as string);\n      };\n      reader.readAsText(file);\n    });\n  }\n\n  /**\n   *  Perform an asynchronous binary read of the specified file name with the specified reader object.\n   *\n   * @param fileName - file to read\n   * @param reader - reader object\n   */\n  static async readBinaryFile(\n    file: File,\n    reader: FileReader\n  ): Promise<Int8Array> {\n    return new Promise<Int8Array>((resolve) => {\n      reader.onload = () => {\n        const fileBody = new Int8Array(reader.result as ArrayBuffer);\n        resolve(fileBody);\n      };\n      reader.readAsArrayBuffer(file);\n    });\n  }\n\n  /**\n   * Asynchronously write the specified file content (Blob) to the specified file name.  It will appear\n   * in the user's local Downloads directory (or equivalent).\n   *\n   * @param fileContent\n   * @param fName\n   */\n  static async writeFile(fileContent: Blob, fName: string): Promise<boolean> {\n    return new Promise<boolean>((resolve) => {\n      saveAs(fileContent, fName);\n      resolve(true);\n    });\n  }\n\n  /**\n   * Convert a camel-case string into human-readable form.\n   *\n   * @param camelCaseString\n   */\n  static toDisplayable(camelCaseString: string): string {\n    if (\n      typeof camelCaseString === 'undefined' ||\n      !camelCaseString ||\n      camelCaseString.indexOf(' ') >= 0\n    ) {\n      return camelCaseString;\n    }\n    let displayableString: string = camelCaseString.charAt(0).toUpperCase();\n    for (let index = 1; index < camelCaseString.length; index++) {\n      const chr: string = camelCaseString.charAt(index);\n      if (chr !== chr.toLowerCase()) {\n        displayableString += ' ';\n      }\n      displayableString += chr;\n    }\n    return displayableString;\n  }\n\n  /**\n   * Return a string path that fits into the width provided.  Capture as much of the leaf\n   * as possible, then as much of the beginning with the remaining space.\n   *\n   * @param path\n   * @param fieldWidth\n   */\n  static extractDisplayPath(path: string, fieldWidth: number): string {\n    const MAX_PATH_WIDTH = fieldWidth - 4; // account for length of ellipsis\n\n    if (!path || MAX_PATH_WIDTH <= 0) {\n      return '';\n    }\n    if (path.length <= MAX_PATH_WIDTH) {\n      return path;\n    }\n    const segmentedPath = path.split('/');\n    const leaf = '/' + segmentedPath[segmentedPath.length - 1];\n    if (leaf.length >= MAX_PATH_WIDTH) {\n      return leaf.substr(0, MAX_PATH_WIDTH);\n    }\n    const delta = MAX_PATH_WIDTH - leaf.length;\n    return path.substr(0, delta) + '...' + leaf;\n  }\n\n  /**\n   * Use the JSON utility to translate the specified buffer into a JSON buffer - then replace any\n   * non-ascii character encodings with unicode escape sequences.\n   *\n   * @param buffer\n   */\n  static sanitizeJSON(buffer: string): string {\n    let jsonBuffer = JSON.stringify(buffer);\n    jsonBuffer = jsonBuffer.replace(/[\\u007F-\\uFFFF]/g, function (chr) {\n      return '\\\\u' + ('0000' + chr.charCodeAt(0).toString(16)).substr(-4);\n    });\n    return jsonBuffer;\n  }\n\n  /**\n   * Restrict JSON parsing to the document management service.\n   *\n   * @param buffer\n   */\n  static objectize(buffer: any): any {\n    if (typeof buffer === 'string') {\n      return JSON.parse(buffer);\n    } else {\n      return buffer;\n    }\n  }\n}\n","/*\n    Copyright (C) 2017 Red Hat, Inc.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n            http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n*/\nimport {\n  DocumentType,\n  FIELD_PATH_SEPARATOR,\n  FieldType,\n  IField,\n} from '../contracts/common';\nimport { DocumentDefinition } from './document-definition.model';\n\nexport class EnumValue {\n  name: string;\n  ordinal: number;\n}\n\nexport class Field {\n  private static uuidCounter = 0;\n\n  name: string;\n  classIdentifier: string;\n  displayName: string;\n  path: string;\n  type: FieldType;\n  scope: string | undefined;\n  value: string;\n  column: number;\n  // The field properties read from document inspection result.\n  documentField: IField = { jsonType: '' };\n  parentField: Field;\n  partOfMapping = false;\n  partOfTransformation = false;\n  visibleInCurrentDocumentSearch = true;\n  enumeration = false;\n  enumIndexValue: number;\n  enumValues: EnumValue[] = [];\n  children: Field[] = [];\n  fieldDepth = 0;\n  uuid: string;\n  collapsed = true;\n  hasUnmappedChildren = false;\n  isCollection = false;\n  isArray = false;\n  isAttribute = false;\n  isPrimitive = false;\n  userCreated = false;\n  docDef: DocumentDefinition;\n  namespaceAlias: string | null;\n\n  static fieldHasUnmappedChild(field: Field): boolean {\n    if (field == null) {\n      return false;\n    }\n    if (field.isTerminal()) {\n      return field.partOfMapping === false;\n    }\n    for (const childField of field.children) {\n      if (\n        childField.hasUnmappedChildren ||\n        Field.fieldHasUnmappedChild(childField)\n      ) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  static getFieldPaths(fields: Field[]): string[] {\n    const paths: string[] = [];\n    for (const field of fields) {\n      paths.push(field.path);\n    }\n    return paths;\n  }\n\n  static getFieldNames(fields: Field[]): string[] {\n    const paths: string[] = [];\n    for (const field of fields) {\n      paths.push(field.name);\n    }\n    return paths;\n  }\n\n  static getField(fieldPath: string, fields: Field[]): Field {\n    // TODO: check this non null operator\n    return fields.find((field) => fieldPath === field.path)!;\n  }\n\n  static alphabetizeFields(fields: Field[]): void {\n    const fieldsByPath: { [key: string]: Field } = {};\n    const fieldPaths: string[] = [];\n    for (const field of fields) {\n      let fieldKey = field.path;\n      // Discard duplicate field keys, field names are repeatable.\n      if (fieldsByPath[fieldKey] != null) {\n        continue;\n      }\n      fieldsByPath[fieldKey] = field;\n      fieldPaths.push(fieldKey);\n    }\n    fieldPaths.sort();\n    fields.length = 0;\n    for (const path of fieldPaths) {\n      fields.push(fieldsByPath[path]);\n    }\n\n    for (const field of fields) {\n      if (field.children && field.children.length) {\n        this.alphabetizeFields(field.children);\n      }\n    }\n  }\n\n  constructor() {\n    this.uuid = Field.uuidCounter.toString();\n    Field.uuidCounter++;\n  }\n\n  /**\n   * Expand all fields above the current field.\n   */\n  expandToRoot() {\n    let parent: Field = this;\n    while (parent != null) {\n      parent.collapsed = false;\n      if (parent.isPropertyOrConstant()) {\n        if (parent.docDef) {\n          parent.docDef.showFields = true;\n        }\n      }\n      parent = parent.parentField;\n    }\n  }\n\n  getNameWithNamespace(): string {\n    if (!this.namespaceAlias) {\n      return this.name;\n    }\n    return this.namespaceAlias + ':' + this.name;\n  }\n\n  isParentField(): boolean {\n    if (this.isCollection && !this.isPrimitive) {\n      return true;\n    }\n    return this.type === 'COMPLEX';\n  }\n\n  isStringField(): boolean {\n    return this.type === 'STRING';\n  }\n\n  isTerminal(): boolean {\n    if (this.enumeration) {\n      return true;\n    }\n    if (this.isCollection && !this.isPrimitive) {\n      return false;\n    }\n    return this.type !== 'COMPLEX';\n  }\n\n  copy(): Field {\n    const copy: Field = new Field();\n    Object.assign(copy, this);\n\n    // make these pointers to the same object, not copies\n    copy.documentField = this.documentField;\n    copy.parentField = this.parentField;\n    copy.docDef = this.docDef;\n\n    copy.children = [];\n    for (const childField of this.children) {\n      copy.children.push(childField.copy());\n    }\n    // console.log(\"Copied: \" + this.name, { \"src\": this, \"target\": copy });\n    return copy;\n  }\n\n  copyFrom(that: Field): void {\n    Object.assign(this, that);\n\n    // make these pointers to the same object, not copies\n    this.documentField = that.documentField;\n    this.parentField = that.parentField;\n    this.docDef = that.docDef;\n\n    this.children = [];\n    for (const childField of that.children) {\n      this.children.push(childField.copy());\n    }\n  }\n\n  // @ts-ignore\n  getCollectionParentField(): Field {\n    let parent: Field = this;\n    while (parent != null) {\n      if (parent.isCollection) {\n        return parent;\n      }\n      parent = parent.parentField;\n    }\n  }\n\n  isInCollection(): boolean {\n    return this.getCollectionParentField() != null;\n  }\n\n  getCollectionCount(): number {\n    let count = 0;\n    let field: Field = this;\n    while (field != null) {\n      if (field.isCollection) {\n        count++;\n      }\n      field = field.parentField;\n    }\n    return count;\n  }\n\n  isSource(): boolean {\n    return this.docDef != null && this.docDef.isSource;\n  }\n\n  getCollectionType(): string | null {\n    return this.isCollection ? (this.isArray ? 'ARRAY' : 'LIST') : null;\n  }\n\n  getFieldLabel(showTypes: boolean, includePath: boolean): string {\n    let fieldPath = '';\n    if (includePath) {\n      fieldPath = this.path;\n    } else {\n      const pathComps = this.path.split(FIELD_PATH_SEPARATOR);\n      // Check for a leaf path attribute field starting with '@'\n      if (\n        this.isAttribute &&\n        pathComps.length > 0 &&\n        pathComps[pathComps.length - 1].startsWith('@')\n      ) {\n        fieldPath = this.path.split('@')[1];\n      } else {\n        fieldPath = this.getNameWithNamespace();\n      }\n    }\n    if (showTypes && this.type && !this.isPropertyOrConstant()) {\n      fieldPath += ' (' + this.type + ')';\n    } else if (this.isProperty() && this.value != null) {\n      fieldPath += ' = ' + this.value;\n      if (showTypes && this.type) {\n        fieldPath += ' (' + this.type + ')';\n      }\n    }\n    if (!fieldPath && !this.parentField) {\n      fieldPath = '< Document Root >';\n    }\n    return fieldPath;\n  }\n\n  isPropertyOrConstant(): boolean {\n    return this.docDef == null ? false : this.docDef.isPropertyOrConstant;\n  }\n\n  isProperty(): boolean {\n    return this.docDef == null\n      ? false\n      : this.docDef.type === DocumentType.PROPERTY;\n  }\n\n  isConstant(): boolean {\n    return this.docDef == null\n      ? false\n      : this.docDef.type === DocumentType.CONSTANT;\n  }\n}\n","/*\n    Copyright (C) 2017 Red Hat, Inc.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n            http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n*/\n\nimport { MappedField, MappingModel } from './mapping.model';\n\nexport enum ErrorLevel {\n  DEBUG = 'DEBUG',\n  INFO = 'INFO',\n  WARN = 'WARN',\n  ERROR = 'ERROR',\n}\n\nexport enum ErrorScope {\n  APPLICATION = 'APPLICATION',\n  DATA_SOURCE = 'DATA_SOURCE',\n  LOOKUP_TABLE = 'LOOKUP_TABLE',\n  MAPPING = 'MAPPING',\n  FIELD = 'FIELD',\n  FORM = 'FORM',\n  CONSTANT = 'CONSTANT',\n  PROPERTY = 'PROPERTY',\n}\n\nexport enum ErrorType {\n  INTERNAL = 'INTERNAL',\n  USER = 'USER',\n  VALIDATION = 'VALIDATION',\n  PREVIEW = 'PREVIEW',\n  FORM = 'FORM',\n}\n\nexport class ErrorInfo {\n  private static errorIdentifierCounter = 0;\n  private _identifier: string;\n\n  message: string;\n  level: ErrorLevel;\n  scope: ErrorScope;\n  type: ErrorType;\n  mapping: MappingModel;\n  field: MappedField;\n  object: any;\n\n  constructor(init: Partial<ErrorInfo>) {\n    this._identifier = ErrorInfo.errorIdentifierCounter.toString();\n    ErrorInfo.errorIdentifierCounter++;\n    Object.assign(this, init);\n  }\n\n  get identifier() {\n    return this._identifier;\n  }\n}\n","/*\n    Copyright (C) 2017 Red Hat, Inc.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n            http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n*/\nimport {\n  DocumentType,\n  FIELD_PATH_SEPARATOR,\n  FieldType,\n  InspectionType,\n} from '../contracts/common';\n\nimport { CommonUtil } from '../utils/common-util';\nimport { DocumentInitializationModel } from './config.model';\nimport { Field } from './field.model';\nimport { MappingDefinition } from './mapping-definition.model';\n\nexport class NamespaceModel {\n  private static unqualifiedNamespace: NamespaceModel;\n\n  alias: string;\n  uri: string;\n  locationUri: string | undefined;\n  createdByUser = false;\n  isTarget = false;\n\n  static getUnqualifiedNamespace(): NamespaceModel {\n    if (NamespaceModel.unqualifiedNamespace == null) {\n      const ns: NamespaceModel = new NamespaceModel();\n      ns.alias = 'Unqualified';\n      NamespaceModel.unqualifiedNamespace = ns;\n    }\n    return NamespaceModel.unqualifiedNamespace;\n  }\n\n  getPrettyLabel(): string {\n    if (this === NamespaceModel.getUnqualifiedNamespace()) {\n      return this.alias;\n    }\n    return (\n      (this.isTarget ? 'Target' : this.alias) +\n      ' [' +\n      (this.uri == null ? 'NO URI' : this.uri) +\n      ']'\n    );\n  }\n\n  copy(): NamespaceModel {\n    const copy: NamespaceModel = new NamespaceModel();\n    Object.assign(copy, this);\n    return copy;\n  }\n\n  copyFrom(that: NamespaceModel): void {\n    Object.assign(this, that);\n  }\n}\n\nexport class PaddingField extends Field {\n  constructor(private _isSource: boolean) {\n    super();\n    this.name = '<padding field>';\n    this.classIdentifier = '<padding field>';\n    this.type = FieldType.NONE;\n    this.displayName = '<padding field>';\n    this.path = '';\n  }\n\n  isSource(): boolean {\n    return this._isSource;\n  }\n}\n\nexport class DocumentDefinition {\n  private static padField: Field;\n\n  LEFT_BRACKET = '\\x5b';\n  RIGHT_BRACKET = '\\x5d';\n\n  initModel: DocumentInitializationModel;\n  id: string;\n  _type: DocumentType;\n  name: string;\n  description: string | undefined;\n  uri: string;\n  inspectionType: InspectionType;\n  inspectionParameters: { [key: string]: string };\n  inspectionSource: string;\n  inspectionResult: string;\n  isSource: boolean;\n  isPropertyOrConstant: boolean;\n  selectedRoot: string;\n  classPath: string;\n  initialized = false;\n  errorOccurred = false;\n  fields: Field[] = [];\n  allFields: Field[] = [];\n  terminalFields: Field[] = [];\n  complexFieldsByClassIdentifier: { [key: string]: Field } = {};\n  enumFieldsByClassIdentifier: { [key: string]: Field } = {};\n  fieldsByPath: { [key: string]: Field } = {};\n  fieldPaths: string[] = [];\n  showFields = true;\n  visibleInCurrentDocumentSearch = true;\n  namespaces: NamespaceModel[] = [];\n  characterEncoding: string;\n  locale: string;\n\n  set type(type: DocumentType) {\n    this._type = type;\n    this.isPropertyOrConstant =\n      type === DocumentType.CONSTANT || type === DocumentType.PROPERTY;\n  }\n\n  get type(): DocumentType {\n    return this._type;\n  }\n\n  getComplexField(classIdentifier: string): Field {\n    return this.complexFieldsByClassIdentifier[classIdentifier];\n  }\n\n  getEnumField(classIdentifier: string): Field {\n    return this.enumFieldsByClassIdentifier[classIdentifier];\n  }\n\n  getAllFields(): Field[] {\n    return [...this.allFields];\n  }\n\n  /**\n   * Return true if the specified field name already exists in the specified document definition,\n   * false otherwise.\n   *\n   * @param targetField\n   * @param targetFieldDocDefType\n   */\n  fieldExists(\n    targetField: Field,\n    targetFieldDocDefType: DocumentType\n  ): boolean {\n    for (const field of this.getAllFields()) {\n      if (\n        field.name === targetField.name &&\n        field.docDef.type === targetFieldDocDefType\n      ) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  isFieldsExist(fields: Field[]): boolean {\n    if (fields == null || fields.length === 0) {\n      return true;\n    }\n    const foundFields: Field[] = this.getFields(Field.getFieldPaths(fields));\n    return foundFields != null && fields.length === foundFields.length;\n  }\n\n  getFields(fieldPaths: string[]): Field[] {\n    const fields: Field[] = [];\n    for (const fieldPath of fieldPaths) {\n      const field = this.getField(fieldPath);\n      if (field != null) {\n        fields.push(field);\n      }\n    }\n    return fields;\n  }\n\n  getName(showTypes: boolean): string {\n    let name = this.name;\n    if (showTypes && !this.isPropertyOrConstant) {\n      const type = this.type;\n      if (type) {\n        name += ' (' + type + ')';\n      }\n    }\n    return name;\n  }\n\n  getNamespaceForAlias(alias: string): NamespaceModel {\n    // TODO: check this non null operator\n    return this.namespaces.find((ns) => alias === ns.alias)!;\n  }\n\n  getField(fieldPath: string): Field | null {\n    if (!fieldPath) {\n      return null;\n    }\n    let field: Field = this.fieldsByPath[fieldPath];\n    // if we can't find the field we're looking for, find parent fields and populate their children\n    const pathSeparator: string = FIELD_PATH_SEPARATOR;\n    let originalPath: string = fieldPath;\n    // strip beginning path separator from path\n    if (originalPath != null && originalPath.indexOf(pathSeparator) === 0) {\n      originalPath = originalPath.substring(1);\n    }\n    if (field == null && originalPath.indexOf(pathSeparator) !== -1) {\n      let currentParentPath = '';\n      while (originalPath.indexOf(pathSeparator) !== -1) {\n        const currentPathSection: string = originalPath.substr(\n          0,\n          originalPath.indexOf(pathSeparator)\n        );\n        currentParentPath += pathSeparator + currentPathSection;\n        const parentField: Field = this.fieldsByPath[currentParentPath];\n        if (parentField == null) {\n          if (originalPath.indexOf(pathSeparator) !== -1) {\n            originalPath = originalPath.substr(\n              originalPath.indexOf(pathSeparator) + 1\n            );\n            continue;\n          } else {\n            break;\n          }\n          // https://github.com/atlasmap/atlasmap/issues/1128\n          // throw new Error('Could not populate parent field with path \\''\n          //  + currentParentPath + '\\' (for: ' + fieldPath + ')');\n        }\n        this.populateChildren(parentField);\n        if (originalPath.indexOf(pathSeparator) !== -1) {\n          originalPath = originalPath.substr(\n            originalPath.indexOf(pathSeparator) + 1\n          );\n        }\n      }\n      field = this.fieldsByPath[fieldPath];\n    }\n    return field;\n  }\n\n  getComplexFields(): Field[] {\n    return this.discoverAllComplexFields(this.fields);\n  }\n\n  getTerminalFields(): Field[] {\n    return [...this.terminalFields];\n  }\n\n  initializeFromFields(): void {\n    if (this.type === DocumentType.JAVA) {\n      this.prepareComplexFields();\n    }\n\n    Field.alphabetizeFields(this.fields);\n\n    for (const field of this.fields) {\n      this.populateFieldData(field);\n      this.allFields.push(field);\n      this.populateChildren(field);\n    }\n\n    this.fieldPaths.sort();\n    this.initialized = true;\n  }\n\n  updateField(field: Field, oldPath: string | null): void {\n    Field.alphabetizeFields(this.fields);\n    if (\n      oldPath != null &&\n      oldPath.length > 0 &&\n      this.fieldsByPath[oldPath] != null\n    ) {\n      delete this.fieldsByPath[oldPath];\n      CommonUtil.removeItemFromArray(oldPath, this.fieldPaths);\n    } else {\n      CommonUtil.removeItemFromArray(field.path, this.fieldPaths);\n    }\n    this.populateFieldData(field);\n    this.fieldPaths.sort();\n  }\n\n  addField(field: Field): void {\n    if (!field.parentField || this.isPropertyOrConstant) {\n      this.fields.push(field);\n      Field.alphabetizeFields(this.fields);\n    } else {\n      this.populateChildren(field.parentField);\n      field.parentField.children.push(field);\n      Field.alphabetizeFields(field.parentField.children);\n    }\n    this.populateFieldData(field);\n    this.allFields.push(field);\n    this.fieldPaths.sort();\n  }\n\n  /**\n   * Return true if the passed field is terminal or children are detected, false otherwise.\n   * @param field - target field\n   */\n  populateChildren(field: Field): boolean {\n    // populate complex fields\n    if (field.isTerminal() || field.children.length > 0) {\n      return true;\n    }\n\n    let cachedField = this.getComplexField(field.classIdentifier);\n    if (cachedField == null) {\n      return false;\n    }\n\n    // copy cached field contents\n    cachedField = cachedField.copy();\n    for (let childField of cachedField.children) {\n      childField = childField.copy();\n      childField.parentField = field;\n      this.rewriteFieldPath(childField);\n      this.populateFieldData(childField);\n      field.children.push(childField);\n    }\n\n    if (field.children.length > 0) {\n      this.fieldPaths.sort();\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  private rewriteFieldPath(field: Field) {\n    const parent = field.parentField;\n    const pathSegments = field.path.split(FIELD_PATH_SEPARATOR);\n    field.path = parent.path + FIELD_PATH_SEPARATOR + pathSegments.slice(-1)[0];\n    for (let child of field.children) {\n      this.rewriteFieldPath(child);\n    }\n  }\n\n  /**\n   * Clear all fields in this document.\n   */\n  clearFields(): void {\n    this.initialized = false;\n    this.fields = [];\n    this.allFields = [];\n    this.terminalFields = [];\n    this.fieldPaths = [];\n    this.namespaces = [];\n    this.fieldsByPath = {};\n    this.complexFieldsByClassIdentifier = {};\n    this.enumFieldsByClassIdentifier = {};\n  }\n\n  getFieldIndex(field: Field, fields: Field[]): number {\n    for (let i = 0; i < fields.length; i++) {\n      if (fields[i].path === field.path) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Remove the specified field from this document definition.\n   *\n   * @param field\n   */\n  removeField(field: Field): void {\n    if (field == null) {\n      return;\n    }\n    let targetIndex = this.getFieldIndex(field, this.fields);\n    if (targetIndex > -1) {\n      this.fields.splice(targetIndex, 1);\n    }\n    targetIndex = this.getFieldIndex(field, this.allFields);\n    if (targetIndex > -1) {\n      this.allFields.splice(targetIndex, 1);\n    }\n    targetIndex = this.getFieldIndex(field, this.terminalFields);\n    if (targetIndex > -1) {\n      this.terminalFields.splice(targetIndex, 1);\n    }\n    let oldFieldPath = field.path;\n    CommonUtil.removeItemFromArray(oldFieldPath, this.fieldPaths);\n    delete this.fieldsByPath[oldFieldPath];\n    if (field.parentField != null) {\n      CommonUtil.removeItemFromArray(field, field.parentField.children);\n    }\n  }\n\n  updateFromMappings(mappingDefinition: MappingDefinition): void {\n    if (mappingDefinition === null) {\n      return;\n    }\n\n    for (const field of this.allFields) {\n      field.partOfMapping = false;\n      field.hasUnmappedChildren = false;\n      field.partOfTransformation = false;\n    }\n\n    // FIXME: some of this work is happening N times for N source/target docs, should only happen once.\n    for (const mapping of mappingDefinition.getAllMappings(true)) {\n      for (const field of mapping.getAllFields()) {\n        let parentField = field;\n        // TODO: check this non null operator\n        const partOfTransformation =\n          mapping.getMappedFieldForField(field)!.actions.length > 0;\n        while (parentField != null) {\n          parentField.partOfMapping = true;\n          parentField.partOfTransformation =\n            parentField.partOfTransformation || partOfTransformation;\n          parentField = parentField.parentField;\n        }\n      }\n    }\n    for (const field of this.allFields) {\n      field.hasUnmappedChildren = Field.fieldHasUnmappedChild(field);\n    }\n  }\n\n  private populateFieldData(field: Field): void {\n    field.docDef = this;\n    let newFieldKey = field.path;\n    this.fieldPaths.push(newFieldKey);\n    this.fieldsByPath[newFieldKey] = field;\n\n    if (field.enumeration) {\n      this.enumFieldsByClassIdentifier[field.classIdentifier] = field;\n    }\n    if (field.isTerminal()) {\n      this.terminalFields.push(field);\n    } else {\n      for (const childField of field.children) {\n        this.populateFieldData(childField);\n        this.allFields.push(childField);\n      }\n    }\n  }\n\n  private prepareComplexFields(): void {\n    const fields: Field[] = this.fields;\n\n    // build complex field cache\n    this.discoverComplexFields(fields);\n\n    for (const key in this.complexFieldsByClassIdentifier) {\n      if (!this.complexFieldsByClassIdentifier.hasOwnProperty(key)) {\n        continue;\n      }\n      const cachedField: Field = this.complexFieldsByClassIdentifier[key];\n      // remove children more than one level deep in cached fields\n      for (const childField of cachedField.children) {\n        childField.children = [];\n      }\n      // alphabetize complex field's childrein\n      Field.alphabetizeFields(cachedField.children);\n    }\n  }\n\n  private discoverAllComplexFields(fields: Field[]): Field[] {\n    let complexFields: Field[] = [];\n\n    for (const field of fields) {\n      if (\n        field.type === 'COMPLEX' &&\n        (field.documentField.status === 'SUPPORTED' ||\n          field.documentField.status === 'CACHED')\n      ) {\n        complexFields.push(field.copy());\n      }\n      if (field.children) {\n        complexFields = complexFields.concat(\n          this.discoverAllComplexFields(field.children)\n        );\n      }\n    }\n    return complexFields;\n  }\n\n  private discoverComplexFields(fields: Field[]): void {\n    for (const field of fields) {\n      if (field.type !== 'COMPLEX') {\n        continue;\n      }\n      if (field.documentField.status === 'SUPPORTED') {\n        this.complexFieldsByClassIdentifier[field.classIdentifier] =\n          field.copy();\n      }\n      if (field.children) {\n        this.discoverComplexFields(field.children);\n      }\n    }\n  }\n}\n","/*\n    Copyright (C) 2017 Red Hat, Inc.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n            http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n*/\nimport {\n  CollectionType,\n  DocumentType,\n  InspectionType,\n} from '../contracts/common';\nimport { DocumentDefaultName } from '../common/config.types';\nimport { DocumentDefinition } from './document-definition.model';\nimport { DocumentManagementService } from '../services/document-management.service';\nimport { ErrorHandlerService } from '../services/error-handler.service';\nimport { FieldActionService } from '../services/field-action.service';\nimport { FileManagementService } from '../services/file-management.service';\nimport { InitializationService } from '../services/initialization.service';\nimport { Logger } from 'loglevel';\nimport { MappingDefinition } from './mapping-definition.model';\nimport { MappingExpressionService } from '../services/mapping-expression.service';\nimport { MappingManagementService } from '../services/mapping-management.service';\nimport { MappingPreviewService } from '../services/mapping-preview.service';\n\nexport class DataMapperInitializationModel {\n  dataMapperVersion = '0.9.2017.07.28';\n  initialized = false;\n  loadingStatus = 'Loading.';\n  admHttpTimeout = 30000; // 30 seconds\n  initializationErrorOccurred = false;\n\n  baseJavaInspectionServiceUrl?: string;\n  baseXMLInspectionServiceUrl?: string;\n  baseJSONInspectionServiceUrl?: string;\n  baseCSVInspectionServiceUrl?: string;\n  baseMappingServiceUrl?: string;\n\n  xsrfHeaderName?: string;\n  xsrfCookieName?: string;\n  xsrfDefaultTokenValue?: string;\n\n  /* class path fetching configuration */\n  classPathFetchTimeoutInMilliseconds = 30000;\n  // if classPath is specified, maven call to resolve pom will be skipped\n  pomPayload?: string;\n\n  classPath?: string;\n\n  /* inspection service filtering flags */\n  fieldNameExclusions: string[] = [];\n  classNameExclusions: string[] = [];\n  disablePrivateOnlyFields = false;\n  disableProtectedOnlyFields = false;\n  disablePublicOnlyFields = false;\n  disablePublicGetterSetterFields = false;\n\n  disableMappingPreviewMode = false;\n\n  /* enable the navigation bar and import/export */\n  disableNavbar = true;\n\n  mappingInitialized = false;\n}\n\nexport class DocumentInitializationModel {\n  id: string;\n  type: DocumentType;\n  name: string;\n  description: string;\n  isSource: boolean;\n  showFields = true;\n  inspectionType: InspectionType;\n  inspectionSource: string;\n  inspectionParameters: { [key: string]: string };\n  inspectionResult: string;\n  selectedRoot: string;\n  collectionType?: CollectionType;\n  collectionClassName?: string;\n}\n\n/**\n * The central store of the AtlasMap UI core library. It is expected to be initialized through\n * {@link InitializationService}.\n */\nexport class ConfigModel {\n  private static cfg: ConfigModel = new ConfigModel();\n\n  initCfg: DataMapperInitializationModel = new DataMapperInitializationModel();\n\n  /* current ui state config */\n  showMappingDetailTray = false;\n  showMappingTable = false;\n  showNamespaceTable = false;\n  showLinesAlways = true;\n  showTypes = false;\n  showMappedFields = true;\n  showUnmappedFields = true;\n  _showMappingPreview = false;\n  currentDraggedField: any = null;\n\n  documentService: DocumentManagementService;\n  mappingService: MappingManagementService;\n  errorService: ErrorHandlerService;\n  initializationService: InitializationService;\n  fieldActionService: FieldActionService;\n  fileService: FileManagementService;\n  previewService: MappingPreviewService;\n  expressionService: MappingExpressionService;\n\n  sourceDocs: DocumentDefinition[] = [];\n  targetDocs: DocumentDefinition[] = [];\n  sourcePropertyDoc: DocumentDefinition = new DocumentDefinition();\n  targetPropertyDoc: DocumentDefinition = new DocumentDefinition();\n  constantDoc: DocumentDefinition = new DocumentDefinition();\n  mappingFiles: string[] = [];\n  mappingDefinitionId = 0;\n  mappings: MappingDefinition | null = null;\n\n  preloadedMappingJson: string | null = null;\n  preloadedFieldActionMetadata: any;\n  logger?: Logger;\n\n  constructor() {\n    this.setConstantPropertyDocs();\n  }\n\n  static getConfig(): ConfigModel {\n    return ConfigModel.cfg;\n  }\n\n  static setConfig(cfg: ConfigModel): void {\n    ConfigModel.cfg = cfg;\n  }\n\n  initializePropertyDoc(propertyDoc: DocumentDefinition, isSource: boolean) {\n    propertyDoc.clearFields();\n    propertyDoc.type = DocumentType.PROPERTY;\n    propertyDoc.name = DocumentDefaultName.PROPERTIES;\n    propertyDoc.id =\n      'DOC.' +\n      propertyDoc.name +\n      '.' +\n      Math.floor(Math.random() * 1000000 + 1).toString();\n    propertyDoc.isSource = isSource;\n    propertyDoc.showFields = false;\n    propertyDoc.isPropertyOrConstant = true;\n  }\n\n  setConstantPropertyDocs(): void {\n    this.initializePropertyDoc(this.sourcePropertyDoc, true);\n    this.initializePropertyDoc(this.targetPropertyDoc, false);\n    this.constantDoc.clearFields();\n    this.constantDoc.type = DocumentType.CONSTANT;\n    this.constantDoc.name = DocumentDefaultName.CONSTANTS;\n    this.constantDoc.id =\n      'DOC.' +\n      this.constantDoc.name +\n      '.' +\n      Math.floor(Math.random() * 1000000 + 1).toString();\n    this.constantDoc.isSource = true;\n    this.constantDoc.showFields = false;\n    this.constantDoc.isPropertyOrConstant = true;\n  }\n\n  set showMappingPreview(show: boolean) {\n    this._showMappingPreview = show;\n  }\n\n  get showMappingPreview(): boolean {\n    return this._showMappingPreview;\n  }\n\n  addDocument(docInitModel: DocumentInitializationModel): DocumentDefinition {\n    const docDef: DocumentDefinition = new DocumentDefinition();\n    docDef.initModel = docInitModel;\n    docDef.id = docInitModel.id;\n    docDef.type = docInitModel.type;\n    docDef.name = docInitModel.name;\n    docDef.description = docInitModel.description;\n    docDef.isSource = docInitModel.isSource;\n    docDef.showFields = docInitModel.showFields;\n    docDef.inspectionType = docInitModel.inspectionType;\n    docDef.inspectionSource = docInitModel.inspectionSource;\n    docDef.inspectionResult = docInitModel.inspectionResult;\n    docDef.inspectionParameters = docInitModel.inspectionParameters;\n    docDef.selectedRoot = docInitModel.selectedRoot;\n\n    if (docDef.type === DocumentType.XSD) {\n      docDef.uri = 'atlas:xml:' + docDef.id;\n    } else if (docDef.type === DocumentType.JAVA) {\n      docDef.uri = `atlas:java:${docDef.id}?className=${docDef.inspectionSource}`;\n      if (\n        docInitModel.collectionType &&\n        docInitModel.collectionType !== CollectionType.NONE\n      ) {\n        docDef.uri += '&collectionType=' + docInitModel.collectionType;\n        if (docInitModel.collectionClassName) {\n          docDef.uri +=\n            '&collectionClassName=' + docInitModel.collectionClassName;\n        }\n      }\n    } else {\n      docDef.uri = 'atlas:' + docDef.type.toLowerCase() + ':' + docDef.id;\n    }\n\n    if (docInitModel.isSource) {\n      this.sourceDocs.push(docDef);\n    } else {\n      this.targetDocs.push(docDef);\n    }\n    return docDef;\n  }\n\n  addDocuments(docModels: DocumentInitializationModel[]): DocumentDefinition[] {\n    const docDefs: DocumentDefinition[] = [];\n    for (const docModel of docModels) {\n      docDefs.push(this.addDocument(docModel));\n    }\n    return docDefs;\n  }\n\n  getDocsWithoutPropertyDoc(isSource: boolean): DocumentDefinition[] {\n    return isSource ? [...this.sourceDocs] : [...this.targetDocs];\n  }\n\n  getDocs(isSource: boolean): DocumentDefinition[] {\n    const docs: DocumentDefinition[] = this.getDocsWithoutPropertyDoc(isSource);\n    return isSource\n      ? [this.sourcePropertyDoc, this.constantDoc].concat(docs)\n      : [this.targetPropertyDoc].concat(docs);\n  }\n\n  /**\n   * Clear source/target/mapping documents from the model.  Reset constant and property document definitions.\n   */\n  clearDocs(): void {\n    this.sourceDocs = [];\n    this.targetDocs = [];\n    this.sourcePropertyDoc.clearFields();\n    this.targetPropertyDoc.clearFields();\n    this.constantDoc.clearFields();\n    this.mappingFiles = [];\n  }\n\n  hasJavaDocuments(): boolean {\n    for (const doc of this.getAllDocs()) {\n      if (doc.type === DocumentType.JAVA) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  getDocForIdentifier(\n    documentId: string,\n    isSource: boolean\n  ): DocumentDefinition | null {\n    // TODO: check this non null operator\n    return this.getDocs(isSource).find((d) => d.id === documentId)!;\n  }\n\n  getFirstXmlDoc(isSource: boolean): DocumentDefinition {\n    const docs: DocumentDefinition[] = this.getDocsWithoutPropertyDoc(isSource);\n    // TODO: check this non null operator\n    return docs.find((doc) => doc.type === DocumentType.XML)!;\n  }\n\n  getAllDocs(): DocumentDefinition[] {\n    return [this.sourcePropertyDoc, this.constantDoc]\n      .concat(this.sourceDocs)\n      .concat(this.targetPropertyDoc)\n      .concat(this.targetDocs);\n  }\n\n  documentsAreLoaded(): boolean {\n    for (const doc of this.getAllDocs()) {\n      if (!doc.initialized) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\n","/*\n    Copyright (C) 2017 Red Hat, Inc.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n            http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n*/\n\nexport class Examples {\n  static pom = `\n    <project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n        xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n        xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n\n        <modelVersion>4.0.0</modelVersion>\n        <groupId>foo.bar</groupId>\n        <artifactId>test.model</artifactId>\n        <version>1.10.0</version>\n        <packaging>jar</packaging>\n        <name>Test :: Model</name>\n\n        <dependencies>\n            <dependency>\n                <groupId>com.fasterxml.jackson.core</groupId>\n                <artifactId>jackson-annotations</artifactId>\n                <version>2.8.5</version>\n            </dependency>\n            <dependency>\n                <groupId>com.fasterxml.jackson.core</groupId>\n                <artifactId>jackson-databind</artifactId>\n                <version>2.8.5</version>\n            </dependency>\n            <dependency>\n                <groupId>com.fasterxml.jackson.core</groupId>\n                <artifactId>jackson-core</artifactId>\n                <version>2.8.5</version>\n            </dependency>\n        </dependencies>\n    </project>\n  `;\n}\n","/*\n    Copyright (C) 2017 Red Hat, Inc.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n            http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n*/\nimport { ErrorInfo, ErrorLevel, ErrorScope, ErrorType } from './error.model';\nimport { MappedField, MappingModel } from './mapping.model';\n\nimport { ConfigModel } from './config.model';\nimport { IExpressionNode } from '../contracts/expression';\nimport { Subject } from 'rxjs';\n\nexport class ExpressionUpdatedEvent {\n  constructor(public node?: ExpressionNode, public offset?: number) {}\n}\n\nexport abstract class ExpressionNode implements IExpressionNode {\n  protected static sequence = 0;\n  public readonly uuid: string;\n  public readonly str: string;\n\n  constructor(prefix: string) {\n    this.uuid = prefix + ExpressionNode.sequence++;\n  }\n\n  getUuid() {\n    return this.uuid;\n  }\n\n  abstract toText(): string;\n  abstract toHTML(): string;\n}\n\nexport class TextNode extends ExpressionNode {\n  static readonly PREFIX = 'expression-text-';\n\n  constructor(public str: string) {\n    super(TextNode.PREFIX);\n  }\n\n  toText(): string {\n    return this.str;\n  }\n\n  toHTML(): string {\n    return `<span id=\"${this.uuid}\">${this.str.replace(/ /g, '&nbsp;')}</span>`;\n  }\n}\n\nexport class FieldNode extends ExpressionNode {\n  static readonly PREFIX = 'expression-field-';\n\n  constructor(\n    private mapping: MappingModel,\n    public mappedField?: MappedField | null,\n    public metaStr?: string,\n    index: number = 0,\n    public collectionContextPath?: string\n  ) {\n    super(FieldNode.PREFIX);\n    if (!mappedField) {\n      if (metaStr) {\n        const fieldParts = metaStr.split(':');\n\n        // Relative paths will not have the full field path in the meta data.\n        if (fieldParts.length === 1) {\n          if (collectionContextPath) {\n            this.mappedField = mapping.getMappedFieldByPath(\n              collectionContextPath + fieldParts[0],\n              true\n            )!;\n          } else {\n            this.mappedField = mapping.getMappedFieldByPath(\n              fieldParts[0],\n              true\n            )!;\n          }\n        } else {\n          this.mappedField = mapping.getMappedFieldByPath(\n            fieldParts[1],\n            true,\n            fieldParts[0]\n          )!;\n        }\n        if (!this.mappedField) {\n          this.mappedField = mapping.getReferenceField(\n            fieldParts[0],\n            fieldParts[1]\n          );\n        }\n      } else {\n        this.mappedField = mapping.getMappedFieldForIndex(\n          (index + 1)?.toString(),\n          true\n        )!;\n      }\n      mappedField = this.mappedField;\n    }\n  }\n\n  toText(): string {\n    if (!this.mappedField || !this.mappedField.field) {\n      return '';\n    }\n    if (this.mappedField.field.enumeration) {\n      // Convert enumeration field/index pairs into a string literal.\n      const enumIdxVal = this.mappedField.field.enumIndexValue\n        ? this.mappedField.field.enumIndexValue\n        : 0;\n      return '\"' + this.mappedField.field.enumValues[enumIdxVal].name + '\"';\n    } else {\n      let textStr = '${';\n\n      // If the mapped field's parent is a complex reference field then only use the leaf.\n      if (\n        this.mappedField.field.parentField &&\n        this.mappedField.field.parentField ===\n          this.mapping.referenceFields[0]?.field\n      ) {\n        textStr += '/' + this.mappedField.field.name + '}';\n      } else {\n        textStr +=\n          this.mappedField.field.docDef.id +\n          ':' +\n          this.mappedField.field.path +\n          '}';\n      }\n      return textStr;\n    }\n  }\n\n  toHTML(): string {\n    if (this.mappedField && this.mappedField.field) {\n      let titleAddendum = '';\n      let mappedFieldName = this.mappedField.field.name;\n      if (this.mappedField.field.enumeration) {\n        const enumIdxVal = this.mappedField.field.enumIndexValue\n          ? this.mappedField.field.enumIndexValue\n          : 0;\n        mappedFieldName +=\n          '.' + this.mappedField.field.enumValues[enumIdxVal].name;\n        titleAddendum = ':  Click to select an enumeration value.';\n      }\n      return `<span style=\"font-weight:bold\" contenteditable=\"false\" id=\"${this.uuid}\" title=\"${this.mappedField.field.docDef.name}:${this.mappedField.field.path}${titleAddendum}\"\n        class=\"expressionFieldLabel label label-default\">${mappedFieldName}</span>`;\n    } else {\n      // TODO: check this non null operator\n      return `<span contenteditable=\"false\" id=\"${this.uuid}\"\n        title=\"Field index '${\n          this.mapping.getIndexForMappedField(this.mappedField!)! - 1\n        }' is not available\"\n        class=\"expressionFieldLabel label label-danger\">N/A</span>`;\n    }\n  }\n\n  hasComplexField(): boolean {\n    return (\n      this.mappedField?.field?.documentField.fieldType === 'COMPLEX' &&\n      (this.mappedField?.field?.documentField.status === 'SUPPORTED' ||\n        this.mappedField?.field?.documentField.status === 'CACHED')\n    );\n  }\n}\n\nexport class ExpressionModel {\n  expressionHTML = '';\n  expressionUpdatedSource = new Subject<ExpressionUpdatedEvent>();\n  expressionUpdated$ = this.expressionUpdatedSource.asObservable();\n\n  private _hasComplexField: boolean;\n  private _nodes: ExpressionNode[] = [];\n  private textCache = '';\n\n  constructor(private mapping: MappingModel, private cfg: ConfigModel) {}\n\n  generateInitialExpression() {\n    this.mapping\n      .getUserMappedFields(true)\n      .forEach((f) => this.appendFieldNode(f));\n  }\n\n  get hasComplexField(): boolean {\n    return this._hasComplexField;\n  }\n\n  set hasComplexField(value: boolean) {\n    this._hasComplexField = value;\n  }\n\n  get nodes(): ReadonlyArray<ExpressionNode> {\n    return this._nodes;\n  }\n\n  getLastNodeIndex() {\n    return this._nodes.length - 1;\n  }\n\n  getLastNode() {\n    return this._nodes[this.getLastNodeIndex()];\n  }\n\n  getNode(nodeId?: string): any {\n    if (!nodeId) {\n      return this.getLastNode();\n    }\n    return this._nodes.find((n) => n.getUuid() === nodeId);\n  }\n\n  setConfigModel(cfg: ConfigModel) {\n    this.cfg = cfg;\n  }\n\n  /**\n   * Clear all text from the specified TextNode offset range or from the '@' to\n   * the end of the text node if no node ID is specified.\n   *\n   * Return the new UUID position indicator string or null.\n   *\n   * @param nodeId\n   * @param startOffset\n   * @param endOffset\n   */\n  clearText(\n    nodeId?: string,\n    startOffset?: number,\n    endOffset?: number\n  ): TextNode | null {\n    let targetNode: TextNode | null = null;\n    if (!nodeId) {\n      const lastNode = this.getLastNode();\n      if (!(lastNode instanceof TextNode)) {\n        return null;\n      }\n      const keyPos = lastNode.str.indexOf('@');\n      if (keyPos !== -1) {\n        targetNode = lastNode;\n        targetNode.str = targetNode.str.substring(0, keyPos);\n      }\n    } else {\n      const node = this._nodes.find((n) => n.getUuid() === nodeId);\n      if (!(node instanceof TextNode) || !endOffset) {\n        return null;\n      }\n      targetNode = node;\n      // TODO: check this non null operator\n      const cleanStr = targetNode.str.replace(\n        targetNode.str.substring(startOffset!, endOffset),\n        ''\n      );\n      targetNode.str = cleanStr;\n    }\n    this.updateCache();\n    this.expressionUpdatedSource.next();\n    return targetNode;\n  }\n\n  /**\n   * Insert text into expression at specified position. If nodeId is not specified,\n   * it will be added to the end of expression. It parses the string\n   * and insert a set of TextNode & FieldNode if it contains field reference like ${0},\n   * otherwise just one TextNode.\n   * This emits ExpressionUpdatedEvent which contains the latest node and offset it\n   * worked on, so that the subscriber can determine where to put the caret in\n   * the expression input widget. If ExpressionUpdatedEvent is undefined, it means that\n   * it worked on the end of the expression.\n   * @param str string to insert\n   * @param nodeId target node to insert the string\n   * @param offset position offset in the target node to insert the string\n   */\n  insertText(str: string, nodeId?: string, offset?: number) {\n    this.insertNodes(this.createNodesFromText(str), nodeId, offset);\n  }\n\n  /**\n   * Insert an array of ExpressionNodes at the specified position. If insertPosition is\n   * not specified the nodes will be appended to the end of the expression.\n   * This emits an ExpressionUpdatedEvent which contains the latest node and offset it\n   * worked on, so that the subscriber can determine where to put the caret in\n   * the expression input widget. If ExpressionUpdatedEvent is undefined, it means that\n   * it worked on the end of the expression.\n   *\n   * @param newNodes an array of ExpressionNode to add\n   * @param insertPosition target node to insert the string\n   * @param offset position offset in the target node to insert the string\n   */\n  insertNodes(\n    newNodes: ExpressionNode[],\n    insertPosition?: string,\n    offset?: number\n  ) {\n    // No position was specified - append to the end\n    if (!insertPosition) {\n      const last = this.getLastNode();\n      if (!last) {\n        this._nodes.push(...newNodes);\n      } else if (last instanceof TextNode && newNodes[0] instanceof TextNode) {\n        (last as TextNode).str += (newNodes[0] as TextNode).str;\n        newNodes.splice(0, 1, last);\n        this._nodes.splice(this.getLastNodeIndex(), 1, ...newNodes);\n      } else if (\n        last instanceof FieldNode &&\n        newNodes[0] instanceof FieldNode\n      ) {\n        this._nodes.splice(\n          this.getLastNodeIndex(),\n          0,\n          new TextNode(' + '),\n          ...newNodes\n        );\n      } else {\n        this._nodes.push(...newNodes);\n      }\n      this.updateCache();\n      this.expressionUpdatedSource.next();\n      return;\n    }\n\n    // Requires position handling\n    const updatedEvent = new ExpressionUpdatedEvent();\n    const targetNode = this._nodes.find((n) => n.getUuid() === insertPosition);\n    // TODO: check this non null operator\n    const targetNodeIndex = this._nodes.indexOf(targetNode!);\n\n    if (targetNode instanceof TextNode) {\n      if (offset === undefined || offset === null || offset < 0) {\n        offset = targetNode.str.length;\n      }\n      const pre = targetNode.str.substring(0, offset);\n      const post = targetNode.str.substring(offset);\n      if (pre.length > 0) {\n        if (newNodes[0] instanceof TextNode) {\n          targetNode.str = pre + (newNodes[0] as TextNode).str;\n          newNodes.splice(0, 1, targetNode);\n        } else {\n          targetNode.str = pre;\n          newNodes.splice(0, 0, targetNode);\n        }\n      }\n      if (post.length > 0) {\n        const lastNewNodeIndex = newNodes.length - 1;\n        if (newNodes[lastNewNodeIndex] instanceof TextNode) {\n          let mergedTextNode: TextNode;\n          if (pre.length > 0) {\n            mergedTextNode = newNodes[lastNewNodeIndex] as TextNode;\n            mergedTextNode.str += post;\n          } else {\n            mergedTextNode = targetNode;\n            mergedTextNode.str =\n              (newNodes[lastNewNodeIndex] as TextNode).str + post;\n          }\n          newNodes.splice(lastNewNodeIndex, 1, mergedTextNode);\n        } else {\n          if (pre.length > 0) {\n            newNodes.push(new TextNode(post));\n          } else {\n            targetNode.str = post;\n            newNodes.push(targetNode);\n          }\n        }\n      }\n      this._nodes.splice(targetNodeIndex, 1, ...newNodes);\n      const lastAddedIndex = targetNodeIndex + newNodes.length - 1;\n      if (\n        this._nodes[lastAddedIndex] instanceof FieldNode &&\n        this.nodes[lastAddedIndex + 1] instanceof FieldNode\n      ) {\n        // insert a glue in between FieldNodes so that it won't break syntax and caret can go into\n        const space = new TextNode(' + ');\n        this._nodes.splice(lastAddedIndex + 1, 0, space);\n        updatedEvent.node = space;\n        updatedEvent.offset = 1;\n      } else if (this._nodes[lastAddedIndex] instanceof FieldNode) {\n        updatedEvent.node = this._nodes[lastAddedIndex + 1];\n        updatedEvent.offset = 0;\n      } else {\n        updatedEvent.node = this._nodes[lastAddedIndex];\n        updatedEvent.offset =\n          (this._nodes[lastAddedIndex] as TextNode).str.length - post.length;\n      }\n      this.updateCache();\n      this.expressionUpdatedSource.next(updatedEvent);\n      return;\n    }\n\n    // targetNode is a FieldNode - insert the text before it if offset is 0, otherwise after it\n    if (offset !== 0 && newNodes[0] instanceof FieldNode) {\n      // insert a glue in between FieldNodes so that it won't break syntax and caret can go into\n      newNodes.splice(0, 0, new TextNode(' + '));\n    }\n    const nextNodeIndex = offset === 0 ? targetNodeIndex : targetNodeIndex + 1;\n    const nextNode = this._nodes[nextNodeIndex];\n    if (\n      nextNode instanceof TextNode &&\n      newNodes[newNodes.length - 1] instanceof TextNode\n    ) {\n      updatedEvent.offset = (\n        newNodes[newNodes.length - 1] as TextNode\n      ).str.length;\n      nextNode.str =\n        (newNodes[newNodes.length - 1] as TextNode).str +\n        (nextNode as TextNode).str;\n      newNodes.pop();\n      this._nodes.splice(nextNodeIndex, 1, ...newNodes);\n      updatedEvent.node = nextNode;\n    } else if (\n      nextNode instanceof FieldNode &&\n      newNodes[newNodes.length - 1] instanceof FieldNode\n    ) {\n      // insert a glue in between FieldNodes so that it won't break syntax and caret can go into\n      const space = new TextNode(' + ');\n      this._nodes.splice(nextNodeIndex, 0, ...newNodes, space);\n      updatedEvent.node = space;\n      updatedEvent.offset = 1;\n    } else {\n      this._nodes.splice(nextNodeIndex, 0, ...newNodes);\n      if (nextNode instanceof TextNode) {\n        updatedEvent.node = nextNode;\n        updatedEvent.offset = 0;\n      } else {\n        updatedEvent.node = newNodes[newNodes.length - 1];\n        updatedEvent.offset = (\n          newNodes[newNodes.length - 1] as TextNode\n        ).str.length;\n      }\n    }\n    this.updateCache();\n    this.expressionUpdatedSource.next(updatedEvent);\n  }\n\n  removeToken(tokenPosition?: string, offset?: number, removeNext?: boolean) {\n    // No position was specified - remove from the end\n    if (!tokenPosition) {\n      const last = this.getLastNode();\n      if (!last) {\n        return;\n      }\n      if (last instanceof FieldNode) {\n        const removed = this._nodes.pop() as FieldNode;\n        if (\n          !this._nodes.find(\n            (n) =>\n              n instanceof FieldNode && n.mappedField === removed.mappedField\n          )\n        ) {\n          // TODO: check this non null operator\n          this.mapping.removeField(removed.mappedField!.field!);\n          this.cfg.mappingService.updateMappedField(this.mapping);\n        }\n      } else if (last instanceof TextNode) {\n        if (last.str.length > 0) {\n          last.str = last.str.substring(0, last.str.length - 1);\n        }\n        if (last.str.length === 0) {\n          this._nodes.pop();\n        }\n      }\n      this.updateCache();\n      this.expressionUpdatedSource.next();\n      return;\n    }\n\n    // Requires position handling\n    let updatedEvent: ExpressionUpdatedEvent | undefined =\n      new ExpressionUpdatedEvent();\n    let targetNode = this._nodes.find((n) => n.getUuid() === tokenPosition);\n    // TODO: check this non null operator\n    let targetNodeIndex = this._nodes.indexOf(targetNode!);\n    if (removeNext) {\n      targetNodeIndex++;\n      targetNode = this._nodes[targetNodeIndex];\n    }\n    if (!targetNode || offset === -1) {\n      if (targetNodeIndex < 1) {\n        return;\n      }\n      targetNode = this._nodes[--targetNodeIndex];\n      offset =\n        targetNode instanceof TextNode\n          ? (targetNode as TextNode).str.length\n          : 1;\n    }\n    if (targetNode instanceof FieldNode) {\n      const removed = this._nodes.splice(targetNodeIndex, 1);\n      const targetFieldNode: FieldNode = removed[0] as FieldNode;\n      if (\n        !this._nodes.find(\n          (n) =>\n            n instanceof FieldNode &&\n            n.mappedField === targetFieldNode.mappedField\n        )\n      ) {\n        // TODO: check this non null operator\n        this.mapping.removeField(targetFieldNode.mappedField!.field!);\n        this.cfg.mappingService.updateMappedField(this.mapping);\n      }\n      if (this._nodes.length > targetNodeIndex) {\n        if (\n          this._nodes[targetNodeIndex - 1] instanceof TextNode &&\n          this._nodes[targetNodeIndex] instanceof TextNode\n        ) {\n          const newOffset = (this._nodes[targetNodeIndex - 1] as TextNode).str\n            .length;\n          (this._nodes[targetNodeIndex - 1] as TextNode).str += (\n            this._nodes[targetNodeIndex] as TextNode\n          ).str;\n          this._nodes.splice(targetNodeIndex, 1);\n          updatedEvent.node = this._nodes[targetNodeIndex - 1];\n          updatedEvent.offset = newOffset;\n        } else if (\n          this._nodes[targetNodeIndex - 1] instanceof FieldNode &&\n          this._nodes[targetNodeIndex] instanceof FieldNode\n        ) {\n          const glue = new TextNode(' + ');\n          this._nodes.splice(targetNodeIndex, 0, glue);\n          updatedEvent.node = glue;\n          updatedEvent.offset = 3;\n        } else if (this._nodes[targetNodeIndex - 1] instanceof TextNode) {\n          updatedEvent.node = this._nodes[targetNodeIndex - 1];\n          updatedEvent.offset = (\n            this._nodes[targetNodeIndex - 1] as TextNode\n          ).str.length;\n        } else if (this._nodes[targetNodeIndex] instanceof TextNode) {\n          updatedEvent.node = this._nodes[targetNodeIndex];\n          updatedEvent.offset = 0;\n        }\n      } else {\n        // end of line\n        updatedEvent = undefined;\n      }\n    } else {\n      const targetString = (targetNode as TextNode).str;\n\n      // Remove empty string text node.\n      if (targetString.length === 1) {\n        this._nodes.splice(targetNodeIndex, 1);\n      } else {\n        (targetNode as TextNode).str =\n          offset === 0\n            ? targetString.substr(1)\n            : targetString.substring(0, offset) +\n              targetString.substring(offset! + 1);\n        updatedEvent.node = targetNode;\n        updatedEvent.offset = offset;\n      }\n    }\n    this.updateCache();\n    this.expressionUpdatedSource.next(updatedEvent);\n  }\n\n  /**\n   * Replace the content of the last text node with a substring terminating at the\n   * specified index.\n   *\n   * @param index\n   */\n  clearToEnd(index: number): void {\n    const last = this.getLastNode();\n    if (!(last instanceof TextNode)) {\n      return;\n    }\n    last.str = last.str.substring(0, index);\n  }\n\n  /**\n   * Reflect mapped source fields to the field references in the expression.\n   * Selected source fields are inserted into or appended to the expression,\n   * and unselected source fields are removed from expression.\n   *\n   * @param mapping Corresponding MappingModel object\n   * @param insertPosition\n   * @param offset\n   */\n  updateFieldReference(\n    mapping: MappingModel,\n    insertPosition?: string,\n    offset?: number\n  ) {\n    const mappedFields = mapping.getUserMappedFields(true);\n    const referenceFields = mapping.getReferenceMappedFields();\n    let fieldNodes = this._nodes.filter(\n      (n) => n instanceof FieldNode\n    ) as FieldNode[];\n\n    // Remove non-reference fields from the expression if unmapped.\n    for (const node of fieldNodes) {\n      // TODO: check this non null operator\n      if (\n        mappedFields.includes(node.mappedField!) ||\n        referenceFields.includes(node.mappedField!) ||\n        node.hasComplexField()\n      ) {\n        continue;\n      }\n      const index = this._nodes.indexOf(node);\n      this._nodes.splice(index, 1);\n      if (\n        this._nodes.length > index &&\n        this._nodes[index - 1] instanceof TextNode &&\n        this._nodes[index] instanceof TextNode\n      ) {\n        (this._nodes[index - 1] as TextNode).str += (\n          this._nodes[index] as TextNode\n        ).str;\n        this._nodes.splice(index, 1);\n      }\n    }\n\n    // Add any non-reference mapped fields into the expression - append if no insert\n    // position is specified.\n    fieldNodes = this._nodes.filter(\n      (n) => n instanceof FieldNode\n    ) as FieldNode[];\n    for (const mfield of mappedFields) {\n      if (\n        !fieldNodes.find((n) => n.mappedField === mfield) &&\n        !referenceFields.find((r) => r.field === mfield.field)\n      ) {\n        if (insertPosition) {\n          this.insertNodes(\n            [new FieldNode(this.mapping, mfield)],\n            insertPosition,\n            offset\n          );\n        } else {\n          this.appendFieldNode(mfield);\n        }\n      }\n    }\n    this.updateCache();\n    this.expressionUpdatedSource.next();\n  }\n\n  clear() {\n    this._nodes = [];\n    this.updateCache();\n    this.expressionUpdatedSource.next();\n  }\n\n  toText() {\n    if (this.textCache.length === 0) {\n      this.updateCache();\n    }\n    return this.textCache;\n  }\n\n  toHTML() {\n    if (this.expressionHTML.length === 0) {\n      this.updateCache();\n    }\n    return this.expressionHTML;\n  }\n\n  addConditionalExpressionNode(\n    mappedField: MappedField,\n    nodeId: string,\n    offset: number\n  ): void {\n    this.insertNodes(\n      [new FieldNode(this.mapping, mappedField)],\n      nodeId,\n      offset\n    );\n  }\n\n  private updateCache() {\n    let answer = '';\n    this._nodes.forEach((node) => (answer += node.toText()));\n    this.textCache = answer;\n    answer = '';\n    this._nodes.forEach((node) => (answer += node.toHTML()));\n    this.expressionHTML = answer; // trigger expr box render\n  }\n\n  /**\n   * Translate an expression string into an array of text nodes and field nodes.  Handle\n   * relative paths for collection-based field references.\n   *\n   * @param text\n   */\n  private createNodesFromText(text: string): ExpressionNode[] {\n    const answer = [];\n    let position = -1;\n    let collectionContextFieldNode = null;\n\n    while (text.search(/\\$\\{[a-zA-Z0-9.:/<>[\\]_-]+\\}/) !== -1) {\n      position = text.search(/\\$/);\n      if (position !== 0) {\n        answer.push(new TextNode(text.substring(0, position)));\n      }\n      const nodeMetaVal = text.substring(position + 2, text.indexOf('}'));\n      let fn = null;\n      if (isNaN(Number(nodeMetaVal))) {\n        fn = collectionContextFieldNode\n          ? new FieldNode(\n              this.mapping,\n              undefined,\n              nodeMetaVal,\n              undefined,\n              collectionContextFieldNode.mappedField?.field?.path!\n            )\n          : new FieldNode(this.mapping, undefined, nodeMetaVal);\n      } else {\n        const index = parseInt(nodeMetaVal, 10);\n        fn = new FieldNode(this.mapping, undefined, undefined, index);\n      }\n\n      if (!fn || !fn.mappedField) {\n        this.cfg.errorService.addError(\n          new ErrorInfo({\n            message: `Unable to map expression element '${nodeMetaVal}' to a field node.`,\n            level: ErrorLevel.ERROR,\n            scope: ErrorScope.MAPPING,\n            type: ErrorType.INTERNAL,\n            mapping: this.mapping,\n          })\n        );\n      } else {\n        if (fn.mappedField?.field?.isCollection) {\n          collectionContextFieldNode = fn;\n        }\n        answer.push(fn);\n      }\n      text = text.substring(text.indexOf('}') + 1);\n    }\n    if (text.length > 0) {\n      answer.push(new TextNode(text));\n    }\n    return answer;\n  }\n\n  private appendFieldNode(mfield: MappedField) {\n    const lastNode = this._nodes.pop();\n    if (lastNode instanceof FieldNode) {\n      this._nodes.push(lastNode, new TextNode(' + '));\n    } else if (lastNode instanceof TextNode) {\n      if (lastNode.str.length === 0) {\n        this._nodes.push(new TextNode(' + '));\n      } else {\n        this._nodes.push(lastNode);\n      }\n    }\n    this._nodes.push(new FieldNode(this.mapping, mfield));\n  }\n}\n","/*\n    Copyright (C) 2017 Red Hat, Inc.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n            http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n*/\nimport { ExpressionModel } from './expression.model';\nimport { FieldAction } from './field-action.model';\n\nexport enum TransitionMode {\n  ONE_TO_ONE = 'ONE_TO_ONE',\n  ONE_TO_MANY = 'ONE_TO_MANY',\n  ENUM = 'ENUM',\n  MANY_TO_ONE = 'MANY_TO_ONE',\n  FOR_EACH = 'FOR_EACH',\n  EXPRESSION = 'EXPRESSION',\n}\n\nexport enum TransitionDelimiter {\n  NONE,\n  AMPERSAND,\n  AT_SIGN,\n  BACKSLASH,\n  COLON,\n  COMMA,\n  DASH,\n  EQUAL,\n  HASH,\n  PERIOD,\n  PIPE,\n  SEMICOLON,\n  SLASH,\n  SPACE,\n  UNDERSCORE,\n  USER_DEFINED,\n}\n\nexport class TransitionDelimiterModel {\n  delimiter: TransitionDelimiter = TransitionDelimiter.SPACE;\n  serializedValue: string | null = null;\n  prettyName: string | null = null;\n  actualDelimiter = '';\n\n  constructor(\n    delimiter: TransitionDelimiter,\n    serializedValue: string | null,\n    prettyName: string,\n    actualDelimiter: string\n  ) {\n    this.delimiter = delimiter;\n    this.serializedValue = serializedValue;\n    this.prettyName = prettyName;\n    this.actualDelimiter = actualDelimiter;\n  }\n}\n\nexport class TransitionModel {\n  static delimiterModels: TransitionDelimiterModel[] = [];\n\n  mode: TransitionMode = TransitionMode.ONE_TO_ONE;\n  delimiter: TransitionDelimiter = TransitionDelimiter.SPACE;\n  userDelimiter = '';\n  lookupTableName: string | null = null;\n  expression!: ExpressionModel;\n  enableExpression = false;\n  transitionFieldAction: FieldAction | null = null;\n\n  constructor() {\n    TransitionModel.initialize();\n  }\n\n  static initialize() {\n    if (TransitionModel.delimiterModels.length === 0) {\n      const models: TransitionDelimiterModel[] = [];\n      models.push(\n        new TransitionDelimiterModel(\n          TransitionDelimiter.NONE,\n          null,\n          '[None]',\n          ''\n        )\n      );\n      models.push(\n        new TransitionDelimiterModel(\n          TransitionDelimiter.AMPERSAND,\n          'Ampersand',\n          'Ampersand [&]',\n          '&'\n        )\n      );\n      models.push(\n        new TransitionDelimiterModel(\n          TransitionDelimiter.AT_SIGN,\n          'AtSign',\n          'At Sign [@]',\n          '@'\n        )\n      );\n      models.push(\n        new TransitionDelimiterModel(\n          TransitionDelimiter.BACKSLASH,\n          'Backslash',\n          'Backslash [\\\\]',\n          '\\\\'\n        )\n      );\n      models.push(\n        new TransitionDelimiterModel(\n          TransitionDelimiter.COLON,\n          'Colon',\n          'Colon [:]',\n          ':'\n        )\n      );\n      models.push(\n        new TransitionDelimiterModel(\n          TransitionDelimiter.COMMA,\n          'Comma',\n          'Comma [,]',\n          ','\n        )\n      );\n      models.push(\n        new TransitionDelimiterModel(\n          TransitionDelimiter.DASH,\n          'Dash',\n          'Dash [-]',\n          '-'\n        )\n      );\n      models.push(\n        new TransitionDelimiterModel(\n          TransitionDelimiter.EQUAL,\n          'Equal',\n          'Equal [=]',\n          '='\n        )\n      );\n      models.push(\n        new TransitionDelimiterModel(\n          TransitionDelimiter.HASH,\n          'Hash',\n          'Hash [#]',\n          '#'\n        )\n      );\n      models.push(\n        new TransitionDelimiterModel(\n          TransitionDelimiter.PERIOD,\n          'Period',\n          'Period [.]',\n          '.'\n        )\n      );\n      models.push(\n        new TransitionDelimiterModel(\n          TransitionDelimiter.PIPE,\n          'Pipe',\n          'Pipe [|]',\n          '|'\n        )\n      );\n      models.push(\n        new TransitionDelimiterModel(\n          TransitionDelimiter.SEMICOLON,\n          'Semicolon',\n          'Semicolon [;]',\n          ';'\n        )\n      );\n      models.push(\n        new TransitionDelimiterModel(\n          TransitionDelimiter.SLASH,\n          'Slash',\n          'Slash [/]',\n          '/'\n        )\n      );\n      models.push(\n        new TransitionDelimiterModel(\n          TransitionDelimiter.SPACE,\n          'Space',\n          'Space [ ]',\n          ' '\n        )\n      );\n      models.push(\n        new TransitionDelimiterModel(\n          TransitionDelimiter.UNDERSCORE,\n          'Underscore',\n          'Underscore [_]',\n          '_'\n        )\n      );\n      models.push(\n        new TransitionDelimiterModel(\n          TransitionDelimiter.USER_DEFINED,\n          'User defined',\n          'User defined',\n          '\\0'\n        )\n      );\n      TransitionModel.delimiterModels = models;\n    }\n  }\n\n  static delimiterToModel(delimiter: string): TransitionDelimiterModel {\n    return TransitionModel.delimiterModels.filter(\n      (model) => model.actualDelimiter === delimiter\n    )[0];\n  }\n\n  /**\n   * Translate a mapping mode number into a string.\n   * @param mode\n   */\n  static getMappingModeName(mode: TransitionMode): string {\n    let actionName: string;\n\n    switch (mode) {\n      case TransitionMode.ONE_TO_ONE: {\n        actionName = 'One to One';\n        break;\n      }\n      case TransitionMode.MANY_TO_ONE: {\n        actionName = 'Many to One';\n        break;\n      }\n      case TransitionMode.ONE_TO_MANY: {\n        actionName = 'One to Many';\n        break;\n      }\n      case TransitionMode.ENUM: {\n        actionName = 'ENUM';\n        break;\n      }\n      case TransitionMode.FOR_EACH: {\n        actionName = 'For Each';\n        break;\n      }\n      case TransitionMode.EXPRESSION: {\n        actionName = 'Expression';\n        break;\n      }\n      default: {\n        actionName = '';\n        break;\n      }\n    }\n    return actionName;\n  }\n\n  getPrettyName() {\n    let transitionFieldActionName = '';\n    if (this.transitionFieldAction) {\n      transitionFieldActionName = ' (' + this.transitionFieldAction.name + ')';\n    }\n    if (\n      this.mode === TransitionMode.ONE_TO_MANY ||\n      this.mode === TransitionMode.MANY_TO_ONE\n    ) {\n      return (\n        TransitionModel.getMappingModeName(this.mode) +\n        transitionFieldActionName\n      );\n    } else if (this.mode === TransitionMode.ENUM) {\n      return 'Enum (table: ' + this.lookupTableName + ')';\n    } else if (this.mode === TransitionMode.EXPRESSION) {\n      return 'Expression (' + this.expression?.toText() + ')';\n    }\n    return TransitionModel.getMappingModeName(this.mode);\n  }\n\n  isOneToManyMode(): boolean {\n    return this.mode === TransitionMode.ONE_TO_MANY;\n  }\n\n  isOneToOneMode(): boolean {\n    return this.mode === TransitionMode.ONE_TO_ONE;\n  }\n\n  isManyToOneMode(): boolean {\n    return this.mode === TransitionMode.MANY_TO_ONE;\n  }\n\n  isForEachMode(): boolean {\n    return this.mode === TransitionMode.FOR_EACH;\n  }\n\n  isEnumerationMode(): boolean {\n    return this.mode === TransitionMode.ENUM;\n  }\n\n  isExpressionMode(): boolean {\n    return this.mode === TransitionMode.EXPRESSION;\n  }\n}\n","/*\n    Copyright (C) 2017 Red Hat, Inc.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n            http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n*/\n\nimport { FieldType } from '../contracts';\nimport { Multiplicity } from '../contracts/field-action';\n\nexport class FieldActionArgument {\n  name: string;\n  type = FieldType.STRING;\n  values: string[] | null = null;\n  serviceObject: any = {};\n}\n\nexport class FieldActionArgumentValue {\n  label: string;\n  name: string;\n  value: string;\n}\n\nexport class FieldActionDefinition {\n  name: string;\n  isCustom: boolean;\n  arguments: FieldActionArgument[] = [];\n  method: string;\n  sourceType = FieldType.NONE;\n  targetType = FieldType.NONE;\n  multiplicity = Multiplicity.ONE_TO_ONE;\n  serviceObject: any = {};\n\n  populateFieldAction(action: FieldAction): void {\n    action.name = this.name;\n    action.definition = this;\n\n    // Use the parsed values if present, otherwise set to '0'.\n    if (action.argumentValues == null || action.argumentValues.length === 0) {\n      action.argumentValues = [];\n      for (const arg of this.arguments) {\n        // Default the input field to 0 for numerics\n        if (\n          [\n            'LONG',\n            'INTEGER',\n            'FLOAT',\n            'DOUBLE',\n            'SHORT',\n            'BYTE',\n            'DECIMAL',\n            'NUMBER',\n          ].indexOf(arg.type.toUpperCase()) !== -1\n        ) {\n          action.setArgumentValue(arg.name!, '0'); // TODO: check this non null operator\n        } else {\n          action.setArgumentValue(arg.name!, ''); // TODO: check this non null operator\n        }\n      }\n    }\n  }\n\n  getArgumentForName(name: string): FieldActionArgument {\n    // TODO: check this non null operator\n    return this.arguments.find((argument) => argument.name === name)!;\n  }\n}\n\nexport class FieldAction {\n  name: string;\n  definition: FieldActionDefinition | null;\n  argumentValues: FieldActionArgumentValue[] = [];\n\n  static create(definition: FieldActionDefinition): FieldAction {\n    const instance = new FieldAction();\n    instance.definition = definition;\n    instance.name = definition?.name;\n    return instance;\n  }\n\n  getArgumentValue(argumentName: string): FieldActionArgumentValue {\n    for (const argValue of this.argumentValues) {\n      if (argValue.name === argumentName) {\n        return argValue;\n      }\n    }\n    const newArgValue: FieldActionArgumentValue =\n      new FieldActionArgumentValue();\n    newArgValue.name = argumentName;\n    newArgValue.value = '0';\n    this.argumentValues.push(newArgValue);\n    return newArgValue;\n  }\n\n  setArgumentValue(argumentName: string, value: string): void {\n    this.getArgumentValue(argumentName).value = value;\n  }\n}\n","/*\n    Copyright (C) 2017 Red Hat, Inc.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n            http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n*/\nimport { ErrorInfo, ErrorLevel, ErrorScope, ErrorType } from '../error.model';\nimport { Input, Options } from 'ky';\n\nimport { ConfigModel } from '../config.model';\nimport { DocumentDefinition } from '../document-definition.model';\nimport { Field } from '../field.model';\nimport { IField } from '../../contracts/common';\n\n/**\n * Encapsulates Document inspection context.\n */\nexport abstract class DocumentInspectionModel {\n  request: DocumentInspectionRequestModel;\n\n  constructor(public cfg: ConfigModel, public doc: DocumentDefinition) {}\n\n  /**\n   * Validates if the online inspection is available for this type of Document.\n   */\n  abstract isOnlineInspectionCapable(): boolean;\n\n  /**\n   * Parse inspection response returned from backend.\n   *\n   * @param responseJson\n   */\n  abstract parseResponse(responseJson: any): void;\n\n  protected parseFieldFromDocument(\n    field: IField,\n    parentField: Field | null\n  ): Field | null {\n    if (field != null && field.status === 'NOT_FOUND') {\n      this.cfg.errorService.addError(\n        new ErrorInfo({\n          message: `Ignoring unknown field: ${field.name} (${field.path}), document: ${this.doc.name}`,\n          level: ErrorLevel.WARN,\n          scope: ErrorScope.APPLICATION,\n          type: ErrorType.USER,\n        })\n      );\n      return null;\n    } else if (field != null && field.status === 'EXCLUDED') {\n      return null;\n    }\n\n    const parsedField: Field = new Field();\n    parsedField.name = field.name!;\n    parsedField.type = field.fieldType!;\n    parsedField.path = field.path!;\n    parsedField.isPrimitive = field.fieldType !== 'COMPLEX';\n    parsedField.documentField = field;\n\n    if ('LIST' === field.collectionType || 'ARRAY' === field.collectionType) {\n      parsedField.isCollection = true;\n      if ('ARRAY' === field.collectionType) {\n        parsedField.isArray = true;\n      }\n    }\n\n    if (parentField != null) {\n      parsedField.parentField = parentField;\n      parentField.children.push(parsedField);\n    } else {\n      this.doc.fields.push(parsedField);\n    }\n\n    return parsedField;\n  }\n}\n\nexport abstract class DocumentInspectionRequestModel {\n  constructor(protected cfg: ConfigModel, protected doc: DocumentDefinition) {}\n  url: Input;\n  options: DocumentInspectionRequestOptions;\n}\n\nexport abstract class DocumentInspectionRequestOptions implements Options {\n  constructor(protected cfg: ConfigModel, protected doc: DocumentDefinition) {}\n  json: any;\n  headers: { [key: string]: string } = { 'Content-Type': 'application/json' };\n  searchParams: { [key: string]: string } = {};\n}\n","/*\n    Copyright (C) 2017 Red Hat, Inc.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n            http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n*/\nimport {\n  DocumentInspectionModel,\n  DocumentInspectionRequestModel,\n  DocumentInspectionRequestOptions,\n} from './document-inspection.model';\nimport { ErrorInfo, ErrorLevel, ErrorScope, ErrorType } from '../error.model';\nimport { FieldType, IDocument } from '../../contracts/common';\nimport {\n  ICsvComplexType,\n  ICsvDocumentContainer,\n  ICsvField,\n  ICsvInspectionResponse,\n  ICsvInspectionResponseContainer,\n} from '../../contracts/documents/csv';\n\nimport { Field } from '../field.model';\n\nexport class CsvInspectionModel extends DocumentInspectionModel {\n  request = new CsvInspectionRequestModel(this.cfg, this.doc);\n\n  isOnlineInspectionCapable(): boolean {\n    if (this.cfg.initCfg.baseCSVInspectionServiceUrl == null) {\n      this.cfg.errorService.addError(\n        new ErrorInfo({\n          message: `CSV inspection service is not configured. Document will not be loaded: ${this.doc.name}`,\n          level: ErrorLevel.WARN,\n          scope: ErrorScope.APPLICATION,\n          type: ErrorType.INTERNAL,\n          object: this.doc,\n        })\n      );\n      return false;\n    }\n    return true;\n  }\n\n  parseResponse(responseJson: any): void {\n    if (typeof responseJson.CsvInspectionResponse !== 'undefined') {\n      this.extractCSVDocumentDefinitionFromInspectionResponse(\n        (responseJson as ICsvInspectionResponseContainer).CsvInspectionResponse\n      );\n    } else if (typeof responseJson.CsvDocument !== 'undefined') {\n      this.extractCSVDocumentDefinition(\n        (responseJson as ICsvDocumentContainer).CsvDocument\n      );\n    } else {\n      throw new Error(`Unknown CSV inspection result format: ${responseJson}`);\n    }\n  }\n\n  private extractCSVDocumentDefinitionFromInspectionResponse(\n    body: ICsvInspectionResponse\n  ): void {\n    if (body.errorMessage) {\n      this.doc.errorOccurred = true;\n      throw new Error(\n        `Could not load JSON document, error: ${body.errorMessage}`\n      );\n    }\n\n    this.extractCSVDocumentDefinition(body.csvDocument);\n  }\n\n  private extractCSVDocumentDefinition(csvDocument: IDocument): void {\n    if (!this.doc.description) {\n      this.doc.description = this.doc.id;\n    }\n    if (!this.doc.name) {\n      this.doc.name = this.doc.id;\n    }\n    if (this.doc.inspectionParameters) {\n      const params = new URLSearchParams(this.doc.inspectionParameters);\n      this.doc.uri = this.doc.uri + '?' + params;\n    }\n\n    for (const field of csvDocument.fields.field) {\n      this.parseCSVFieldFromDocument(field as ICsvField, null);\n    }\n  }\n\n  private parseCSVFieldFromDocument(\n    field: ICsvField,\n    parentField: Field | null\n  ): void {\n    const parsedField = this.parseFieldFromDocument(field, parentField);\n    if (parsedField == null) {\n      return;\n    }\n    parsedField.column = field.column;\n    if (field.fieldType !== FieldType.COMPLEX) {\n      return;\n    }\n    const csvComplexType = field as ICsvComplexType;\n    if (csvComplexType.csvFields?.csvField?.length) {\n      for (const childField of csvComplexType.csvFields.csvField) {\n        this.parseCSVFieldFromDocument(childField, parsedField);\n      }\n    }\n  }\n}\n\nexport class CsvInspectionRequestModel extends DocumentInspectionRequestModel {\n  url = this.cfg.initCfg.baseCSVInspectionServiceUrl + 'inspect';\n  options = new CsvInspectionRequestOptions(this.cfg, this.doc);\n}\n\nexport class CsvInspectionRequestOptions extends DocumentInspectionRequestOptions {\n  body = this.doc.inspectionSource;\n  searchParams: { [key: string]: string } = this.doc.inspectionParameters;\n}\n","/*\n    Copyright (C) 2017 Red Hat, Inc.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n            http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n*/\nimport { CollectionType, FieldType } from '../../contracts/common';\nimport {\n  DocumentInspectionModel,\n  DocumentInspectionRequestModel,\n  DocumentInspectionRequestOptions,\n} from './document-inspection.model';\nimport { EnumValue, Field } from '../field.model';\nimport { ErrorInfo, ErrorLevel, ErrorScope, ErrorType } from '../error.model';\nimport {\n  IClassInspectionRequestContainer,\n  IClassInspectionResponseContainer,\n  IJavaClass,\n  IJavaClassContainer,\n  IJavaField,\n  JAVA_INSPECTION_REQUEST_JSON_TYPE,\n} from '../../contracts/documents/java';\n\nimport { ConfigModel } from '../config.model';\nimport { DocumentDefinition } from '../document-definition.model';\n\n/**\n * Encapsulates Java class inspection context.\n */\nexport class JavaInspectionModel extends DocumentInspectionModel {\n  request = new JavaInspectionRequestModel(this.cfg, this.doc);\n\n  isOnlineInspectionCapable(): boolean {\n    if (this.cfg.initCfg.baseJavaInspectionServiceUrl == null) {\n      this.cfg.errorService.addError(\n        new ErrorInfo({\n          message: `Java inspection service is not configured. Document will not be loaded: ${this.doc.name}`,\n          level: ErrorLevel.WARN,\n          scope: ErrorScope.APPLICATION,\n          type: ErrorType.INTERNAL,\n          object: this.doc,\n        })\n      );\n      return false;\n    }\n    return true;\n  }\n\n  parseResponse(responseJson: any): void {\n    let javaClass: IJavaClass;\n    if (responseJson.ClassInspectionResponse) {\n      if (responseJson.errorMessage) {\n        this.doc.errorOccurred = true;\n        throw new Error(\n          `Could not load JSON document, error: ${responseJson.errorMessage}`\n        );\n      }\n      javaClass = (responseJson as IClassInspectionResponseContainer)\n        .ClassInspectionResponse.javaClass;\n    } else {\n      javaClass = (responseJson as IJavaClassContainer).JavaClass;\n    }\n    const docIdentifier: string = this.doc.id;\n    if (!javaClass || javaClass.status === 'NOT_FOUND') {\n      this.doc.errorOccurred = true;\n      throw new Error(\n        `Could not load JAVA document. Document is not found: ${docIdentifier}`\n      );\n    }\n\n    if (!this.doc.description) {\n      this.doc.description = javaClass.className;\n    }\n    if (!this.doc.name) {\n      this.doc.name = javaClass.className!;\n      // Make doc name the class name rather than fully qualified name\n      if (this.doc.name && this.doc.name.indexOf('.') !== -1) {\n        this.doc.name = this.doc.name.substr(\n          this.doc.name.lastIndexOf('.') + 1\n        );\n      }\n    }\n    if (javaClass.uri && (!this.doc.uri || this.doc.uri.length === 0)) {\n      this.doc.uri = javaClass.uri;\n    }\n\n    let rootField = null;\n    if (\n      javaClass.collectionType &&\n      javaClass.collectionType !== CollectionType.NONE.valueOf()\n    ) {\n      this.parseJavaFieldFromDocument(javaClass, null);\n      rootField = this.doc.fields[0];\n    }\n    for (const field of javaClass.javaFields.javaField) {\n      this.parseJavaFieldFromDocument(field, rootField);\n    }\n  }\n\n  private parseJavaFieldFromDocument(\n    field: IJavaField,\n    parentField: Field | null\n  ): void {\n    const parsedField = this.parseFieldFromDocument(field, parentField);\n    if (parsedField == null) {\n      return;\n    }\n\n    if (field.className) {\n      parsedField.classIdentifier = field.className;\n    }\n\n    if (field.fieldType !== FieldType.COMPLEX) {\n      return;\n    }\n\n    const javaClass = field as IJavaClass;\n    parsedField.enumeration = javaClass.enumeration;\n    if (javaClass.enumeration && javaClass.javaEnumFields?.javaEnumField) {\n      for (const enumValue of javaClass.javaEnumFields.javaEnumField) {\n        const parsedEnumValue: EnumValue = new EnumValue();\n        parsedEnumValue.name = enumValue.name;\n        parsedEnumValue.ordinal = enumValue.ordinal;\n        parsedField.enumValues.push(parsedEnumValue);\n      }\n    }\n\n    if (javaClass.javaFields?.javaField?.length) {\n      for (const childField of javaClass.javaFields.javaField) {\n        this.parseJavaFieldFromDocument(childField, parsedField);\n      }\n    }\n  }\n}\n\nexport class JavaInspectionRequestModel extends DocumentInspectionRequestModel {\n  url = this.cfg.initCfg.baseJavaInspectionServiceUrl + 'class';\n  options = new JavaInspectionRequestOptions(this.cfg, this.doc);\n}\n\nexport class JavaInspectionRequestOptions extends DocumentInspectionRequestOptions {\n  constructor(protected cfg: ConfigModel, protected doc: DocumentDefinition) {\n    super(cfg, doc);\n    const request: IClassInspectionRequestContainer = {\n      ClassInspectionRequest: {\n        jsonType: JAVA_INSPECTION_REQUEST_JSON_TYPE,\n        className: this.doc.inspectionSource,\n        disablePrivateOnlyFields: this.cfg.initCfg.disablePrivateOnlyFields,\n        disableProtectedOnlyFields: this.cfg.initCfg.disableProtectedOnlyFields,\n        disablePublicOnlyFields: this.cfg.initCfg.disablePublicOnlyFields,\n        disablePublicGetterSetterFields:\n          this.cfg.initCfg.disablePublicGetterSetterFields,\n      },\n    };\n    this.json = request;\n    if (\n      this.doc.initModel.collectionType &&\n      (this.doc.initModel.collectionType as CollectionType) !==\n        CollectionType.NONE\n    ) {\n      request.ClassInspectionRequest.collectionType =\n        this.doc.initModel.collectionType;\n      if (this.doc.initModel.collectionClassName) {\n        request.ClassInspectionRequest.collectionClassName =\n          this.doc.initModel.collectionClassName;\n      }\n    }\n    if (\n      this.cfg.initCfg.fieldNameExclusions &&\n      this.cfg.initCfg.fieldNameExclusions.length\n    ) {\n      request.ClassInspectionRequest.fieldNameExclusions = {\n        string: this.cfg.initCfg.fieldNameExclusions,\n      };\n    }\n    if (\n      this.cfg.initCfg.classNameExclusions &&\n      this.cfg.initCfg.classNameExclusions.length\n    ) {\n      request.ClassInspectionRequest.classNameExclusions = {\n        string: this.cfg.initCfg.classNameExclusions,\n      };\n    }\n  }\n}\n","/*\n    Copyright (C) 2017 Red Hat, Inc.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n            http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n*/\nimport {\n  DocumentInspectionModel,\n  DocumentInspectionRequestModel,\n  DocumentInspectionRequestOptions,\n} from './document-inspection.model';\nimport { EnumValue, Field } from '../field.model';\nimport { ErrorInfo, ErrorLevel, ErrorScope, ErrorType } from '../error.model';\nimport {\n  IJsonComplexType,\n  IJsonDocument,\n  IJsonDocumentContainer,\n  IJsonField,\n  IJsonInspectionResponse,\n  IJsonInspectionResponseContainer,\n  JSON_INSPECTION_REQUEST_JSON_TYPE,\n} from '../../contracts/documents/json';\nimport { FieldType } from '../../contracts/common';\n\n/**\n * Encapsulates JSON inspection context.\n */\nexport class JsonInspectionModel extends DocumentInspectionModel {\n  request = new JsonInspectionRequestModel(this.cfg, this.doc);\n\n  isOnlineInspectionCapable(): boolean {\n    if (this.cfg.initCfg.baseJSONInspectionServiceUrl == null) {\n      this.cfg.errorService.addError(\n        new ErrorInfo({\n          message: `JSON inspection service is not configured. Document will not be loaded: ${this.doc.name}`,\n          level: ErrorLevel.WARN,\n          scope: ErrorScope.APPLICATION,\n          type: ErrorType.INTERNAL,\n          object: this.doc,\n        })\n      );\n      return false;\n    }\n    return true;\n  }\n\n  parseResponse(responseJson: any): void {\n    if (typeof responseJson.JsonInspectionResponse !== 'undefined') {\n      this.extractJSONDocumentDefinitionFromInspectionResponse(\n        (responseJson as IJsonInspectionResponseContainer)\n          .JsonInspectionResponse\n      );\n    } else if (typeof responseJson.JsonDocument !== 'undefined') {\n      this.extractJSONDocumentDefinition(\n        (responseJson as IJsonDocumentContainer).JsonDocument\n      );\n    } else {\n      throw new Error(`Unknown JSON inspection result format: ${responseJson}`);\n    }\n  }\n\n  private extractJSONDocumentDefinitionFromInspectionResponse(\n    body: IJsonInspectionResponse\n  ): void {\n    if (body.errorMessage) {\n      this.doc.errorOccurred = true;\n      throw new Error(\n        `Could not load JSON document, error: ${body.errorMessage}`\n      );\n    }\n\n    this.extractJSONDocumentDefinition(body.jsonDocument);\n  }\n\n  private extractJSONDocumentDefinition(jsonDocument: IJsonDocument): void {\n    if (!this.doc.description) {\n      this.doc.description = this.doc.id;\n    }\n    if (!this.doc.name) {\n      this.doc.name = this.doc.id;\n    }\n\n    for (const field of jsonDocument.fields.field) {\n      this.parseJSONFieldFromDocument(field as IJsonField, null);\n    }\n  }\n\n  private parseJSONFieldFromDocument(\n    field: IJsonField,\n    parentField: Field | null\n  ): void {\n    const parsedField = this.parseFieldFromDocument(field, parentField);\n    if (parsedField == null) {\n      return;\n    }\n    if (field.fieldType !== FieldType.COMPLEX) {\n      return;\n    }\n    const complex = field as IJsonComplexType;\n    parsedField.enumeration = complex.enumeration;\n    /** FIXME enumIndexValue doesn't exist on JsonField/JsonComplexType\n    parsedField.enumIndexValue = complex.enumIndexValue\n      ? complex.enumIndexValue\n      : 0;\n    */\n    if (parsedField.enumeration && complex.jsonEnumFields?.jsonEnumField) {\n      for (const enumValue of complex.jsonEnumFields.jsonEnumField) {\n        const parsedEnumValue: EnumValue = new EnumValue();\n        parsedEnumValue.name = enumValue.name!;\n        parsedEnumValue.ordinal = enumValue.ordinal;\n        parsedField.enumValues.push(parsedEnumValue);\n      }\n    }\n    if (complex.jsonFields?.jsonField.length) {\n      for (const childField of complex.jsonFields.jsonField) {\n        this.parseJSONFieldFromDocument(childField, parsedField);\n      }\n    }\n  }\n}\n\nexport class JsonInspectionRequestModel extends DocumentInspectionRequestModel {\n  url = this.cfg.initCfg.baseJSONInspectionServiceUrl + 'inspect';\n  options = new JsonInspectionRequestOptions(this.cfg, this.doc);\n}\n\nexport class JsonInspectionRequestOptions extends DocumentInspectionRequestOptions {\n  json = {\n    JsonInspectionRequest: {\n      jsonType: JSON_INSPECTION_REQUEST_JSON_TYPE,\n      type: this.doc.inspectionType,\n      jsonData: this.doc.inspectionSource,\n    },\n  };\n}\n","/*\n    Copyright (C) 2017 Red Hat, Inc.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n            http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n*/\n\nimport { IDocument, IField, IStringList, InspectionType } from '../common';\n\n/**\n * The JSON inspection data model contracts between frontend and backend.\n */\nexport const JSON_MODEL_PACKAGE_PREFIX = 'io.atlasmap.json.v2';\nexport const JSON_DATA_SOURCE_JSON_TYPE =\n  JSON_MODEL_PACKAGE_PREFIX + '.JsonDataSource';\nexport const JSON_ENUM_FIELD_JSON_TYPE =\n  JSON_MODEL_PACKAGE_PREFIX + '.JsonEnumField';\nexport const JSON_INSPECTION_REQUEST_JSON_TYPE =\n  JSON_MODEL_PACKAGE_PREFIX + '.JsonInspectionRequest';\n\n/**\n * The root object that carries {@link IJsonInspectionRequest}\n * when it's sent to backend.\n */\nexport interface IJsonInspectionRequestContainer {\n  JsonInspectionRequest: IJsonInspectionRequest;\n}\n\n/**\n * The serialized JSON inspection request.\n */\nexport interface IJsonInspectionRequest {\n  fieldNameExclusions?: IStringList;\n  typeNameExclusions?: IStringList;\n  namespaceExclusions?: IStringList;\n  jsonData?: string;\n  uri?: string;\n  type: InspectionType;\n}\n\n/**\n * The root object that carries {@link IJsonInspectionResponse}\n * when it's received from backend.\n */\nexport interface IJsonInspectionResponseContainer {\n  JsonInspectionResponse: IJsonInspectionResponse;\n}\n\n/**\n * The serialized JSON inspection response.\n */\nexport interface IJsonInspectionResponse {\n  jsonDocument: IJsonDocument;\n  errorMessage?: string;\n  executionTime?: number;\n}\n\n/**\n * The root object that carries {@link IJsonDocument}\n * when it's inspected with maven plugin.\n */\nexport interface IJsonDocumentContainer {\n  JsonDocument: IJsonDocument;\n}\n\n/**\n * The serialized JSON document inspection result.\n */\nexport interface IJsonDocument extends IDocument {}\n\n/**\n * The serialized JSON primitive field in inspection result.\n */\nexport interface IJsonField extends IField {\n  primitive: boolean;\n  typeName: string;\n  userCreated?: boolean;\n}\n\n/**\n * The serialized JSON complex field in inspection result.\n */\nexport interface IJsonComplexType extends IJsonField {\n  jsonFields?: IJsonFields;\n  jsonEnumFields?: IJsonEnumFields;\n  enumeration: boolean;\n  uri?: string;\n}\n\n/**\n * The container of JSON field.\n */\nexport interface IJsonFields {\n  jsonField: IJsonField[];\n}\n\n/**\n * The container of JSON enum field.\n */\nexport interface IJsonEnumFields {\n  jsonEnumField: IJsonEnumField[];\n}\n\n/**\n * The serialized JSON enum field.\n */\nexport interface IJsonEnumField extends IField {\n  ordinal: number;\n  typeName: string;\n  userCreated?: boolean;\n}\n","/*\n    Copyright (C) 2017 Red Hat, Inc.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n            http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n*/\nimport {\n  DocumentInspectionModel,\n  DocumentInspectionRequestModel,\n  DocumentInspectionRequestOptions,\n} from './document-inspection.model';\nimport { EnumValue, Field } from '../field.model';\nimport { ErrorInfo, ErrorLevel, ErrorScope, ErrorType } from '../error.model';\nimport { FieldType, IField } from '../../contracts/common';\nimport {\n  IXmlComplexType,\n  IXmlDocument,\n  IXmlDocumentContainer,\n  IXmlField,\n  IXmlInspectionResponse,\n  IXmlInspectionResponseContainer,\n  XML_INSPECTION_REQUEST_JSON_TYPE,\n} from '../../contracts/documents/xml';\nimport { NamespaceModel } from '../document-definition.model';\n\nexport class XmlInspectionModel extends DocumentInspectionModel {\n  request = new XmlInspectionRequestModel(this.cfg, this.doc);\n\n  isOnlineInspectionCapable(): boolean {\n    if (this.cfg.initCfg.baseXMLInspectionServiceUrl == null) {\n      this.cfg.errorService.addError(\n        new ErrorInfo({\n          message: `XML inspection service is not configured. Document will not be loaded: ${this.doc.name}`,\n          level: ErrorLevel.WARN,\n          scope: ErrorScope.APPLICATION,\n          type: ErrorType.INTERNAL,\n          object: this.doc,\n        })\n      );\n      return false;\n    }\n    return true;\n  }\n\n  parseResponse(responseJson: any): void {\n    if (typeof responseJson.XmlInspectionResponse !== 'undefined') {\n      this.extractXMLDocumentDefinitionFromInspectionResponse(\n        (responseJson as IXmlInspectionResponseContainer).XmlInspectionResponse\n      );\n    } else if (typeof responseJson.XmlDocument !== 'undefined') {\n      this.extractXMLDocumentDefinition(\n        (responseJson as IXmlDocumentContainer).XmlDocument\n      );\n    } else {\n      throw new Error(`Unknown XML inspection result format: ${responseJson}`);\n    }\n  }\n\n  private extractXMLDocumentDefinitionFromInspectionResponse(\n    body: IXmlInspectionResponse\n  ): void {\n    if (body.errorMessage) {\n      this.doc.errorOccurred = true;\n      throw new Error(\n        `Could not load XML document, error: ${body.errorMessage}`\n      );\n    }\n\n    this.extractXMLDocumentDefinition(body.xmlDocument);\n  }\n\n  private extractXMLDocumentDefinition(xmlDocument: IXmlDocument): void {\n    if (!this.doc.description) {\n      this.doc.description = this.doc.id;\n    }\n    if (!this.doc.name) {\n      this.doc.name = this.doc.id;\n    }\n\n    if (xmlDocument?.xmlNamespaces?.xmlNamespace?.length) {\n      for (const serviceNS of xmlDocument.xmlNamespaces.xmlNamespace) {\n        const ns: NamespaceModel = new NamespaceModel();\n        ns.alias = serviceNS.alias;\n        ns.uri = serviceNS.uri;\n        ns.locationUri = serviceNS.locationUri;\n        ns.isTarget = serviceNS.targetNamespace;\n        this.doc.namespaces.push(ns);\n      }\n    }\n\n    for (const field of xmlDocument.fields.field) {\n      if (!this.doc.selectedRoot || this.isSelectedRootElement(field)) {\n        this.parseXMLFieldFromDocument(field, null);\n        break;\n      }\n    }\n  }\n\n  private isSelectedRootElement(field: IField): boolean {\n    if (!this.doc.selectedRoot && !field?.name) {\n      return false;\n    }\n    return (\n      this.doc.selectedRoot ===\n      (field.name!.indexOf(':') !== -1 ? field.name!.split(':')[1] : field.name)\n    );\n  }\n\n  private parseXMLFieldFromDocument(\n    field: IXmlField,\n    parentField: Field | null\n  ): void {\n    const parsedField = this.parseFieldFromDocument(field, parentField);\n    if (parsedField == null) {\n      return;\n    }\n\n    if (field.name!.indexOf(':') !== -1) {\n      parsedField.namespaceAlias = field.name!.split(':')[0];\n      parsedField.name = field.name!.split(':')[1];\n    }\n\n    parsedField.isAttribute = parsedField.path.indexOf('@') !== -1;\n    if (field.fieldType !== FieldType.COMPLEX) {\n      return;\n    }\n    const complex = field as IXmlComplexType;\n\n    parsedField.enumeration = complex.enumeration;\n\n    if (parsedField.enumeration && complex.xmlEnumFields?.xmlEnumField) {\n      for (const enumValue of complex.xmlEnumFields.xmlEnumField) {\n        const parsedEnumValue: EnumValue = new EnumValue();\n        parsedEnumValue.name = enumValue.name!;\n        parsedEnumValue.ordinal = enumValue.ordinal;\n        parsedField.enumValues.push(parsedEnumValue);\n      }\n    }\n    if (complex.xmlFields?.xmlField.length) {\n      for (const childField of complex.xmlFields.xmlField) {\n        this.parseXMLFieldFromDocument(childField, parsedField);\n      }\n    }\n  }\n}\n\nexport class XmlInspectionRequestModel extends DocumentInspectionRequestModel {\n  url = this.cfg.initCfg.baseXMLInspectionServiceUrl + 'inspect';\n  options = new XmlInspectionRequestOptions(this.cfg, this.doc);\n}\n\nexport class XmlInspectionRequestOptions extends DocumentInspectionRequestOptions {\n  json = {\n    XmlInspectionRequest: {\n      jsonType: XML_INSPECTION_REQUEST_JSON_TYPE,\n      type: this.doc.inspectionType,\n      xmlData: this.doc.inspectionSource,\n    },\n  };\n}\n","/*\n    Copyright (C) 2017 Red Hat, Inc.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n            http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n*/\n\nimport { IDataSource, IDocument, IField } from '../common';\n\n/**\n * The XML inspection data model contracts between frontend and backend.\n */\n\nexport const XML_MODEL_PACKAGE_PREFIX = 'io.atlasmap.xml.v2';\nexport const XML_DATA_SOURCE_JSON_TYPE =\n  XML_MODEL_PACKAGE_PREFIX + '.XmlDataSource';\nexport const XML_ENUM_FIELD_JSON_TYPE =\n  XML_MODEL_PACKAGE_PREFIX + '.XmlEnumField';\nexport const XML_INSPECTION_REQUEST_JSON_TYPE =\n  XML_MODEL_PACKAGE_PREFIX + '.XmlInspectionRequest';\n\n/**\n * The root object that carries {@link IXmlInspectionResponse}\n * when it's sent to backend.\n */\nexport interface IXmlInspectionResponseContainer {\n  XmlInspectionResponse: IXmlInspectionResponse;\n}\n\n/**\n * The serialized XML inspection response.\n */\nexport interface IXmlInspectionResponse {\n  xmlDocument: IXmlDocument;\n  errorMessage?: string;\n  executionTime?: number;\n}\n\n/**\n * The root object that carries {@link IXmlDocument}\n * when it's inspected with maven plugin.\n */\nexport interface IXmlDocumentContainer {\n  XmlDocument: IXmlDocument;\n}\n\n/**\n * The serialized XML document in inspection result.\n */\nexport interface IXmlDocument extends IDocument {\n  xmlNamespaces?: IXmlNamespaces;\n}\n\n/**\n * The serialized XML DataSource.\n * @see IXmlNamespaces\n */\nexport interface IXmlDataSource extends IDataSource {\n  template?: string;\n  xmlNamespaces?: IXmlNamespaces;\n}\n\n/**\n * The container of XML namespace.\n */\nexport interface IXmlNamespaces {\n  xmlNamespace: IXmlNamespace[];\n}\n\n/**\n * The serialized XML namespace.\n */\nexport interface IXmlNamespace {\n  alias: string;\n  uri: string;\n  locationUri?: string;\n  targetNamespace: boolean;\n}\n\n/**\n * The serialized XML primitive field.\n */\nexport interface IXmlField extends IField {\n  userCreated?: boolean;\n  attribute?: boolean;\n}\n\n/**\n * The serialized XML complex field.\n */\nexport interface IXmlComplexType extends IField {\n  xmlEnumFields?: IXmlEnumFields;\n  xmlFields?: IXmlFields;\n  annotation?: boolean;\n  anonymous?: boolean;\n  enumeration: boolean;\n  uri?: string;\n}\n\n/**\n * The container of XML enum field.\n */\nexport interface IXmlEnumFields {\n  xmlEnumField: IXmlEnumField[];\n}\n\n/**\n * The serialized XML enum field.\n */\nexport interface IXmlEnumField extends IField {\n  ordinal: number;\n  typeName: string;\n  attribute: boolean;\n  userCreated: boolean;\n}\n\n/**\n * The container of XML field.\n */\nexport interface IXmlFields {\n  xmlField: IXmlField[];\n}\n","/*\n    Copyright (C) 2017 Red Hat, Inc.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n            http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n*/\n\nimport { FieldType } from '../contracts';\n\nexport class LookupTableEntry {\n  sourceValue: string;\n  sourceType = FieldType.STRING;\n  targetValue: string;\n  targetType = FieldType.STRING;\n}\n\nexport class LookupTable {\n  name: string;\n  lookupEntry: LookupTableEntry[] = [];\n  sourceIdentifier: string;\n  targetIdentifier: string;\n\n  constructor() {\n    this.name =\n      new Date().getTime() +\n      '-' +\n      Math.floor(Math.random() * 1000000).toString();\n  }\n\n  getInputOutputKey(): string {\n    return this.sourceIdentifier + ':' + this.targetIdentifier;\n  }\n\n  getEntryForSource(\n    sourceValue: string,\n    autocreate: boolean\n  ): LookupTableEntry | null {\n    for (const entry of this.lookupEntry) {\n      if (entry.sourceValue === sourceValue) {\n        return entry;\n      }\n    }\n    if (autocreate) {\n      const entry: LookupTableEntry = new LookupTableEntry();\n      entry.sourceValue = sourceValue;\n      this.lookupEntry.push(entry);\n      return entry;\n    }\n    return null;\n  }\n\n  toString() {\n    let result: string =\n      'Lookup Table, name: ' +\n      this.name +\n      ', entries: ' +\n      this.lookupEntry.length;\n    result += '\\nsourceIdentifier: ' + this.sourceIdentifier;\n    result += '\\n\\targetIdentifier: ' + this.targetIdentifier;\n    let counter = 0;\n    for (const entry of this.lookupEntry) {\n      result +=\n        '\\n\\tEntry #' +\n        counter +\n        ': ' +\n        entry.sourceValue +\n        ' => ' +\n        entry.targetValue;\n      counter += 1;\n    }\n    return result;\n  }\n}\n","/*\n    Copyright (C) 2017 Red Hat, Inc.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n            http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n*/\n\nimport { CommonUtil } from '../utils/common-util';\nimport { DocumentDefinition } from './document-definition.model';\nimport { Field } from './field.model';\nimport { LookupTable } from './lookup-table.model';\nimport { MappingModel } from './mapping.model';\nimport { TransitionMode } from './transition.model';\n\nexport class MappingDefinition {\n  name: string | null = null;\n  mappings: MappingModel[] = [];\n  activeMapping: MappingModel | null = null;\n  parsedDocs: DocumentDefinition[] = [];\n  templateText: string | null = null;\n\n  private tables: LookupTable[] = [];\n  private tablesBySourceTargetKey: { [key: string]: LookupTable } = {};\n  private tablesByName: { [key: string]: LookupTable } = {};\n\n  constructor() {\n    // Mapping definition ID must be 0 until https://github.com/atlasmap/atlasmap/issues/1577\n    // this.name = 'UI.' + Math.floor((Math.random() * 1000000) + 1).toString();\n    this.name = 'UI.0';\n  }\n\n  templateExists(): boolean {\n    return this.templateText != null && this.templateText !== '';\n  }\n\n  addTable(table: LookupTable): void {\n    this.tablesBySourceTargetKey[table.getInputOutputKey()] = table;\n    this.tablesByName[table.name] = table;\n    this.tables.push(table);\n  }\n\n  getTableByName(name: string): LookupTable {\n    return this.tablesByName[name];\n  }\n\n  getTableBySourceTarget(\n    sourceIdentifier: string,\n    targetIdentifier: string\n  ): LookupTable {\n    const key: string = sourceIdentifier + ':' + targetIdentifier;\n    return this.tablesBySourceTargetKey[key];\n  }\n\n  getTables(): LookupTable[] {\n    const tables: LookupTable[] = [];\n    for (const key in this.tablesByName) {\n      if (!this.tablesByName.hasOwnProperty(key)) {\n        continue;\n      }\n      const table: LookupTable = this.tablesByName[key];\n      tables.push(table);\n    }\n    return tables;\n  }\n\n  removeTableByName(name: string) {\n    if (name) {\n      const table = this.tablesByName[name];\n      const iokey = table.getInputOutputKey();\n      if (this.tablesByName[name]) {\n        delete this.tables[this.tables.indexOf(table)];\n        delete this.tablesByName[name];\n        delete this.tablesBySourceTargetKey[iokey];\n      }\n    }\n  }\n\n  getAllMappings(includeActiveMapping: boolean): MappingModel[] {\n    const mappings: MappingModel[] = [...this.mappings];\n    if (includeActiveMapping) {\n      if (this.activeMapping == null) {\n        return mappings;\n      }\n      for (const mapping of mappings) {\n        if (mapping === this.activeMapping) {\n          return mappings;\n        }\n      }\n      mappings.push(this.activeMapping);\n    }\n    return mappings;\n  }\n\n  findMappingsForField(field: Field): MappingModel[] {\n    const mappingsForField: MappingModel[] = [];\n    for (const m of this.mappings) {\n      if (m.isFieldMapped(field)) {\n        mappingsForField.push(m);\n      }\n    }\n    return mappingsForField;\n  }\n\n  removeMapping(m: MappingModel): boolean {\n    if (m.transition.mode === TransitionMode.ENUM) {\n      this.removeTableByName(m.transition.lookupTableName!);\n    }\n    return CommonUtil.removeItemFromArray(m, this.mappings);\n  }\n}\n","/*\n    Copyright (C) 2017 Red Hat, Inc.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n            http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n*/\nimport { FieldType, IField } from '../contracts/common';\n\nimport { CommonUtil } from '../utils/common-util';\nimport { ConfigModel } from './config.model';\nimport { Field } from './field.model';\nimport { FieldAction } from './field-action.model';\nimport { PaddingField } from './document-definition.model';\nimport { TransitionModel } from './transition.model';\n\nexport class MappedField {\n  /**\n   * The field properties read from mapping definition. This is a temporary object\n   * when it's deserialized from mapping definition and once {@link field} is populated\n   * this should not be used.\n   * @todo Identify document field at once when it deserializes and remove this temporary\n   * object.\n   */\n  mappingField: IField;\n  /** The field object created from document field */\n  field: Field | null;\n  /** The field actions read from mapping and enriched through {@link FieldActionService} */\n  actions: FieldAction[] = [];\n\n  static sortMappedFieldsByPath(mappedFields: MappedField[]): MappedField[] {\n    if (mappedFields == null || mappedFields.length === 0) {\n      return [];\n    }\n    const fieldsByPath: { [key: string]: MappedField } = {};\n    const fieldPaths: string[] = [];\n    for (const mappedField of mappedFields) {\n      if (mappedField == null || mappedField.field == null) {\n        continue;\n      }\n      const path: string = mappedField.field.path;\n      fieldsByPath[path] = mappedField;\n      fieldPaths.push(path);\n    }\n    fieldPaths.sort();\n    const result: MappedField[] = [];\n    for (const name of fieldPaths) {\n      result.push(fieldsByPath[name]);\n    }\n    return result;\n  }\n\n  isPadField(): boolean {\n    return this.field instanceof PaddingField;\n  }\n\n  isSource(): boolean {\n    return this.field ? this.field.isSource() : false;\n  }\n\n  removeAction(action: FieldAction): void {\n    CommonUtil.removeItemFromArray(action, this.actions);\n  }\n}\n\nexport class MappingModel {\n  cfg: ConfigModel;\n  uuid: string;\n\n  sourceFields: MappedField[] = [];\n  targetFields: MappedField[] = [];\n  referenceFields: MappedField[] = [];\n  transition: TransitionModel = new TransitionModel();\n\n  constructor() {\n    this.uuid = 'mapping.' + Math.floor(Math.random() * 1000000 + 1).toString();\n    this.cfg = ConfigModel.getConfig();\n  }\n\n  getFirstCollectionField(isSource: boolean): Field | null {\n    for (const f of isSource ? this.sourceFields : this.targetFields) {\n      if (f.field && f.field.isInCollection()) {\n        return f.field;\n      }\n    }\n    return null;\n  }\n\n  isLookupMode(): boolean {\n    for (const f of this.sourceFields.concat(this.targetFields)) {\n      if (f.field && f.field.enumeration) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Add the specified field to this field mapping.\n   *\n   * @param field - field to add to the mapping\n   * @param first - if true add the field to the beginning of the array, last otherwise.\n   */\n  addField(field: Field, first: boolean): MappedField {\n    const mappedFields = this.getMappedFields(field.isSource());\n    if (mappedFields.length === 1) {\n      const mappedField: MappedField = mappedFields[0];\n      if (!mappedField.field) {\n        mappedField.field = field;\n        return mappedField;\n      }\n    }\n    const mappedField: MappedField = new MappedField();\n    mappedField.field = field;\n    if (first) {\n      mappedFields.unshift(mappedField);\n    } else {\n      mappedFields.push(mappedField);\n    }\n    return mappedField;\n  }\n\n  /**\n   * Remove the specified field from this field mapping.\n   *\n   * @param field\n   */\n  removeField(field: Field) {\n    const mappedFields = this.getMappedFields(field.isSource());\n    CommonUtil.removeItemFromArray(\n      mappedFields.find((mf) => mf.field === field),\n      mappedFields\n    );\n  }\n\n  /**\n   * Return the number of user-defined (non-padding) fields in this mapping.\n   *\n   * @param field\n   */\n  getUserFieldCount(field: Field): number {\n    const mappedFields = this.getMappedFields(field.isSource());\n    let userFieldCount = 0;\n\n    for (const mappedField of mappedFields) {\n      if (!mappedField.isPadField()) {\n        userFieldCount++;\n      }\n    }\n    return userFieldCount;\n  }\n\n  hasMappedField(isSource: boolean) {\n    return isSource\n      ? this.sourceFields.length > 0\n      : this.targetFields.length > 0;\n  }\n\n  isEmpty() {\n    return this.sourceFields.length === 0 && this.targetFields.length === 0;\n  }\n\n  isFullyMapped(): boolean {\n    return this.sourceFields.length > 0 && this.targetFields.length > 0;\n  }\n\n  addMappedField(mappedField: MappedField, isSource: boolean): void {\n    this.getMappedFields(isSource).push(mappedField);\n  }\n\n  removeMappedField(mappedField: MappedField): void {\n    if (!mappedField || !mappedField.field) {\n      return;\n    }\n    if (mappedField.field.isCollection) {\n      this.removeReferenceField(mappedField);\n    }\n    CommonUtil.removeItemFromArray(\n      mappedField,\n      this.getMappedFields(mappedField.field!.isSource())\n    );\n    this.cfg.mappingService.notifyMappingUpdated();\n  }\n\n  getMappedFieldForField(field: Field): MappedField | null {\n    if (!field || !field.isSource) {\n      return null;\n    }\n\n    for (const mappedField of this.getMappedFields(field.isSource())) {\n      if (mappedField.field === field) {\n        return mappedField;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Return the MappedField associated with the specified field path and panel. The\n   * document ID is optional identifier parameters used to distinguish the fields\n   * with the same path in a different document. The first match will be returned\n   * if not specified.\n   *\n   * @param fieldPath\n   * @param isSource\n   * @param identifier\n   */\n  getMappedFieldByPath(\n    fieldPath: string,\n    isSource: boolean,\n    docId?: string\n  ): MappedField | null {\n    if (!fieldPath) {\n      return null;\n    }\n    const mappedFields = this.getMappedFields(isSource);\n    for (let i = 0; i < mappedFields.length; i++) {\n      if (mappedFields[i].field?.path === fieldPath) {\n        if (!docId) {\n          return mappedFields[i];\n        }\n        if (docId && mappedFields[i].field?.docDef.id === docId) {\n          return mappedFields[i];\n        }\n      }\n    }\n    return null;\n  }\n\n  getMappedFieldForIndex(index: string, isSource: boolean): MappedField | null {\n    if (!index || index.length === 0) {\n      return null;\n    }\n    const mappedFields = this.getMappedFields(isSource);\n    if (+index - 1 > mappedFields.length - 1) {\n      return null;\n    }\n    return mappedFields[+index - 1];\n  }\n\n  getIndexForMappedField(mappedField: MappedField): number | null {\n    if (!mappedField || !mappedField.field) {\n      return null;\n    }\n    return (\n      this.getMappedFields(mappedField.field.isSource()).indexOf(mappedField) +\n      1\n    );\n  }\n\n  getField(docId: string, fieldPath: string): Field | null {\n    let docDef = this.cfg.getDocForIdentifier(docId, true);\n    if (!docDef) {\n      docDef = this.cfg.getDocForIdentifier(docId, false);\n    }\n    let field: Field | null = null;\n    if (docDef) {\n      field = Field.getField(fieldPath, docDef.getAllFields());\n    }\n    return field;\n  }\n\n  /**\n   * Create a reference field in the reference fields array for this mapping.\n   *\n   * @param field\n   */\n  createReferenceField(field: Field): MappedField | null {\n    let mappedField: MappedField | null = null;\n\n    if (!field) {\n      return null;\n    }\n    if (\n      !field.documentField?.status ||\n      field.documentField?.status === 'SUPPORTED' ||\n      field.documentField?.status === 'CACHED'\n    ) {\n      mappedField = new MappedField();\n      mappedField.field = field;\n      this.referenceFields.push(mappedField);\n    }\n    return mappedField;\n  }\n\n  /**\n   * Remove the specified reference field from the reference fields array.\n   *\n   * @param field\n   */\n  removeReferenceField(mappedField: MappedField) {\n    if (!mappedField) {\n      return;\n    }\n    CommonUtil.removeItemFromArray(mappedField, this.referenceFields);\n  }\n\n  /**\n   * Return true if a reference field exists in this mapping with the specified\n   * document ID and field path, false otherwise.\n   *\n   * @param docId\n   * @param fieldPath\n   */\n  referenceFieldExists(docId: string, fieldPath: string): boolean {\n    if (!docId || !fieldPath) {\n      return false;\n    }\n    const referenceFields = this.getReferenceMappedFields();\n    for (let referenceField of referenceFields) {\n      if (\n        referenceField.field &&\n        referenceField.field.docDef.id === docId &&\n        referenceField.field.path === fieldPath\n      ) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * A reference field is a complex field which is referenced in a conditional\n   * expression but does not exist as an explicit part of the mapping.  It is\n   * typically used as a parameter to conditional functions/ constructs. If the\n   * field already exists return it otherwise create it.\n   *\n   * @param docId\n   * @param fieldPath\n   */\n  getReferenceField(docId: string, fieldPath: string): MappedField | null {\n    if (!docId || !fieldPath) {\n      return null;\n    }\n    const referenceFields = this.getReferenceMappedFields();\n    for (let referenceField of referenceFields) {\n      if (\n        referenceField.field &&\n        referenceField.field.docDef.id === docId &&\n        referenceField.field.path === fieldPath\n      ) {\n        return referenceField;\n      }\n    }\n    const field = this.getField(docId, fieldPath);\n    if (field?.type === FieldType.COMPLEX) {\n      this.transition.expression.hasComplexField = true;\n      return this.createReferenceField(field);\n    }\n    return null;\n  }\n\n  /**\n   * Return an array of user mapped fields for the specified panel in this\n   * field pair instance.  No data-mapper generated padding fields will be\n   * included.\n   *\n   * @param isSource - true source panel, false target panel\n   */\n  getUserMappedFields(isSource: boolean): MappedField[] {\n    const workingFields = isSource ? this.sourceFields : this.targetFields;\n    const resultFields: MappedField[] = [new MappedField()];\n\n    for (const mappedField of workingFields) {\n      if (!mappedField.isPadField()) {\n        resultFields.push(mappedField);\n      }\n    }\n    resultFields.shift();\n    return resultFields;\n  }\n\n  getReferenceMappedFields(): MappedField[] {\n    return this.referenceFields;\n  }\n\n  getMappedFields(isSource: boolean): MappedField[] {\n    return isSource ? this.sourceFields : this.targetFields;\n  }\n\n  getLastMappedField(isSource: boolean): MappedField | null {\n    const fields: MappedField[] = this.getMappedFields(isSource);\n    if (fields != null && fields.length > 0) {\n      return fields[fields.length - 1];\n    }\n    return null;\n  }\n\n  getFields(isSource: boolean): Field[] {\n    const fields: Field[] = [];\n    for (const mappedField of this.getMappedFields(isSource)) {\n      if (mappedField.field != null) {\n        fields.push(mappedField.field);\n      }\n    }\n    return fields;\n  }\n\n  getFieldNames(isSource: boolean): string[] {\n    const fields: Field[] = this.getFields(isSource);\n    Field.alphabetizeFields(fields);\n    const names: string[] = [];\n    for (const field of fields) {\n      names.push(field.name);\n    }\n    return names;\n  }\n\n  getFieldPaths(isSource: boolean): string[] {\n    const fields: Field[] = this.getFields(isSource);\n    Field.alphabetizeFields(fields);\n    const paths: string[] = [];\n    for (const field of fields) {\n      paths.push(field.path);\n    }\n    return paths;\n  }\n\n  hasFieldActions(): boolean {\n    for (const mappedField of this.getAllMappedFields()) {\n      if (mappedField.actions.length > 0) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  getAllFields(): Field[] {\n    return this.getFields(true).concat(this.getFields(false));\n  }\n\n  getAllMappedFields(): MappedField[] {\n    return this.getMappedFields(true).concat(this.getMappedFields(false));\n  }\n\n  isFieldMapped(field: Field): boolean {\n    return this.getMappedFieldForField(field) != null;\n  }\n\n  hasTransformation(): boolean {\n    const mappedFields: MappedField[] = this.getAllMappedFields();\n    for (const mappedField of mappedFields) {\n      if (mappedField.actions.length > 0) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Walk all target field mappings and return one of corresponding source field name\n   * if the specified field is already the target of a previous mapping, null otherwise.\n   *\n   * @param field\n   */\n  public getMappedTarget(field: Field): string | null {\n    // TODO: check this non null operator\n    const mappings: MappingModel[] = this.cfg.mappings!.mappings;\n\n    if (field.isSource()) {\n      return null;\n    }\n    for (const m of mappings) {\n      if (m.targetFields.length === 0) {\n        continue;\n      }\n\n      for (const mappedOutputField of m.targetFields) {\n        // TODO: check this non null operator\n        if (\n          mappedOutputField.field?.docDef === field.docDef &&\n          mappedOutputField.field!.path === field.path\n        ) {\n          if (m.isFieldMapped(field)) {\n            return m.sourceFields[0]?.field!.name;\n          }\n        }\n      }\n    }\n    return null;\n  }\n}\n","// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, result);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\tvar result = _entry(_this);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tresult.then(returnValue, function(error) {\n\t\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturnValue(result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","/*\n    Copyright (C) 2017 Red Hat, Inc.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n            http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n*/\nimport {\n  CollectionType,\n  DocumentType,\n  InspectionType,\n} from '../contracts/common';\nimport {\n  ConfigModel,\n  DocumentInitializationModel,\n} from '../models/config.model';\n\nimport { CommonUtil } from './common-util';\nimport { CsvInspectionModel } from '../models/inspect/csv-inspection.model';\nimport { DocumentDefinition } from '../models/document-definition.model';\nimport { DocumentInspectionModel } from '../models/inspect/document-inspection.model';\nimport { JavaInspectionModel } from '../models/inspect/java-inspection.model';\nimport { JsonInspectionModel } from '../models/inspect/json-inspection.model';\nimport { XmlInspectionModel } from '../models/inspect/xml-inspection.model';\n\nexport class DocumentInspectionUtil {\n  /**\n   * Create one of the subclass of {@link DocumentInspectionModel} which\n   * corresponds to the existing {@link DocumentDefinition} passed in as an argument.\n   * @see fromNonJavaProperties()\n   * @see fromJavaProperties()\n   *\n   * @param cfg\n   * @param doc\n   * @returns\n   */\n  static fromDocumentDefinition(\n    cfg: ConfigModel,\n    doc: DocumentDefinition\n  ): DocumentInspectionModel {\n    switch (doc.type) {\n      case DocumentType.JAVA:\n        return new JavaInspectionModel(cfg, doc);\n      case DocumentType.JSON:\n        return new JsonInspectionModel(cfg, doc);\n      case DocumentType.XSD:\n      case DocumentType.XML:\n        return new XmlInspectionModel(cfg, doc);\n      case DocumentType.CSV:\n        return new CsvInspectionModel(cfg, doc);\n      default:\n        throw new Error(\n          `Document type '${doc.type}' is not supported for inspection`\n        );\n    }\n  }\n\n  /**\n   * Create {@link JavaInspectionModel} from arguments and add corresponding\n   * {@link DocumentDefinition} into {@link ConfigModel}.\n   * @see fromDocumentDefinition()\n   * @see fromNonJavaProperties()\n   * @todo https://github.com/atlasmap/atlasmap/issues/2919\n   * Assign GUID to Java Document ID as well, and use simple class name for default Document name\n   *\n   * @param cfg\n   * @param className\n   * @param isSource\n   * @param collectionType\n   * @param collectionClassName\n   * @returns\n   */\n  static fromJavaProperties(\n    cfg: ConfigModel,\n    className: string,\n    isSource: boolean,\n    collectionType = CollectionType.NONE,\n    collectionClassName?: string\n  ): JavaInspectionModel {\n    const model: DocumentInitializationModel =\n      new DocumentInitializationModel();\n    model.id = className;\n    const simpleName = className.split('.').pop();\n    model.name = simpleName ? simpleName : '';\n    model.type = DocumentType.JAVA;\n    model.inspectionType = InspectionType.JAVA_CLASS;\n    model.inspectionSource = className;\n    model.inspectionParameters = { '': '' };\n    model.isSource = isSource;\n    model.collectionType = collectionType;\n    model.collectionClassName = collectionClassName;\n    model.description = 'Java document class ' + className;\n    if (collectionType && collectionType !== CollectionType.NONE) {\n      model.description += ' collection type: ' + collectionType;\n      if (collectionClassName) {\n        model.description += ' collection class name: ' + collectionClassName;\n      }\n    }\n    DocumentInspectionUtil.removeDocumentIfAlreadyExists(\n      cfg,\n      model.id,\n      isSource\n    );\n    const doc = cfg.addDocument(model);\n    return new JavaInspectionModel(cfg, doc);\n  }\n\n  /**\n   * Create one of the subclass of {@link DocumentInspectionModel}\n   * other than Java from arguments and add corresponding\n   * {@link DocumentDefinition} into {@link ConfigModel}..\n   * @see fromDocumentDefinition()\n   * @see fromJavaProperties()\n   *\n   * @param cfg\n   * @param id\n   * @param name\n   * @param documentType\n   * @param inspectionType\n   * @param inspectionSource\n   * @param isSource\n   * @param inspectionParameters\n   * @returns\n   */\n  static fromNonJavaProperties(\n    cfg: ConfigModel,\n    id: string,\n    name: string,\n    documentType: DocumentType,\n    inspectionType: InspectionType,\n    inspectionSource: string,\n    isSource: boolean,\n    inspectionParameters?: { [key: string]: string }\n  ): DocumentInspectionModel {\n    const model: DocumentInitializationModel =\n      new DocumentInitializationModel();\n    model.name = name;\n    model.id = id;\n    model.type = documentType;\n    model.inspectionType = inspectionType;\n    model.inspectionSource = inspectionSource;\n    if (inspectionParameters) {\n      model.inspectionParameters = inspectionParameters;\n    } else {\n      model.inspectionParameters = { '': '' };\n    }\n    model.isSource = isSource;\n    model.description = isSource ? 'Source document ' : 'Target document ';\n    model.description += name + ' type: ' + documentType;\n    DocumentInspectionUtil.removeDocumentIfAlreadyExists(\n      cfg,\n      model.id,\n      isSource\n    );\n    const doc = cfg.addDocument(model);\n    return this.fromDocumentDefinition(cfg, doc);\n  }\n\n  private static removeDocumentIfAlreadyExists(\n    cfg: ConfigModel,\n    id: string,\n    isSource: boolean\n  ) {\n    // Clear out the existing document if importing the same name.\n    const existing = cfg.getDocForIdentifier(id, isSource);\n    if (existing) {\n      if (isSource) {\n        CommonUtil.removeItemFromArray(existing, cfg.sourceDocs);\n      } else {\n        CommonUtil.removeItemFromArray(existing, cfg.targetDocs);\n      }\n    }\n  }\n}\n","/*\n    Copyright (C) 2017 Red Hat, Inc.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n            http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n*/\nimport {\n  ErrorInfo,\n  ErrorLevel,\n  ErrorScope,\n  ErrorType,\n} from '../models/error.model';\nimport {\n  IAtlasMappingContainer,\n  IStringMapContainer,\n} from '../contracts/mapping';\nimport { gzip, inflate } from 'pako';\n\nimport { ADMDigest } from '../contracts/adm-digest';\nimport { CommonUtil } from '../utils/common-util';\nimport { ConfigModel } from '../models/config.model';\nimport { HTTP_STATUS_NO_CONTENT } from '../common/config.types';\nimport { MappingDigestUtil } from '../utils/mapping-digest-util';\nimport ky from 'ky';\nimport log from 'loglevel';\n\nexport enum FileName {\n  DIGEST = 'Mapping digest file',\n  ADM = 'ADM archive file',\n  JAR = 'Jar file',\n}\n\nexport enum FileType {\n  DIGEST = 'GZ',\n  ADM = 'ZIP',\n  JAR = 'JAR',\n}\n\n/**\n * Handles file manipulation stored in the backend, including import/export via UI.\n */\nexport class FileManagementService {\n  _cfg!: ConfigModel;\n\n  constructor(private api: typeof ky) {}\n\n  get cfg() {\n    return this._cfg;\n  }\n\n  set cfg(cfg: ConfigModel) {\n    this._cfg = cfg;\n    if (!this._cfg.logger) {\n      this._cfg.logger = log.getLogger('file-management');\n    }\n  }\n\n  findMappingFiles(filter: string): Promise<string[]> {\n    return new Promise<string[]>((resolve, reject) => {\n      const url =\n        this.cfg.initCfg.baseMappingServiceUrl +\n        'mappings' +\n        (filter == null ? '' : '?filter=' + filter);\n      this.cfg.logger!.debug('Mapping List Request');\n      this.api\n        .get(url)\n        .json<IStringMapContainer>()\n        .then((body) => {\n          this.cfg.logger!.debug(\n            `Mapping List Response: ${JSON.stringify(body)}`\n          );\n          const entries = body.StringMap.stringMapEntry;\n          resolve(entries.map((item) => item.name));\n        })\n        .catch((error: any) => {\n          if (error.status !== HTTP_STATUS_NO_CONTENT) {\n            this.cfg.errorService.addBackendError(\n              'Error occurred while accessing the current mapping files from the runtime service.',\n              error\n            );\n            reject(error);\n          }\n        });\n    });\n  }\n\n  /**\n   * Retrieve the current user data mappings digest file from the server as a GZIP compressed byte array buffer.\n   */\n  getCurrentMappingDigest(): Promise<ADMDigest | null> {\n    return new Promise<ADMDigest | null>((resolve, reject) => {\n      this.getCurrentFile(FileName.DIGEST, FileType.DIGEST)\n        .then((gzipped) => {\n          if (!gzipped) {\n            resolve(null);\n            return;\n          }\n          const gunzipped = inflate(gzipped);\n          const stringified = new Uint8Array(gunzipped).reduce(\n            (data, byte) => data + String.fromCharCode(byte),\n            ''\n          );\n          const admDigest = CommonUtil.objectize(stringified);\n          resolve(admDigest);\n        })\n        .catch((error) => {\n          reject(error);\n        });\n    });\n  }\n\n  getCurrentADMArchive(): Promise<Uint8Array | null> {\n    return this.getCurrentFile(FileName.ADM, FileType.ADM);\n  }\n\n  private getCurrentFile(\n    fileName: string,\n    fileType: string\n  ): Promise<Uint8Array | null> {\n    return new Promise<Uint8Array | null>((resolve, reject) => {\n      const url = `${this.cfg.initCfg.baseMappingServiceUrl}mapping/${fileType}/`;\n      this.cfg.logger!.debug(`Get Current ${fileName} Request: ${url}`);\n      const headers = {\n        'Content-Type': 'application/octet-stream',\n        Accept: 'application/octet-stream',\n        'Response-Type': 'application/octet-stream',\n      };\n      this.api\n        .get(url, { headers })\n        .arrayBuffer()\n        .then((body: ArrayBuffer) => {\n          this.cfg.logger!.debug(\n            `Get Current ${fileName} Response: ${JSON.stringify(body)}`\n          );\n          if (body.byteLength) {\n            resolve(new Uint8Array(body));\n          } else {\n            resolve(null);\n          }\n        })\n        .catch((error: any) => {\n          if (error.status !== HTTP_STATUS_NO_CONTENT) {\n            this.cfg.errorService.addBackendError(\n              `Error occurred while accessing the ${fileName} from the runtime service.`,\n              error\n            );\n            reject(error);\n          }\n        });\n    });\n  }\n\n  /**\n   * Delete mapping files on the runtime.\n   */\n  resetMappings(): Promise<boolean> {\n    return new Promise<boolean>((resolve) => {\n      const url = this.cfg.initCfg.baseMappingServiceUrl + 'mapping/RESET';\n      this.cfg.logger!.debug('Reset Mappings Request');\n      this.api\n        .delete(url)\n        .arrayBuffer()\n        .then((res: any) => {\n          this.cfg.logger!.debug(\n            `Reset Mappings Response: ${JSON.stringify(res)}`\n          );\n          resolve(true);\n          return res;\n        })\n        .catch((error: any) => {\n          this.cfg.errorService.addBackendError(\n            'Error occurred while resetting mappings.',\n            error\n          );\n          resolve(false);\n        });\n    });\n  }\n\n  /**\n   * Delete user-defined JAR library files on the runtime.\n   */\n  resetLibs(): Promise<boolean> {\n    return new Promise<boolean>((resolve) => {\n      const url = this.cfg.initCfg.baseMappingServiceUrl + 'mapping/resetLibs';\n      this.cfg.logger!.debug('Reset Libs Request');\n      this.api\n        .delete(url)\n        .arrayBuffer()\n        .then((res: any) => {\n          this.cfg.logger!.debug(`Reset Libs Response: ${JSON.stringify(res)}`);\n          resolve(true);\n          return res;\n        })\n        .catch((error: any) => {\n          this.cfg.errorService.addBackendError(\n            'Error occurred while resetting user-defined JAR libraries.',\n            error\n          );\n          resolve(false);\n        });\n    });\n  }\n\n  /**\n   * Clear error service and delete jar libraries, documents and mappings.\n   */\n  resetAll(): Promise<boolean> {\n    return new Promise<boolean>((resolve) => {\n      this.cfg.errorService.resetAll();\n      this.cfg.fileService\n        .resetMappings()\n        .then(async () => {\n          this.cfg.mappings = null;\n          this.cfg.clearDocs();\n          this.cfg.fileService\n            .resetLibs()\n            .then((value) => {\n              resolve(value);\n            })\n            .catch((error) => {\n              this.cfg.errorService.addBackendError(\n                `Failed to remove jar files: ${error.message}`,\n                error\n              );\n              resolve(false);\n            });\n        })\n        .catch((error) => {\n          this.cfg.errorService.addBackendError(\n            `Failed to remove mappings: ${error.message}`,\n            error\n          );\n          resolve(false);\n        });\n    });\n  }\n\n  /**\n   * Commit the specified AtlasMapping object to the runtime service.  The mappings\n   * are kept separate so they can be updated with minimal overhead.\n   *\n   * @param buffer - The stringified AtlasMapping JSON\n   */\n  setMappingToService(\n    atlasMappingContainer: IAtlasMappingContainer\n  ): Promise<boolean> {\n    const jsonBuffer = JSON.stringify(atlasMappingContainer);\n    return this.setMappingStringToService(jsonBuffer);\n  }\n\n  /**\n   * Commit the specified AtlasMapping JSON user mapping string to the runtime service.  The mappings\n   * are kept separate so they can be updated with minimal overhead.\n   *\n   * @param buffer - The stringified AtlasMapping JSON\n   */\n  setMappingStringToService(jsonBuffer: string): Promise<boolean> {\n    return new Promise<boolean>((resolve) => {\n      const url = this.cfg.initCfg.baseMappingServiceUrl + 'mapping/JSON';\n      const headers = {\n        'Content-Type': 'application/json',\n        Accept: 'application/json',\n        'Response-Type': 'application/json',\n      };\n      this.cfg.logger!.debug(\n        `Set Mapping Request (set mapping): ${jsonBuffer}`\n      );\n      this.api\n        .put(url, { headers, body: jsonBuffer })\n        .arrayBuffer()\n        .then((res) => {\n          this.cfg.logger!.debug(\n            `Set Mapping Response: ${JSON.stringify(res)}`\n          );\n          resolve(true);\n        })\n        .catch((error: any) => {\n          this.cfg.errorService.addBackendError(\n            `Unable to update the mappings file to the AtlasMap design runtime service. ${error.status} ${error.statusText}`,\n            error\n          );\n          resolve(false);\n        });\n    });\n  }\n\n  setMappingDigestToService(mappingDigest: ADMDigest): Promise<boolean> {\n    return new Promise<boolean>((resolve) => {\n      // Compress the JSON buffer - write out as binary.\n      const strBuffer = JSON.stringify(mappingDigest);\n      const binBuffer = CommonUtil.str2bytes(strBuffer);\n      let compressedBuffer: Uint8Array;\n      try {\n        compressedBuffer = gzip(binBuffer);\n      } catch (error1) {\n        this.cfg.errorService.addError(\n          new ErrorInfo({\n            message: 'Unable to compress the current data mappings.',\n            level: ErrorLevel.ERROR,\n            scope: ErrorScope.APPLICATION,\n            type: ErrorType.INTERNAL,\n            object: error1,\n          })\n        );\n        resolve(false);\n        return;\n      }\n      // Update .../target/mappings/adm-catalog-files.gz\n      const url = this.cfg.initCfg.baseMappingServiceUrl + 'mapping/GZ/0';\n      const fileContent: Blob = new Blob([compressedBuffer], {\n        type: 'application/octet-stream',\n      });\n      this.setBinaryFileToService(fileContent, url, FileName.DIGEST).then(\n        (value) => {\n          resolve(value);\n        }\n      );\n    });\n  }\n\n  private setADMArchiveFileToService(\n    compressedBuffer: BlobPart\n  ): Promise<boolean> {\n    const url = this.cfg.initCfg.baseMappingServiceUrl + 'mapping/ZIP/';\n    const fileContent: Blob = new Blob([compressedBuffer], {\n      type: 'application/octet-stream',\n    });\n    return this.setBinaryFileToService(fileContent, url, FileName.ADM);\n  }\n\n  /**\n   * The user has either exported their mappings or imported new mappings.\n   * Either way we're saving them on the server.\n   *\n   * @param compressedBuffer\n   */\n  private setBinaryFileToService(\n    compressedBuffer: BlobPart,\n    url: string,\n    fileName: FileName\n  ): Promise<boolean> {\n    return new Promise<boolean>((resolve) => {\n      this.cfg.logger!.debug(`Set ${fileName} Request`);\n      this.api\n        .put(url, { body: compressedBuffer })\n        .arrayBuffer()\n        .then((res) => {\n          this.cfg.logger!.debug(\n            `Set ${fileName} Response: ${JSON.stringify(res)}`\n          );\n          resolve(true);\n        })\n        .catch((error: any) => {\n          this.cfg.errorService.addBackendError(\n            `Unable to update the ${fileName} to the AtlasMap design runtime service.\n              ${error.status} ${error.statusText}`,\n            error\n          );\n          resolve(false);\n        });\n    });\n  }\n\n  /**\n   * Push a user-defined Java archive file (JAR binary buffer) to the runtime.\n   *\n   * @param binaryBuffer - binary JAR file\n   */\n  importJarFile(binaryBuffer: BlobPart): Promise<boolean> {\n    return new Promise<boolean>(async (resolve) => {\n      const url = this.cfg.initCfg.baseMappingServiceUrl + 'library';\n      const fileContent: Blob = new Blob([binaryBuffer], {\n        type: 'application/octet-stream',\n      });\n      const jarUpdated = await this.setBinaryFileToService(\n        fileContent,\n        url,\n        FileName.JAR\n      );\n      if (jarUpdated && this.cfg.mappingService) {\n        this.cfg.mappingService.notifyMappingUpdated();\n        await this.cfg.fieldActionService.fetchFieldActions();\n        resolve(true);\n      } else {\n        resolve(false);\n      }\n    });\n  }\n\n  /**\n   * Generate mapping digest file from current state and push it to the runtime.\n   *\n   * @returns {@link Promise}\n   */\n  updateDigestFile(): Promise<boolean> {\n    return new Promise<boolean>(async (resolve) => {\n      try {\n        let mappingJson = undefined;\n        // Retrieve the JSON mappings buffer from the server.\n        if (this.cfg.mappings) {\n          mappingJson = await this.getCurrentMappingJson();\n        }\n        const mappingDigest = MappingDigestUtil.generateMappingDigest(\n          this.cfg,\n          mappingJson\n        );\n\n        // Save mapping digest file to the runtime.\n        this.setMappingDigestToService(mappingDigest).then((value) => {\n          resolve(value);\n        });\n      } catch (error) {\n        this.cfg.errorService.addError(\n          new ErrorInfo({\n            message: 'Unable to update mapping digest file.',\n            level: ErrorLevel.ERROR,\n            scope: ErrorScope.APPLICATION,\n            type: ErrorType.INTERNAL,\n            object: error,\n          })\n        );\n        resolve(false);\n        return;\n      }\n    });\n  }\n\n  /**\n   * Update the current mapping files and export the ADM archive file with current mappings.\n   *\n   * Establish the mapping digest file content in JSON format (mappings + schema + instance-schema),\n   * compress it (GZIP), update the runtime, then fetch the full ADM archive ZIP file from the runtime\n   * and export it.\n   *\n   * @param event\n   */\n  exportADMArchive(mappingsFileName: string): Promise<boolean> {\n    return new Promise<boolean>((resolve) => {\n      this.updateDigestFile().then(() => {\n        // Fetch the full ADM archive file from the runtime (ZIP) and export it to to the local\n        // downloads area.\n        this.getCurrentADMArchive().then(async (value: Uint8Array | null) => {\n          // If value is null then no compressed mappings digest file is available on the server.\n          if (value === null) {\n            resolve(false);\n            return;\n          }\n          // Tack on a .adm suffix if one wasn't already specified.\n          if (mappingsFileName.split('.').pop() !== 'adm') {\n            mappingsFileName = mappingsFileName.concat('.adm');\n          }\n          const fileContent = new Blob([value], {\n            type: 'application/octet-stream',\n          });\n          CommonUtil.writeFile(fileContent, mappingsFileName)\n            .then((value2) => {\n              resolve(value2);\n            })\n            .catch((error) => {\n              this.cfg.errorService.addError(\n                new ErrorInfo({\n                  message: 'Unable to save the current data mappings.',\n                  level: ErrorLevel.ERROR,\n                  scope: ErrorScope.APPLICATION,\n                  type: ErrorType.INTERNAL,\n                  object: error,\n                })\n              );\n              resolve(false);\n            });\n        });\n      });\n    });\n  }\n\n  /**\n   * Clean up all existing mappings, documents, libraries and import specified ADM archive file,\n   * push it to the runtime and reflect back in UI. The ADM file is in (ZIP) file format.\n   * Once pushed, we can retrieve from runtime the extracted compressed (GZIP) mappings\n   * digest file as well as the mappings JSON file.  These files exist separately for performance reasons.\n   *\n   * Once the runtime has its ADM archive file, digest file and mappings file set then restart the DM.\n   *\n   * @param mappingsFileName - ADM archive file\n   */\n  importADMArchive(admFile: File): Promise<boolean> {\n    return new Promise<boolean>((resolve) => {\n      this.resetAll().then(() => {\n        const reader = new FileReader();\n\n        // Turn the imported ADM file into a binary octet stream.\n        CommonUtil.readBinaryFile(admFile, reader)\n          .then((fileBin) => {\n            // Push the binary stream to the runtime.\n            this.setADMArchiveFileToService(fileBin).then((value) => {\n              resolve(value);\n            });\n          })\n          .catch((error) => {\n            this.cfg.errorService.addError(\n              new ErrorInfo({\n                message: `Unable to import the specified ADM file '${admFile.name}'`,\n                level: ErrorLevel.ERROR,\n                scope: ErrorScope.APPLICATION,\n                type: ErrorType.INTERNAL,\n                object: error,\n              })\n            );\n            resolve(false);\n          });\n      });\n    });\n  }\n\n  /**\n   * Retrieve the current user AtlasMap data mappings from the server as a JSON object.\n   */\n  getCurrentMappingJson(): Promise<IAtlasMappingContainer> {\n    return new Promise<any>((resolve, reject) => {\n      if (this.cfg.mappings === null) {\n        reject();\n        return;\n      }\n      this.cfg.mappingFiles[0] = this.cfg.mappings.name!;\n      const baseURL: string =\n        this.cfg.initCfg.baseMappingServiceUrl + 'mapping/JSON/';\n      this.cfg.logger!.debug('Get Current Mapping Request');\n      this.api\n        .get(baseURL)\n        .json<IAtlasMappingContainer>()\n        .then((body) => {\n          this.cfg.logger!.debug(\n            `Get Current Mapping Response: ${JSON.stringify(body)}`\n          );\n          resolve(body);\n        })\n        .catch((error: any) => {\n          if (error.status !== HTTP_STATUS_NO_CONTENT) {\n            this.cfg.errorService.addBackendError(\n              'Error occurred while accessing the current mappings from the backend service.',\n              error\n            );\n            reject(error);\n          } else {\n            resolve(undefined);\n          }\n        });\n    });\n  }\n}\n","/*\n    Copyright (C) 2017 Red Hat, Inc.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n            http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n*/\n/*\n    Generate a global unique identifier.\n    Ref: https://stackoverflow.com/questions/26501688/a-typescript-guid-class\n*/\nexport class Guid {\n  static newGuid() {\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(\n      /[xy]/g,\n      function (c) {\n        var r = (Math.random() * 16) | 0,\n          v = c === 'x' ? r : (r & 0x3) | 0x8;\n        return v.toString(16);\n      }\n    );\n  }\n}\n","/*\n    Copyright (C) 2017 Red Hat, Inc.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n            http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n*/\nimport { ErrorInfo, ErrorScope, ErrorType } from '../models/error.model';\nimport { LookupTable, LookupTableEntry } from '../models/lookup-table.model';\n\nimport { ConfigModel } from '../models/config.model';\nimport { Field } from '../models/field.model';\nimport { MappingDefinition } from '../models/mapping-definition.model';\nimport { MappingModel } from '../models/mapping.model';\nimport { TransitionMode } from '../models/transition.model';\n\nconst EnumerationUnspecified = '[ None ]';\n\n/**\n * Lookup table structure.\n */\nexport class LookupTableData {\n  sourceEnumValue: string;\n  targetEnumValues: string[];\n  selectedTargetEnumValue: string;\n}\n\n/**\n * Static lookup table utility methods.\n */\nexport class LookupTableUtil {\n  static populateMappingLookupTable(\n    mappingDefinition: MappingDefinition,\n    m: MappingModel\n  ): void {\n    if (\n      !(\n        m.transition.mode === TransitionMode.ENUM &&\n        !m.transition.lookupTableName &&\n        m.getFields(true).length === 1 &&\n        m.getFields(false).length === 1\n      )\n    ) {\n      return;\n    }\n    let inputIdentifier: string | undefined;\n    let outputIdentifier: string | undefined;\n\n    const inputField: Field = m.getFields(true)[0];\n    if (inputField) {\n      inputIdentifier = inputField.name + '-' + inputField.docDef.id;\n    }\n    const outputField: Field = m.getFields(true)[0];\n    if (outputField) {\n      outputIdentifier = outputField.name + '-' + outputField.docDef.id;\n    }\n    if (inputIdentifier && outputIdentifier) {\n      let table: LookupTable = mappingDefinition.getTableBySourceTarget(\n        inputIdentifier,\n        outputIdentifier\n      );\n      if (!table) {\n        table = new LookupTable();\n        table.sourceIdentifier = inputIdentifier;\n        table.targetIdentifier = outputIdentifier;\n        mappingDefinition.addTable(table);\n        m.transition.lookupTableName = table.name;\n      } else {\n        m.transition.lookupTableName = table.name;\n      }\n    }\n  }\n\n  static updateLookupTables(mappingDefinition: MappingDefinition) {\n    for (const t of mappingDefinition.getTables()) {\n      if (t.sourceIdentifier && t.targetIdentifier) {\n        continue;\n      }\n      const m: MappingModel = LookupTableUtil.getFirstMappingForLookupTable(\n        mappingDefinition,\n        t.name\n      );\n      if (m && m.transition.lookupTableName) {\n        if (!t.sourceIdentifier) {\n          const inputField: Field = m.getFields(true)[0];\n          if (inputField) {\n            t.sourceIdentifier = inputField.classIdentifier;\n          }\n        }\n        if (!t.targetIdentifier) {\n          const outputField: Field = m.getFields(false)[0];\n          if (outputField) {\n            t.targetIdentifier = outputField.classIdentifier;\n          }\n        }\n      }\n    }\n    for (const m of mappingDefinition.mappings) {\n      LookupTableUtil.populateMappingLookupTable(mappingDefinition, m);\n    }\n  }\n\n  private static getFirstMappingForLookupTable(\n    mappingDefinition: MappingDefinition,\n    lookupTableName: string\n  ): MappingModel {\n    // TODO: check this non null operator\n    return mappingDefinition.mappings.find(\n      (m) => m.transition.lookupTableName === lookupTableName\n    )!;\n  }\n\n  private static errorNoTable(cfg: ConfigModel, mapping: MappingModel) {\n    cfg.errorService.addError(\n      new ErrorInfo({\n        message:\n          'Could not find enumeration lookup table ' +\n          mapping.transition?.lookupTableName +\n          ' for mapping.',\n        scope: ErrorScope.MAPPING,\n        type: ErrorType.INTERNAL,\n        mapping: mapping,\n      })\n    );\n  }\n\n  static getEnumerationValues(\n    cfg: ConfigModel,\n    mapping: MappingModel\n  ): LookupTableData[] {\n    if (!cfg || !cfg.mappings || !mapping) {\n      return [];\n    }\n    const targetField: Field = mapping.getFields(false)[0];\n    const targetValues: string[] = [];\n    targetValues.push('[ None ]');\n    for (const e of targetField.enumValues) {\n      targetValues.push(e.name);\n    }\n\n    const table = cfg.mappings.getTableByName(\n      mapping.transition?.lookupTableName!\n    );\n    if (!table) {\n      LookupTableUtil.errorNoTable(cfg, mapping);\n      return [];\n    }\n\n    const enumVals: LookupTableData[] = [];\n    const sourceField: Field = mapping.getFields(true)[0];\n    for (const sourceEnum of sourceField.enumValues) {\n      const tableData: LookupTableData = new LookupTableData();\n      tableData.sourceEnumValue = sourceEnum.name;\n      tableData.targetEnumValues = targetValues;\n      const selected: LookupTableEntry | null = table.getEntryForSource(\n        tableData.sourceEnumValue,\n        false\n      );\n      tableData.selectedTargetEnumValue =\n        selected == null ? EnumerationUnspecified : selected.targetValue;\n      enumVals.push(tableData);\n    }\n    return enumVals;\n  }\n\n  static updateEnumerationValues(\n    cfg: ConfigModel,\n    mapping: MappingModel,\n    enumerationValues: LookupTableData[]\n  ) {\n    if (!cfg || !cfg.mappings || !mapping) {\n      return;\n    }\n    const table = cfg.mappings.getTableByName(\n      mapping.transition?.lookupTableName!\n    );\n    if (!table) {\n      LookupTableUtil.errorNoTable(cfg, mapping);\n      return;\n    }\n    table.lookupEntry = [];\n    for (const enumValue of enumerationValues) {\n      if (enumValue.selectedTargetEnumValue === EnumerationUnspecified) {\n        continue;\n      }\n      const lte: LookupTableEntry = new LookupTableEntry();\n      lte.sourceValue = enumValue.sourceEnumValue;\n      lte.targetValue = enumValue.selectedTargetEnumValue;\n      table.lookupEntry.push(lte);\n    }\n  }\n}\n","/*\n    Copyright (C) 2017 Red Hat, Inc.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n            http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n*/\nimport { ADMDigest } from '../contracts/adm-digest';\nimport { CommonUtil } from './common-util';\nimport { ConfigModel } from '../models/config.model';\n\nexport class MappingDigestUtil {\n  static generateMappingDigest(cfg: ConfigModel, mappingJson: any): ADMDigest {\n    let mappingDigest: ADMDigest = {\n      exportMappings: { value: '' },\n      exportMeta: [],\n      exportBlockData: [],\n    };\n\n    // Retrieve the JSON mappings buffer from the server.\n    const jsonBuffer = JSON.stringify(mappingJson);\n    if (jsonBuffer) {\n      mappingDigest.exportMappings.value = CommonUtil.sanitizeJSON(jsonBuffer);\n    }\n\n    for (const doc of cfg.getAllDocs()) {\n      if (!doc.isPropertyOrConstant) {\n        mappingDigest.exportMeta.push({\n          name: doc.name,\n          dataSourceType: doc.type,\n          id: doc.id,\n          inspectionType: doc.inspectionType,\n          inspectionParameters: doc.inspectionParameters,\n          isSource: doc.isSource,\n        });\n        mappingDigest.exportBlockData.push({ value: doc.inspectionSource });\n      }\n    }\n    return mappingDigest;\n  }\n}\n","/*\n    Copyright (C) 2017 Red Hat, Inc.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n            http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n*/\nimport {\n  CONSTANT_FIELD_JSON_TYPE,\n  IPropertyField,\n  PROPERTY_FIELD_JSON_TYPE,\n} from '../contracts/mapping';\nimport {\n  DocumentDefinition,\n  PaddingField,\n} from '../models/document-definition.model';\nimport {\n  ErrorInfo,\n  ErrorLevel,\n  ErrorScope,\n  ErrorType,\n} from '../models/error.model';\nimport { MappedField, MappingModel } from '../models/mapping.model';\nimport { ConfigModel } from '../models/config.model';\nimport { Field } from '../models/field.model';\nimport { IField } from '../contracts/common';\n\n/**\n * Static routines for handling mappings.\n */\nexport class MappingUtil {\n  static updateMappingsFromDocuments(cfg: ConfigModel): void {\n    // TODO: check this non null operator\n    for (const mapping of cfg.mappings!.mappings) {\n      MappingUtil.updateMappedFieldsFromDocuments(mapping, cfg, true);\n      MappingUtil.updateMappedFieldsFromDocuments(mapping, cfg, false);\n    }\n    for (const doc of cfg.getAllDocs()) {\n      if (doc.id == null) {\n        doc.id =\n          'DOC.' +\n          doc.name +\n          '.' +\n          Math.floor(Math.random() * 1000000 + 1).toString();\n      }\n    }\n  }\n\n  static updateMappedFieldsFromDocuments(\n    mapping: MappingModel,\n    cfg: ConfigModel,\n    isSource: boolean\n  ): void {\n    let mappedFields: MappedField[] = mapping.getMappedFields(isSource);\n    let mappedFieldIndex = -1;\n\n    for (const mappedField of mappedFields) {\n      let doc: DocumentDefinition | null = null;\n      mappedFieldIndex += 1;\n\n      if (\n        mappedField.field instanceof PaddingField ||\n        mappedField.mappingField === undefined\n      ) {\n        continue;\n      }\n      if (MappingUtil.isPropertyField(mappedField.mappingField)) {\n        doc = isSource ? cfg.sourcePropertyDoc : cfg.targetPropertyDoc;\n        // Preserve property Document ID from parsed data\n        if (mappedField.mappingField.docId) {\n          doc.id = mappedField.mappingField.docId;\n        }\n      } else if (MappingUtil.isConstantField(mappedField.mappingField)) {\n        doc = cfg.constantDoc;\n        // Preserve constant Document ID from parsed data\n        if (mappedField.mappingField.docId) {\n          doc.id = mappedField.mappingField.docId;\n        }\n      } else {\n        if (mappedField.mappingField.docId == null) {\n          cfg.errorService.addError(\n            new ErrorInfo({\n              message: `Could not find doc ID for mapped field ${mappedField.mappingField.name}`,\n              level: ErrorLevel.ERROR,\n              scope: ErrorScope.APPLICATION,\n              type: ErrorType.INTERNAL,\n            })\n          );\n          continue;\n        }\n        doc = cfg.getDocForIdentifier(\n          mappedField.mappingField.docId!,\n          isSource\n        );\n        if (doc == null) {\n          if (mappedField.mappingField.name != null) {\n            cfg.errorService.addError(\n              new ErrorInfo({\n                message: `Could not find document for mapped field '${mappedField.mappingField.name}' \\\nwith ID ${mappedField.mappingField.docId}`,\n                level: ErrorLevel.ERROR,\n                scope: ErrorScope.APPLICATION,\n                type: ErrorType.INTERNAL,\n              })\n            );\n          }\n          continue;\n        }\n\n        doc.id = mappedField.mappingField.docId;\n      }\n\n      if (!mappedField.mappingField.path) {\n        continue;\n      }\n      mappedField.field = doc.getField(mappedField.mappingField.path);\n\n      if (mappedField.field == null) {\n        // Check for collection instance.\n        if (mappedField.mappingField.path.indexOf('<0>') >= 0) {\n          mappedField.field = doc.getField(\n            mappedField.mappingField.path!.replace('<0>', '<>')\n          );\n        } else if (\n          MappingUtil.isConstantField(mappedField.mappingField) &&\n          mappedField.mappingField.value &&\n          mappedField.mappingField.fieldType\n        ) {\n          let constantField = cfg.constantDoc.getField(\n            mappedField.mappingField.value\n          );\n          if (!constantField) {\n            constantField = new Field();\n          }\n          constantField.value = mappedField.mappingField.value;\n          constantField.type = mappedField.mappingField.fieldType;\n          constantField.displayName = constantField.value;\n          constantField.name = constantField.value;\n          constantField.path = constantField.value;\n          constantField.userCreated = true;\n          mappedField.field = constantField;\n          doc.addField(constantField);\n        } else if (\n          MappingUtil.isPropertyField(mappedField.mappingField) &&\n          mappedField.mappingField.fieldType &&\n          mappedField.mappingField.name &&\n          mappedField.mappingField.path\n        ) {\n          const propMappingField = mappedField.mappingField as IPropertyField;\n          let propertyField = doc.getField(propMappingField.path!);\n\n          if (!propertyField) {\n            propertyField = new Field();\n          }\n          let fieldName = propMappingField.name;\n          propertyField.type = propMappingField.fieldType!;\n          if (propMappingField.scope) {\n            propertyField.scope = propMappingField.scope;\n          }\n          propertyField.displayName = fieldName!;\n          propertyField.name = fieldName!;\n          propertyField.path = propMappingField.path!;\n          propertyField.userCreated = true;\n          mappedField.field = propertyField;\n          doc.addField(propertyField);\n        } else {\n          cfg.errorService.addError(\n            new ErrorInfo({\n              message: `Could not find field from document '${doc.name}' for mapped field '${mappedField.mappingField.name}'`,\n              level: ErrorLevel.ERROR,\n              scope: ErrorScope.APPLICATION,\n              type: ErrorType.INTERNAL,\n              object: { mappedField: mappedField, doc: doc },\n            })\n          );\n          return;\n        }\n      }\n\n      const zeroBasedIndex = +mappedField.mappingField.index!; // TODO: check this non null operator\n      mappedFields = mapping.getMappedFields(isSource);\n      if (zeroBasedIndex <= mappedFieldIndex) {\n        mappedFields[mappedFieldIndex] = mappedField;\n      } else {\n        cfg.mappingService.addPlaceholders(\n          zeroBasedIndex - mappedFieldIndex,\n          mapping,\n          mappedFieldIndex,\n          isSource\n        );\n      }\n    }\n  }\n\n  /**\n   * Check all mappings in the current context and remove if it refers to un-existing fields.\n   *\n   * @param cfg ConfigModel\n   */\n  static removeStaleMappings(cfg: ConfigModel): void {\n    let index = 0;\n    let sourceFieldPaths: string[] = [];\n    for (const doc of cfg.getDocs(true)) {\n      sourceFieldPaths = sourceFieldPaths.concat(\n        Field.getFieldPaths(doc.getAllFields())\n      );\n    }\n    let targetSourcePaths: string[] = [];\n    for (const doc of cfg.getDocs(false)) {\n      targetSourcePaths = targetSourcePaths.concat(\n        Field.getFieldPaths(doc.getAllFields())\n      );\n    }\n    // TODO: check these non null operator\n    while (index < cfg.mappings!.mappings.length) {\n      const mapping: MappingModel = cfg.mappings!.mappings[index];\n      const mappingIsStale: boolean = this.isMappingStale(\n        mapping,\n        sourceFieldPaths,\n        targetSourcePaths\n      );\n      if (mappingIsStale) {\n        cfg.mappings!.mappings.splice(index, 1);\n      } else {\n        index++;\n      }\n    }\n  }\n\n  private static isMappingStale(\n    mapping: MappingModel,\n    sourceFieldPaths: string[],\n    targetSourcePaths: string[]\n  ): boolean {\n    for (const field of mapping.getFields(true)) {\n      if (\n        !(field instanceof PaddingField) &&\n        sourceFieldPaths.indexOf(field.path) === -1\n      ) {\n        return true;\n      }\n    }\n    for (const field of mapping.getFields(false)) {\n      if (\n        !(field instanceof PaddingField) &&\n        targetSourcePaths.indexOf(field.path) === -1\n      ) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  static updateDocumentNamespacesFromMappings(cfg: ConfigModel): void {\n    const docs: DocumentDefinition[] = cfg.getDocs(false);\n\n    // TODO: check this non null operator\n    for (const parsedDoc of cfg.mappings!.parsedDocs) {\n      if (!parsedDoc) {\n        continue;\n      }\n      if (parsedDoc.isSource) {\n        continue;\n      }\n      if (parsedDoc.namespaces.length === 0) {\n        continue;\n      }\n\n      const doc = this.getDocById(parsedDoc.id, docs);\n      if (doc == null) {\n        cfg.errorService.addError(\n          new ErrorInfo({\n            message: `Could not find document with identifier '${parsedDoc.id}' for namespace override.`,\n            level: ErrorLevel.ERROR,\n            scope: ErrorScope.APPLICATION,\n            type: ErrorType.INTERNAL,\n            object: {\n              identifier: parsedDoc.id,\n              parsedDoc: parsedDoc,\n              docs: docs,\n            },\n          })\n        );\n        continue;\n      }\n\n      doc.namespaces = [...parsedDoc.namespaces];\n    }\n  }\n\n  private static getDocById(\n    documentId: string,\n    docs: DocumentDefinition[]\n  ): DocumentDefinition | null {\n    if (documentId == null || docs == null || !docs.length) {\n      return null;\n    }\n    for (const doc of docs) {\n      if (doc.id === documentId) {\n        return doc;\n      }\n    }\n    return null;\n  }\n\n  static activeMapping(cfg: ConfigModel): boolean {\n    return !!cfg?.mappings?.activeMapping;\n  }\n\n  /**\n   * Return true if the specified mapped field array has any established field actions,\n   * false otherwise.\n   *\n   * @param fields\n   */\n  static hasFieldAction(fields: MappedField[]): boolean {\n    for (let field of fields) {\n      if (field.actions.length > 0) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  static hasMappedCollection(\n    mapping: MappingModel,\n    isSource: boolean\n  ): boolean | null {\n    const mappedFields = mapping.getMappedFields(isSource);\n    return (\n      mapping.isFullyMapped() &&\n      mappedFields[0].field &&\n      mappedFields[0].field.isInCollection()\n    );\n  }\n\n  static isPropertyField(field: IField) {\n    return field?.jsonType === PROPERTY_FIELD_JSON_TYPE;\n  }\n\n  static isConstantField(field: IField) {\n    return field?.jsonType === CONSTANT_FIELD_JSON_TYPE;\n  }\n}\n","/*\n    Copyright (C) 2017 Red Hat, Inc.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n            http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n*/\n\nimport {\n  ATLAS_MAPPING_JSON_TYPE,\n  COLLECTION_JSON_TYPE,\n  CONSTANT_FIELD_JSON_TYPE,\n  FIELD_GROUP_JSON_TYPE,\n  IAtlasMappingContainer,\n  ICollection,\n  IConstant,\n  IFieldGroup,\n  IJsonDataSource,\n  ILookupEntry,\n  ILookupTable,\n  IMapping,\n  IProperty,\n  IPropertyField,\n  MAPPING_JSON_TYPE,\n  MappingType,\n  PROPERTY_FIELD_JSON_TYPE,\n} from '../contracts/mapping';\nimport {\n  DATA_SOURCE_JSON_TYPE,\n  DataSourceType,\n  DocumentType,\n  FIELD_PATH_SEPARATOR,\n  FieldType,\n  IDataSource,\n  IField,\n  IFieldAction,\n} from '../contracts/common';\nimport {\n  DocumentDefinition,\n  NamespaceModel,\n} from '../models/document-definition.model';\nimport {\n  ErrorInfo,\n  ErrorLevel,\n  ErrorScope,\n  ErrorType,\n} from '../models/error.model';\nimport {\n  FieldAction,\n  FieldActionArgument,\n  FieldActionArgumentValue,\n} from '../models/field-action.model';\nimport {\n  IXmlDataSource,\n  IXmlField,\n  IXmlNamespace,\n  XML_DATA_SOURCE_JSON_TYPE,\n  XML_ENUM_FIELD_JSON_TYPE,\n  XML_MODEL_PACKAGE_PREFIX,\n} from '../contracts/documents/xml';\nimport {\n  JSON_DATA_SOURCE_JSON_TYPE,\n  JSON_ENUM_FIELD_JSON_TYPE,\n} from '../contracts/documents/json';\nimport { LookupTable, LookupTableEntry } from '../models/lookup-table.model';\nimport { MappedField, MappingModel } from '../models/mapping.model';\nimport { TransitionMode, TransitionModel } from '../models/transition.model';\n\nimport { ConfigModel } from '../models/config.model';\nimport { ExpressionModel } from '../models/expression.model';\nimport { Field } from '../models/field.model';\nimport { IAudits } from '../contracts/mapping-preview';\nimport { ICsvField } from '../contracts/documents/csv';\nimport { IJavaField } from '../contracts/documents/java';\nimport { JAVA_ENUM_FIELD_JSON_TYPE } from '../contracts/documents/java';\nimport { MappingDefinition } from '../models/mapping-definition.model';\nimport { MappingUtil } from './mapping-util';\nimport { Multiplicity } from '../contracts/field-action';\n\nexport class MappingSerializer {\n  static serializeMappings(\n    cfg: ConfigModel,\n    ignoreValue: boolean = true\n  ): IAtlasMappingContainer {\n    // TODO: check this non null operator\n    const mappingDefinition: MappingDefinition = cfg.mappings!;\n    let jsonMappings: IMapping[] = [];\n    for (const mapping of mappingDefinition.mappings.filter((m) =>\n      m.isFullyMapped()\n    )) {\n      try {\n        const serializedFieldMapping = MappingSerializer.serializeFieldMapping(\n          cfg,\n          mapping,\n          mapping.uuid,\n          ignoreValue\n        );\n        if (serializedFieldMapping) {\n          jsonMappings = jsonMappings.concat(serializedFieldMapping);\n        }\n      } catch (e) {\n        const input: any = {\n          mapping: mapping,\n          'mapping def': mappingDefinition,\n        };\n        cfg.errorService.addError(\n          new ErrorInfo({\n            message:\n              'Caught exception while attempting to serialize mapping, skipping. ',\n            level: ErrorLevel.ERROR,\n            scope: ErrorScope.APPLICATION,\n            type: ErrorType.INTERNAL,\n            object: { input: input, error: e },\n          })\n        );\n      }\n    }\n\n    const serializedLookupTables = MappingSerializer.serializeLookupTables(\n      cfg.mappings!\n    );\n    const constantDescriptions: IConstant[] =\n      MappingSerializer.serializeConstants(cfg.constantDoc);\n    const sourcePropertyDescriptions: IProperty[] =\n      MappingSerializer.serializeProperties(cfg.sourcePropertyDoc);\n    const targetPropertyDescriptions: IProperty[] =\n      MappingSerializer.serializeProperties(cfg.targetPropertyDoc);\n    const serializedDataSources: IDataSource[] =\n      MappingSerializer.serializeDocuments(\n        cfg.sourceDocs.concat(cfg.targetDocs),\n        mappingDefinition\n      );\n\n    const payload: IAtlasMappingContainer = {\n      AtlasMapping: {\n        jsonType: ATLAS_MAPPING_JSON_TYPE,\n        dataSource: serializedDataSources,\n        mappings: { mapping: jsonMappings },\n        name: cfg.mappings!.name ? cfg.mappings!.name : undefined,\n        lookupTables: { lookupTable: serializedLookupTables },\n        constants: { constant: constantDescriptions },\n        properties: {\n          property: sourcePropertyDescriptions.concat(\n            targetPropertyDescriptions\n          ),\n        },\n      },\n    };\n    return payload;\n  }\n\n  static serializeFieldMapping(\n    cfg: ConfigModel,\n    mapping: MappingModel,\n    id: string,\n    ignoreValue: boolean = true\n  ): IMapping {\n    const serializedInputFields = MappingSerializer.serializeFields(\n      mapping,\n      true,\n      cfg,\n      ignoreValue\n    );\n    const serializedOutputFields = MappingSerializer.serializeFields(\n      mapping,\n      false,\n      cfg,\n      ignoreValue\n    );\n    let jsonMapping: IMapping;\n    const mappingExpression = cfg.expressionService.getMappingExpressionStr(\n      false,\n      mapping\n    );\n\n    if (\n      mapping.transition.isManyToOneMode() ||\n      mapping.transition.isForEachMode() ||\n      mapping.transition.isExpressionMode()\n    ) {\n      const actions = [];\n      if (mapping.transition.transitionFieldAction) {\n        actions[0] = this.serializeAction(\n          mapping.transition.transitionFieldAction,\n          cfg\n        );\n      }\n      const field = serializedInputFields;\n      const inputFieldGroup: IFieldGroup = {\n        jsonType: FIELD_GROUP_JSON_TYPE,\n        actions,\n        field,\n      };\n      if (mappingExpression.length > 0) {\n        jsonMapping = {\n          jsonType: MAPPING_JSON_TYPE,\n          id: id,\n          expression: mappingExpression,\n          inputFieldGroup,\n          outputField: serializedOutputFields,\n        };\n      } else {\n        jsonMapping = {\n          jsonType: MAPPING_JSON_TYPE,\n          id: id,\n          inputFieldGroup,\n          outputField: serializedOutputFields,\n        };\n      }\n    } else {\n      if (\n        mapping.transition.isOneToManyMode() &&\n        mapping.transition.transitionFieldAction\n      ) {\n        const mappingAction = this.serializeAction(\n          mapping.transition.transitionFieldAction,\n          cfg\n        );\n        if (!serializedInputFields[0].actions) {\n          serializedInputFields[0].actions = [];\n        }\n        if (mappingAction) {\n          serializedInputFields[0].actions.unshift(mappingAction);\n        }\n      }\n      if (mappingExpression.length > 0) {\n        if (serializedInputFields[0].jsonType?.includes('FieldGroup')) {\n          let serializedInputFieldGroup =\n            serializedInputFields[0] as IFieldGroup;\n          for (let i = 1; i < serializedInputFields.length; i++) {\n            if (serializedInputFields[i].jsonType?.includes('FieldGroup')) {\n              const serializedFieldGroup0 =\n                serializedInputFields[0] as IFieldGroup;\n              const serializedFieldGroupi = serializedInputFields[\n                i\n              ] as IFieldGroup;\n              if (\n                serializedFieldGroupi.field &&\n                serializedFieldGroup0.field &&\n                serializedFieldGroupi.field[0].path ===\n                  serializedFieldGroup0.field[0].path\n              ) {\n                serializedInputFieldGroup.field?.push(\n                  serializedFieldGroupi.field[0]\n                );\n              }\n            }\n            // TODO - Support input fields from different complex parent fields\n            // in the same complex conditional expression.\n          }\n\n          jsonMapping = {\n            jsonType: MAPPING_JSON_TYPE,\n            id: id,\n            expression: mappingExpression,\n            inputFieldGroup: serializedInputFieldGroup,\n            outputField: serializedOutputFields,\n          };\n        } else {\n          jsonMapping = {\n            jsonType: MAPPING_JSON_TYPE,\n            id: id,\n            expression: mappingExpression,\n            inputField: serializedInputFields,\n            outputField: serializedOutputFields,\n          };\n        }\n      } else {\n        jsonMapping = {\n          jsonType: MAPPING_JSON_TYPE,\n          id: id,\n          inputField: serializedInputFields,\n          outputField: serializedOutputFields,\n        };\n      }\n    }\n\n    if (mapping.transition.isEnumerationMode()) {\n      jsonMapping.mappingType = MappingType.LOOKUP; /* @deprecated */\n      if (mapping.transition.lookupTableName) {\n        jsonMapping.lookupTableName = mapping.transition.lookupTableName;\n      }\n    }\n    return jsonMapping;\n  }\n\n  static deserializeMappingServiceJSON(\n    json: IAtlasMappingContainer,\n    cfg: ConfigModel\n  ): void {\n    // Process constants and properties before mappings.\n    for (const field of MappingSerializer.deserializeConstants(json)) {\n      cfg.constantDoc.addField(field);\n    }\n    for (const field of MappingSerializer.deserializeProperties(\n      cfg,\n      json,\n      true\n    )) {\n      cfg.sourcePropertyDoc.addField(field);\n    }\n    for (const field of MappingSerializer.deserializeProperties(\n      cfg,\n      json,\n      false\n    )) {\n      cfg.targetPropertyDoc.addField(field);\n    }\n    if (!cfg.mappings) {\n      cfg.mappings = new MappingDefinition();\n    }\n    cfg.mappings.name = this.deserializeAtlasMappingName(json);\n    cfg.mappings.parsedDocs = cfg.mappings.parsedDocs.concat(\n      MappingSerializer.deserializeDocs(json, cfg.mappings)!\n    ); // TODO: check this non null operator\n    cfg.mappings.mappings = cfg.mappings.mappings.concat(\n      MappingSerializer.deserializeMappings(json, cfg)\n    );\n    for (const lookupTable of MappingSerializer.deserializeLookupTables(json)) {\n      cfg.mappings.addTable(lookupTable);\n    }\n  }\n\n  /**\n   * Return the AtlasMap mappings file name from the specified JSON buffer or an empty string.\n   *\n   * @param json\n   */\n  static deserializeAtlasMappingName(json: IAtlasMappingContainer): string {\n    if (json?.AtlasMapping?.name) {\n      return json.AtlasMapping.name;\n    } else {\n      return '';\n    }\n  }\n\n  static addInputFieldGroupFields(\n    inputField: IField[],\n    mapping: MappingModel,\n    cfg: ConfigModel\n  ) {\n    for (const field of inputField) {\n      if (field.fieldType === 'COMPLEX') {\n        MappingSerializer.addInputFieldGroupFields(\n          (field as IFieldGroup).field!,\n          mapping,\n          cfg\n        );\n      } else {\n        MappingSerializer.deserializeMappedField(mapping, field, true, cfg);\n      }\n    }\n  }\n\n  static deserializeFieldMapping(\n    mappingJson: IMapping,\n    cfg: ConfigModel\n  ): MappingModel {\n    const mapping = new MappingModel();\n    mapping.uuid = mappingJson.id;\n    mapping.sourceFields = [];\n    mapping.targetFields = [];\n    mapping.referenceFields = [];\n    mapping.transition.mode = TransitionMode.ONE_TO_ONE;\n    const isLookupMapping =\n      mappingJson.mappingType === 'LOOKUP' ||\n      mappingJson.lookupTableName != null;\n\n    if (\n      mappingJson.mappingType &&\n      mappingJson.mappingType !== MappingType.NONE\n    ) {\n      this.deserializeFieldMappingFromType(mapping, mappingJson, cfg);\n      return mapping;\n    }\n\n    if (mappingJson.inputFieldGroup) {\n      MappingSerializer.deserializeInputFieldGroup(mappingJson, mapping, cfg);\n    } else {\n      const inputField = mappingJson.inputField;\n\n      if (inputField) {\n        for (const field of inputField) {\n          MappingSerializer.deserializeMappedField(mapping, field, true, cfg);\n        }\n      }\n      if (\n        mappingJson.outputField?.length &&\n        mappingJson.outputField.length > 1\n      ) {\n        mapping.transition.mode = TransitionMode.ONE_TO_MANY;\n      }\n      if (cfg.mappings) {\n        MappingUtil.updateMappedFieldsFromDocuments(mapping, cfg, true);\n      }\n    }\n\n    if (mappingJson.expression && mappingJson.expression.length > 0) {\n      mapping.transition.enableExpression = true;\n      mapping.transition.mode = TransitionMode.EXPRESSION;\n      mapping.transition.expression = new ExpressionModel(mapping, cfg);\n      mapping.transition.expression.insertText(mappingJson.expression);\n    }\n\n    for (const field of mappingJson.outputField) {\n      MappingSerializer.deserializeMappedField(mapping, field, false, cfg);\n    }\n    MappingUtil.updateMappedFieldsFromDocuments(mapping, cfg, false);\n\n    if (isLookupMapping) {\n      mapping.transition.lookupTableName = mappingJson.lookupTableName!;\n      mapping.transition.mode = TransitionMode.ENUM;\n    }\n\n    return mapping;\n  }\n\n  private static deserializeInputFieldGroup(\n    mappingJson: IMapping,\n    mapping: MappingModel,\n    cfg: ConfigModel\n  ) {\n    if (!mappingJson.inputFieldGroup) {\n      return;\n    }\n\n    if (\n      mappingJson.expression &&\n      mappingJson.inputFieldGroup!.fieldType === FieldType.COMPLEX\n    ) {\n      mapping.transition.expression.hasComplexField = true;\n    }\n    mapping.transition.mode = TransitionMode.MANY_TO_ONE;\n\n    MappingSerializer.addInputFieldGroupFields(\n      mappingJson.inputFieldGroup.field!,\n      mapping,\n      cfg\n    );\n    MappingUtil.updateMappedFieldsFromDocuments(mapping, cfg, true);\n\n    if (\n      mappingJson.inputFieldGroup.actions &&\n      mappingJson.inputFieldGroup.actions[0]?.delimiter\n    ) {\n      mapping.transition.delimiter = TransitionModel.delimiterToModel(\n        mappingJson.inputFieldGroup.actions[0]?.delimiter\n      )?.delimiter;\n      // Check for an InputFieldGroup containing a many-to-one action\n      const firstAction = mappingJson.inputFieldGroup.actions[0];\n      if (firstAction) {\n        // @deprecated Support legacy ADM files that have transformation-action-based expressions.\n        if (firstAction.Expression || firstAction['@type'] === 'Expression') {\n          mapping.transition.enableExpression = true;\n          mapping.transition.mode = TransitionMode.EXPRESSION;\n          mapping.transition.expression = new ExpressionModel(mapping, cfg);\n          const expr = firstAction.Expression\n            ? firstAction.Expression.expression\n            : firstAction['expression'];\n          mapping.transition.expression.insertText(expr);\n        } else {\n          mapping.transition.mode = TransitionMode.MANY_TO_ONE;\n          const parsedAction = this.parseAction(firstAction);\n          // TODO: check this non null operator\n          parsedAction.definition =\n            cfg.fieldActionService.getActionDefinitionForName(\n              parsedAction.name,\n              Multiplicity.MANY_TO_ONE\n            )!;\n          mapping.transition.transitionFieldAction = parsedAction;\n        }\n      }\n    }\n  }\n\n  static deserializeAudits(audits: IAudits, errorType: ErrorType): ErrorInfo[] {\n    const errors: ErrorInfo[] = [];\n    if (!audits?.audit) {\n      return errors;\n    }\n    for (const audit of audits.audit) {\n      const msg = audit.status + '[' + audit.path + ']: ' + audit.message;\n      errors.push(\n        new ErrorInfo({\n          message: msg,\n          level: ErrorLevel[audit.status],\n          scope: ErrorScope.MAPPING,\n          type: errorType,\n          object: audit.value,\n        })\n      );\n    }\n    return errors;\n  }\n\n  private static createInputFieldGroup(\n    field: IField[],\n    isComplex: boolean,\n    docId?: string,\n    path?: string\n  ): IFieldGroup {\n    const inputFieldGroup: IFieldGroup = {\n      jsonType: FIELD_GROUP_JSON_TYPE,\n      actions: [],\n      docId: docId,\n      path: path,\n      field,\n    };\n    if (isComplex) {\n      inputFieldGroup.fieldType = FieldType.COMPLEX;\n    }\n    return inputFieldGroup;\n  }\n\n  private static serializeDocuments(\n    docs: DocumentDefinition[],\n    mappingDefinition: MappingDefinition\n  ): IDataSource[] {\n    const serializedDocs: IDataSource[] = [];\n    for (const doc of docs) {\n      let serializedDoc: IDataSource = {\n        jsonType: DATA_SOURCE_JSON_TYPE,\n        id: doc.id,\n        name: doc.name,\n        description: doc.description,\n        uri: doc.uri,\n        dataSourceType: doc.isSource\n          ? DataSourceType.SOURCE\n          : DataSourceType.TARGET,\n      };\n      if (doc.characterEncoding != null) {\n        serializedDoc.characterEncoding = doc.characterEncoding;\n      }\n      if (doc.locale != null) {\n        serializedDoc.locale = doc.locale;\n      }\n      if (doc.type === DocumentType.XML || doc.type === DocumentType.XSD) {\n        const xmlDoc = serializedDoc as IXmlDataSource;\n        xmlDoc.jsonType = XML_DATA_SOURCE_JSON_TYPE;\n        const namespaces: IXmlNamespace[] = [];\n        for (const ns of doc.namespaces) {\n          namespaces.push({\n            alias: ns.alias,\n            uri: ns.uri,\n            locationUri: ns.locationUri,\n            targetNamespace: ns.isTarget,\n          });\n        }\n        if (!doc.isSource && mappingDefinition.templateText) {\n          xmlDoc.template = mappingDefinition.templateText;\n        }\n        xmlDoc.xmlNamespaces = { xmlNamespace: namespaces };\n      } else if (doc.type === DocumentType.JSON) {\n        const jsonDoc = serializedDoc as IJsonDataSource;\n        if (!doc.isSource && mappingDefinition.templateText) {\n          jsonDoc.template = mappingDefinition.templateText;\n        }\n        jsonDoc.jsonType = JSON_DATA_SOURCE_JSON_TYPE;\n      }\n\n      serializedDocs.push(serializedDoc);\n    }\n    return serializedDocs;\n  }\n\n  private static serializeConstants(docDef: DocumentDefinition): IConstant[] {\n    const constantDescriptions: IConstant[] = [];\n    for (const field of docDef.fields) {\n      // Use the constant value for the name.\n      constantDescriptions.push({\n        name: field.name,\n        value: field.value,\n        fieldType: field.type,\n      });\n    }\n    return constantDescriptions;\n  }\n\n  private static serializeProperties(docDef: DocumentDefinition): IProperty[] {\n    const propertyDescriptions: IProperty[] = [];\n    for (const field of docDef.fields) {\n      propertyDescriptions.push({\n        name: field.name,\n        fieldType: field.type,\n        scope: field.scope,\n        dataSourceType: docDef.isSource\n          ? DataSourceType.SOURCE\n          : DataSourceType.TARGET,\n      });\n    }\n    return propertyDescriptions;\n  }\n\n  private static serializeLookupTables(\n    mappingDefinition: MappingDefinition\n  ): ILookupTable[] {\n    const serializedTables: ILookupTable[] = [];\n    const tables = mappingDefinition.getTables();\n    if (!tables || !tables.length) {\n      return serializedTables;\n    }\n\n    for (const table of tables) {\n      const lookupEntries: ILookupEntry[] = [];\n      for (const entry of table.lookupEntry) {\n        const serializedEntry: ILookupEntry = {\n          sourceValue: entry.sourceValue,\n          sourceType: entry.sourceType,\n          targetValue: entry.targetValue,\n          targetType: entry.targetType,\n        };\n        lookupEntries.push(serializedEntry);\n      }\n\n      const serializedTable: ILookupTable = {\n        lookupEntry: lookupEntries,\n        name: table.name,\n      };\n      serializedTables.push(serializedTable);\n    }\n    return serializedTables;\n  }\n\n  /**\n   * Generate serialized meta-data representing a direct-reference instance collection preview.\n   *\n   * @param cfg\n   * @param mapping\n   * @param field\n   * @param serializedField\n   * @param fieldsJson\n   */\n  private static processCollectionPreview(\n    field: Field,\n    serializedField: IField,\n    fieldsJson: IField[]\n  ) {\n    serializedField.path = field.path.replace('<>', '<0>');\n    const collectionInstanceInputFieldGroup =\n      MappingSerializer.createInputFieldGroup(\n        [serializedField],\n        true,\n        field.docDef.id,\n        field.path\n      );\n    fieldsJson.push(collectionInstanceInputFieldGroup);\n  }\n\n  /**\n   * Serialize field action arguments.\n   *\n   * @param action\n   * @param cfg\n   */\n  private static processActionArguments(\n    action: FieldAction,\n    cfg: ConfigModel\n  ): { [key: string]: string } {\n    const actionArguments: { [key: string]: any } = {};\n    if (action === null) {\n      return actionArguments;\n    }\n    for (const argValue of action.argumentValues) {\n      if (\n        action.definition?.isCustom &&\n        ['methodName', 'className', 'name'].includes(argValue.name)\n      ) {\n        continue;\n      }\n      actionArguments[argValue.name] = argValue.value;\n      const argumentConfig: FieldActionArgument =\n        action.definition!.getArgumentForName(argValue.name);\n      if (argumentConfig == null) {\n        cfg.errorService.addError(\n          new ErrorInfo({\n            message: `Cannot find action argument ${argValue.name}: ${argValue.value}`,\n            level: ErrorLevel.ERROR,\n            scope: ErrorScope.APPLICATION,\n            type: ErrorType.INTERNAL,\n            object: action,\n          })\n        );\n        continue;\n      }\n      if (argumentConfig.type === 'INTEGER') {\n        actionArguments[argValue.name] = parseInt(argValue.value, 10);\n      }\n    }\n    return actionArguments;\n  }\n\n  private static serializeFields(\n    mapping: MappingModel,\n    isSource: boolean,\n    cfg: ConfigModel,\n    ignoreValue: boolean = false\n  ): IField[] {\n    let collectionInputFieldGroup = null;\n    let collectionInstanceInputFieldGroup = null;\n    const fields: MappedField[] = mapping.getMappedFields(isSource);\n    const fieldsJson: IField[] = [];\n\n    for (const mappedField of fields) {\n      if (!mappedField.field || mappedField.isPadField()) {\n        continue;\n      }\n\n      const field: Field = mappedField.field;\n      const serializedField: IField = {\n        jsonType: field.documentField.jsonType,\n        name: field.name,\n        path: field.path,\n        fieldType: field.type,\n        docId: field.docDef.id,\n      };\n\n      // The 'attribute' field only applies to XML.\n      if (field.documentField.jsonType?.includes(XML_MODEL_PACKAGE_PREFIX)) {\n        (serializedField as IXmlField).attribute = field.isAttribute;\n      }\n\n      // Only capture a value for preview mode and constants.\n      if (!ignoreValue || field.isConstant()) {\n        if (field.value) {\n          serializedField.value = field.value;\n        } else {\n          serializedField.value = '';\n        }\n      }\n\n      if (\n        field.docDef.type === DocumentType.XML ||\n        field.docDef.type === DocumentType.XSD\n      ) {\n        (serializedField as IXmlField).userCreated = field.userCreated;\n      } else if (\n        field.docDef.type === DocumentType.JAVA &&\n        !field.isPrimitive\n      ) {\n        (serializedField as IJavaField).className = field.classIdentifier;\n      }\n\n      if (field.isProperty()) {\n        serializedField.jsonType = PROPERTY_FIELD_JSON_TYPE;\n        serializedField.name = field.name;\n        (serializedField as IPropertyField).scope = field.scope;\n        serializedField.path = cfg.documentService.getPropertyPath(\n          field.scope,\n          field.name\n        );\n      } else if (field.isConstant()) {\n        serializedField.jsonType = CONSTANT_FIELD_JSON_TYPE;\n        serializedField.name = field.name;\n      } else if (field.enumeration) {\n        if (field.docDef.type === DocumentType.JSON) {\n          serializedField.jsonType = JSON_ENUM_FIELD_JSON_TYPE;\n        } else if (\n          field.docDef.type === DocumentType.XML ||\n          field.docDef.type === DocumentType.XSD\n        ) {\n          serializedField.jsonType = XML_ENUM_FIELD_JSON_TYPE;\n        } else {\n          serializedField.jsonType = JAVA_ENUM_FIELD_JSON_TYPE;\n        }\n      }\n\n      let includeIndexes: boolean =\n        mapping.getMappedFields(isSource).length > 1;\n      includeIndexes =\n        includeIndexes || (mapping.transition.isExpressionMode() && isSource);\n      if (includeIndexes) {\n        // TODO: check this non null operator\n        serializedField.index =\n          mapping.getIndexForMappedField(mappedField)! - 1;\n      }\n      if (field.docDef.type === DocumentType.CSV) {\n        (serializedField as ICsvField).column = field.column;\n      }\n\n      this.serializeActions(cfg, mappedField, serializedField);\n\n      // Check for collection field references.\n      if (isSource && field.isInCollection()) {\n        const collectionParentField = field.getCollectionParentField();\n\n        if (\n          !mapping.referenceFieldExists(\n            collectionParentField.docDef.id,\n            collectionParentField.path\n          )\n        ) {\n          if (!ignoreValue) {\n            MappingSerializer.processCollectionPreview(\n              field,\n              serializedField,\n              fieldsJson\n            );\n          } else {\n            fieldsJson.push(serializedField);\n            collectionInputFieldGroup = null;\n          }\n        } else {\n          // Establish/add to the inner reference field group.\n          if (collectionInstanceInputFieldGroup === null) {\n            collectionInstanceInputFieldGroup =\n              MappingSerializer.createInputFieldGroup(\n                [serializedField],\n                true,\n                collectionParentField.docDef.id,\n                collectionParentField.path\n              );\n          } else {\n            (collectionInstanceInputFieldGroup as IFieldGroup)!.field!.push(\n              serializedField\n            );\n            continue;\n          }\n          collectionInstanceInputFieldGroup.fieldType =\n            collectionParentField.documentField.fieldType;\n\n          // Preview-mode uses element/ item instance <0>.\n          if (!ignoreValue) {\n            collectionInstanceInputFieldGroup.path =\n              collectionParentField.path.replace('<>', '<0>');\n\n            // Establish one outer input field group for the preview collection.\n            if (collectionInputFieldGroup === null) {\n              collectionInputFieldGroup =\n                MappingSerializer.createInputFieldGroup(\n                  [collectionInstanceInputFieldGroup],\n                  true,\n                  collectionParentField.docDef.id,\n                  collectionParentField.path\n                );\n              collectionInstanceInputFieldGroup.fieldType =\n                collectionParentField.documentField.fieldType;\n              fieldsJson.push(collectionInputFieldGroup);\n            }\n          } else {\n            fieldsJson.push(collectionInstanceInputFieldGroup);\n          }\n        }\n\n        // Non-aggregate field reference.\n      } else {\n        fieldsJson.push(serializedField);\n        collectionInputFieldGroup = null;\n      }\n    }\n    return fieldsJson;\n  }\n\n  /**\n   * Walk the list of actions associated with the specified mapped field and serialize them into JSON.\n   *\n   * @param cfg\n   * @param mappedField\n   * @param serializedField\n   */\n  private static serializeActions(\n    cfg: ConfigModel,\n    mappedField: MappedField,\n    serializedField: IField\n  ): void {\n    if (mappedField.actions.length) {\n      const actions: IFieldAction[] = [];\n\n      for (const action of mappedField.actions) {\n        const actionJson = this.serializeAction(action, cfg);\n        if (actionJson) {\n          actions.push(actionJson);\n        }\n      }\n      if (actions.length > 0) {\n        serializedField.actions = actions;\n      }\n    }\n  }\n\n  private static serializeAction(\n    action: FieldAction,\n    cfg: ConfigModel\n  ): { [key: string]: any } {\n    let actionJson = MappingSerializer.processActionArguments(action, cfg);\n    actionJson['@type'] = action.definition!.name;\n    return actionJson;\n  }\n\n  private static deserializeDocs(\n    json: IAtlasMappingContainer,\n    mappingDefinition: MappingDefinition\n  ): DocumentDefinition[] | null {\n    const docs: DocumentDefinition[] = [];\n    if (!json || !json.AtlasMapping || !json.AtlasMapping.dataSource) {\n      return null;\n    }\n    for (const docRef of json.AtlasMapping.dataSource) {\n      const doc: DocumentDefinition = new DocumentDefinition();\n      doc.isSource = docRef.dataSourceType === 'SOURCE';\n      doc.uri = docRef.uri;\n      doc.id = docRef.id;\n      doc.name = docRef.name ? docRef.name : '';\n      doc.description = docRef.description;\n      const xmlDocRef = docRef as IXmlDataSource;\n      if (xmlDocRef.xmlNamespaces && xmlDocRef.xmlNamespaces.xmlNamespace) {\n        for (const svcNS of xmlDocRef.xmlNamespaces.xmlNamespace) {\n          const ns: NamespaceModel = new NamespaceModel();\n          ns.alias = svcNS.alias;\n          ns.uri = svcNS.uri;\n          ns.locationUri = svcNS.locationUri;\n          ns.isTarget = svcNS.targetNamespace ? svcNS.targetNamespace : false;\n          ns.createdByUser = true;\n          doc.namespaces.push(ns);\n        }\n      }\n      if (xmlDocRef.template) {\n        mappingDefinition.templateText = xmlDocRef.template;\n      }\n      docs.push(doc);\n    }\n    return docs;\n  }\n\n  private static deserializeMappings(\n    json: IAtlasMappingContainer,\n    cfg: ConfigModel\n  ): MappingModel[] {\n    const mappings: MappingModel[] = [];\n\n    if (!json.AtlasMapping.mappings?.mapping) {\n      return mappings;\n    }\n    for (const fieldMapping of json.AtlasMapping.mappings.mapping) {\n      // for backward compatibility\n      const isCollectionMapping =\n        fieldMapping.jsonType === COLLECTION_JSON_TYPE;\n      if (isCollectionMapping) {\n        const collection = fieldMapping as ICollection;\n        for (const innerFieldMapping of collection.mappings.mapping) {\n          mappings.push(\n            MappingSerializer.deserializeFieldMapping(\n              innerFieldMapping as IMapping,\n              cfg\n            )\n          );\n        }\n      } else {\n        mappings.push(\n          MappingSerializer.deserializeFieldMapping(\n            fieldMapping as IMapping,\n            cfg\n          )\n        );\n      }\n    }\n    return mappings;\n  }\n\n  /**\n   * @deprecated Deserialize a field mapping based on its mapping type.  This is deprecated in favor of\n   * concatenate/ split actions.\n   *\n   * @param mapping\n   * @param fieldMapping\n   * @param docRefs\n   * @param cfg\n   * @param ignoreValue\n   */\n  private static deserializeFieldMappingFromType(\n    mapping: MappingModel,\n    fieldMapping: IMapping,\n    cfg: ConfigModel\n  ): void {\n    if (fieldMapping.mappingType === 'SEPARATE') {\n      mapping.transition.mode = TransitionMode.ONE_TO_MANY;\n      mapping.transition.transitionFieldAction = FieldAction.create(\n        cfg.fieldActionService.getActionDefinitionForName(\n          'Split',\n          Multiplicity.ONE_TO_MANY\n        )!\n      ); // TODO: check this non null operator\n      mapping.transition.transitionFieldAction.setArgumentValue(\n        'delimiter',\n        fieldMapping.delimiter!\n      );\n    } else if (fieldMapping.mappingType === 'LOOKUP') {\n      mapping.transition.mode = TransitionMode.ENUM;\n      mapping.transition.lookupTableName = fieldMapping.lookupTableName!;\n    } else if (fieldMapping.mappingType === 'COMBINE') {\n      mapping.transition.mode = TransitionMode.MANY_TO_ONE;\n      mapping.transition.transitionFieldAction = FieldAction.create(\n        cfg.fieldActionService.getActionDefinitionForName(\n          'Concatenate',\n          Multiplicity.MANY_TO_ONE\n        )!\n      ); // TODO: check this non null operator\n      mapping.transition.transitionFieldAction.setArgumentValue(\n        'delimiter',\n        fieldMapping.delimiter!\n      );\n    } else {\n      mapping.transition.mode = TransitionMode.ONE_TO_ONE;\n    }\n\n    for (const field of fieldMapping.inputField!) {\n      MappingSerializer.deserializeMappedField(mapping, field, true, cfg);\n    }\n    for (const field of fieldMapping.outputField) {\n      MappingSerializer.deserializeMappedField(mapping, field, false, cfg);\n    }\n    MappingUtil.updateMappedFieldsFromDocuments(mapping, cfg, true);\n  }\n\n  private static deserializeConstants(\n    jsonMapping: IAtlasMappingContainer\n  ): Field[] {\n    const fields: Field[] = [];\n    if (!jsonMapping?.AtlasMapping?.constants?.constant) {\n      return fields;\n    }\n    for (const constant of jsonMapping.AtlasMapping.constants.constant) {\n      const field: Field = new Field();\n      field.name = constant.name;\n      field.path = FIELD_PATH_SEPARATOR + field.name;\n      field.value = constant.value;\n      field.type = constant.fieldType;\n      field.userCreated = true;\n      field.isAttribute = false;\n      fields.push(field);\n    }\n    return fields;\n  }\n\n  private static deserializeProperties(\n    cfg: ConfigModel,\n    jsonMapping: IAtlasMappingContainer,\n    isSource: boolean\n  ): Field[] {\n    const fields: Field[] = [];\n    if (!jsonMapping?.AtlasMapping?.properties?.property) {\n      return fields;\n    }\n\n    // Source and target properties are mixed in the 'property' JSON array.\n    for (const property of jsonMapping.AtlasMapping.properties.property) {\n      if (\n        (isSource && property.dataSourceType === DataSourceType.TARGET) ||\n        (!isSource && property.dataSourceType !== DataSourceType.TARGET)\n      ) {\n        continue;\n      }\n      const field: Field = new Field();\n      field.name = property.name;\n      field.type = property.fieldType;\n      field.scope = property.scope;\n      field.path = cfg.documentService.getPropertyPath(field.scope, field.name);\n      field.userCreated = true;\n      field.isAttribute = false;\n      fields.push(field);\n    }\n    return fields;\n  }\n\n  private static deserializeLookupTables(\n    jsonMapping: IAtlasMappingContainer\n  ): LookupTable[] {\n    const tables: LookupTable[] = [];\n    if (\n      !jsonMapping ||\n      !jsonMapping.AtlasMapping ||\n      !jsonMapping.AtlasMapping.lookupTables ||\n      !jsonMapping.AtlasMapping.lookupTables.lookupTable\n    ) {\n      return tables;\n    }\n    for (const table of jsonMapping.AtlasMapping.lookupTables.lookupTable) {\n      const parsedTable: LookupTable = new LookupTable();\n      parsedTable.name = table.name;\n      for (const entry of table.lookupEntry) {\n        const parsedEntry: LookupTableEntry = new LookupTableEntry();\n        parsedEntry.sourceValue = entry.sourceValue;\n        parsedEntry.sourceType = entry.sourceType;\n        parsedEntry.targetValue = entry.targetValue;\n        parsedEntry.targetType = entry.targetType;\n        parsedTable.lookupEntry.push(parsedEntry);\n      }\n      tables.push(parsedTable);\n    }\n    return tables;\n  }\n\n  /**\n   * Walk the list of field actions found in the parsed data and restore them to the live mapping.\n   *\n   * @param field\n   * @param mappedField\n   * @param mapping\n   * @param cfg\n   * @param isSource\n   */\n  private static deserializeFieldActions(\n    field: IField,\n    mappedField: MappedField,\n    mapping: MappingModel,\n    cfg: ConfigModel,\n    isSource: boolean\n  ): void {\n    if (!field.actions) {\n      return;\n    }\n\n    for (const action of field.actions) {\n      const parsedAction = this.parseAction(action);\n      if (action.name === 'CustomAction') {\n        parsedAction.definition =\n          cfg.fieldActionService.getActionDefinitionForName(\n            action.argumentValues[0].value,\n            Multiplicity.ONE_TO_ONE\n          );\n      } else {\n        parsedAction.definition =\n          cfg.fieldActionService.getActionDefinitionForName(parsedAction.name)!;\n      }\n      if (parsedAction.definition == null) {\n        cfg.errorService.addError(\n          new ErrorInfo({\n            message: `Could not find field action definition for action '${action.name}'`,\n            level: ErrorLevel.ERROR,\n            scope: ErrorScope.APPLICATION,\n            type: ErrorType.INTERNAL,\n          })\n        );\n        continue;\n      }\n      parsedAction.definition.populateFieldAction(parsedAction);\n\n      /** @deprecated Support old-style transformation-action-based expressions. */\n      if (isSource && (action.Expression || action['@type'] === 'Expression')) {\n        mapping.transition.enableExpression = true;\n        mapping.transition.expression = new ExpressionModel(mapping, cfg);\n        const expr = action.Expression\n          ? action.Expression.expression\n          : action['expression'];\n        mapping.transition.expression.insertText(expr);\n      } else if (\n        isSource &&\n        parsedAction.definition &&\n        [Multiplicity.ONE_TO_MANY, Multiplicity.MANY_TO_ONE].includes(\n          parsedAction.definition.multiplicity\n        )\n      ) {\n        if (mapping.transition.transitionFieldAction) {\n          cfg.logger!\n            .warn(`Duplicated multiplicity transformations were detected: \\\n              ${mapping.transition.transitionFieldAction.name} is being overwritten by ${parsedAction.name} ...`);\n        }\n        mapping.transition.transitionFieldAction = parsedAction;\n      } else {\n        mappedField.actions.push(parsedAction);\n      }\n    }\n  }\n\n  private static deserializeMappedField(\n    mapping: MappingModel,\n    field: IField,\n    isSource: boolean,\n    cfg: ConfigModel\n  ): MappedField | null {\n    if (MappingUtil.isConstantField(field)) {\n      if (field.docId) {\n        cfg.constantDoc.id = field.docId;\n      } else {\n        field.docId = cfg.constantDoc.id;\n      }\n    } else if (MappingUtil.isPropertyField(field)) {\n      const doc = isSource ? cfg.sourcePropertyDoc : cfg.targetPropertyDoc;\n      if (field.docId) {\n        doc.id = field.docId;\n      } else {\n        field.docId = doc.id;\n      }\n      field.path = cfg.documentService.getPropertyPath(\n        (field as IPropertyField).scope,\n        field.name!\n      );\n    } else if (!field.docId) {\n      cfg.errorService.addError(\n        new ErrorInfo({\n          message: 'Parsed mapping field does not have document id, dropping.',\n          level: ErrorLevel.ERROR,\n          scope: ErrorScope.APPLICATION,\n          type: ErrorType.INTERNAL,\n          object: field,\n        })\n      );\n      return null;\n    }\n    const mappedField: MappedField = new MappedField();\n    mappedField.mappingField = field;\n    mapping.addMappedField(mappedField, isSource);\n    if (field.actions) {\n      this.deserializeFieldActions(field, mappedField, mapping, cfg, isSource);\n    }\n    return mappedField;\n  }\n\n  private static parseAction(action: IFieldAction): FieldAction {\n    if (action['@type']) {\n      return MappingSerializer.parseNewAction(action);\n    } else {\n      // TODO: check this non null operator\n      return MappingSerializer.parseOldAction(action)!;\n    }\n  }\n\n  /**\n   * @deprecated actionName: {param:...} style has been deprecated. Use {`@type`: actionName} style action description.\n   */\n  private static parseOldAction(action: IFieldAction): FieldAction | null {\n    for (const actionName of Object.keys(action)) {\n      if (!action.hasOwnProperty(actionName)) {\n        return null;\n      }\n      const parsedAction: FieldAction = new FieldAction();\n      parsedAction.name = actionName;\n      const actionParams: any = action[actionName];\n      if (actionParams) {\n        for (const paramName of Object.keys(actionParams)) {\n          if (!actionParams.hasOwnProperty(paramName)) {\n            return null;\n          }\n          const parsedArgumentValue: FieldActionArgumentValue =\n            new FieldActionArgumentValue();\n          parsedArgumentValue.name = paramName;\n          let value = actionParams[paramName];\n          value = value == null ? null : value.toString();\n          parsedArgumentValue.value = value;\n          parsedAction.argumentValues.push(parsedArgumentValue);\n        }\n      }\n      return parsedAction;\n    }\n    return null;\n  }\n\n  private static parseNewAction(action: IFieldAction): FieldAction {\n    const parsedAction: FieldAction = new FieldAction();\n    parsedAction.name = action['@type']!;\n    for (const [key, value] of Object.entries(action)) {\n      if ('@type' === key) {\n        continue;\n      }\n      const parsedArgumentValue: FieldActionArgumentValue =\n        new FieldActionArgumentValue();\n      parsedArgumentValue.name = key;\n      const valueString = value == null ? null : (value as any).toString();\n      parsedArgumentValue.value = valueString;\n      parsedAction.argumentValues.push(parsedArgumentValue);\n    }\n    return parsedAction;\n  }\n}\n","/*\n    Copyright (C) 2017 Red Hat, Inc.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n            http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n*/\nimport {\n  CollectionType,\n  DocumentType,\n  FIELD_PATH_SEPARATOR,\n  FieldType,\n  InspectionType,\n} from '../contracts/common';\nimport {\n  ErrorInfo,\n  ErrorLevel,\n  ErrorScope,\n  ErrorType,\n} from '../models/error.model';\nimport {\n  HTTP_STATUS_NO_CONTENT,\n  constantTypes,\n  propertyTypes,\n} from '../common/config.types';\nimport { Observable, Subscription } from 'rxjs';\n\nimport { CommonUtil } from '../utils/common-util';\nimport { ConfigModel } from '../models/config.model';\nimport { DocumentDefinition } from '../models/document-definition.model';\nimport { DocumentInspectionModel } from '../models/inspect/document-inspection.model';\nimport { DocumentInspectionUtil } from '../utils/document-inspection-util';\nimport { Field } from '../models/field.model';\nimport { Guid } from '../utils';\nimport ky from 'ky';\n\n/**\n * Manages Document object lifecycle. Import a Document source\n * such as JSON/XML schema/instance, request an inspection to the backend,\n * then enable it for mapping by consuming inspection result in UI.\n */\nexport class DocumentManagementService {\n  cfg!: ConfigModel;\n\n  private mappingUpdatedSubscription!: Subscription;\n  private MAX_SEARCH_MATCH = 10000;\n\n  constructor(private api: typeof ky) {}\n\n  initialize(): void {\n    this.mappingUpdatedSubscription =\n      this.cfg.mappingService.mappingUpdated$.subscribe(() => {\n        for (const d of this.cfg.getAllDocs()) {\n          if (d.initialized) {\n            d.updateFromMappings(this.cfg.mappings!); // TODO: check this non null operator\n          }\n        }\n      });\n  }\n\n  uninitialize(): void {\n    this.mappingUpdatedSubscription.unsubscribe();\n  }\n\n  /**\n   * Request Document inspection for each {@link DocumentDefinition} object\n   * stored in {@link ConfigModel} and populate it back with the inspection result.\n   *\n   * @returns\n   */\n  inspectDocuments(): Observable<DocumentDefinition> {\n    return new Observable<DocumentDefinition>((observer) => {\n      for (const docDef of this.cfg.getAllDocs()) {\n        if (\n          docDef === this.cfg.sourcePropertyDoc ||\n          docDef === this.cfg.targetPropertyDoc ||\n          docDef === this.cfg.constantDoc\n        ) {\n          docDef.initialized = true;\n          continue;\n        }\n\n        const inspectionModel = DocumentInspectionUtil.fromDocumentDefinition(\n          this.cfg,\n          docDef\n        );\n\n        // TODO: check this non null operator\n        this.inspectDocument(inspectionModel)\n          .then(() => {\n            observer.next(docDef);\n          })\n          .catch((error: any) => {\n            observer.error(error);\n          });\n      }\n    });\n  }\n\n  private inspectDocument(\n    inspectionModel: DocumentInspectionModel\n  ): Promise<DocumentDefinition> {\n    return new Promise<DocumentDefinition>((resolve, reject) => {\n      const docDef = inspectionModel.doc;\n      if (docDef.inspectionResult) {\n        const responseJson: any = JSON.parse(docDef.inspectionResult);\n        inspectionModel.parseResponse(responseJson);\n        docDef.initializeFromFields();\n        docDef.initialized = true;\n        resolve(docDef);\n        return;\n      }\n\n      if (!inspectionModel.isOnlineInspectionCapable()) {\n        docDef.initialized = true;\n        docDef.errorOccurred = true;\n        reject(docDef);\n        return;\n      }\n\n      const request = inspectionModel.request;\n      this.cfg.logger!.debug(\n        `Document Inspection Request: ${JSON.stringify(request.options.json)}`\n      );\n      this.api\n        .post(request.url, request.options)\n        .json()\n        .then((responseJson: any) => {\n          this.cfg.logger!.debug(\n            `Document Inspection Response: ${JSON.stringify(responseJson)}`\n          );\n          inspectionModel.parseResponse(responseJson);\n          docDef.initializeFromFields();\n          docDef.initialized = true;\n          resolve(docDef);\n        })\n        .catch((error: any) => {\n          this.cfg.errorService.addBackendError(\n            `Failed to inspect Document: ${docDef.name}(${docDef.id})`,\n            error\n          );\n          reject(error);\n        });\n    });\n  }\n\n  getLibraryClassNames(): Promise<string[]> {\n    return new Promise<string[]>((resolve, reject) => {\n      if (typeof this.cfg.initCfg.baseMappingServiceUrl === 'undefined') {\n        resolve([]);\n        return;\n      }\n      const url: string =\n        this.cfg.initCfg.baseMappingServiceUrl + 'library/list';\n      this.cfg.logger!.debug('Library Class List Service Request: ' + url);\n      this.api\n        .get(url)\n        .json()\n        .then((body: any) => {\n          this.cfg.logger!.debug(\n            `Library Class List Service Response: ${JSON.stringify(body)}`\n          );\n          const classNames: string[] = body.ArrayList;\n          resolve(classNames);\n        })\n        .catch((error: any) => {\n          if (error.status !== HTTP_STATUS_NO_CONTENT) {\n            this.cfg.errorService.addBackendError(\n              'Error occurred while accessing the user uploaded JARs from the runtime service.',\n              error\n            );\n            reject(error);\n          } else {\n            resolve([]);\n          }\n        });\n    });\n  }\n\n  /**\n   * Import user uploaded Document source such as JSON/XML schema/instance, assign\n   * a unique Document ID with using GUID and delegate to {@link addNonJavaDocument}\n   * to make it available  as a Document for mappings.\n   * @see addNonJavaDocument\n   *\n   * @param selectedFile - user selected file\n   * @param isSource - true is source panel, false is target\n   * @param isSchema- user specified instance/ schema (true === schema)\n   * @param inspectionParameters - CSV parameters\n   *\n   */\n  importNonJavaDocument(\n    selectedFile: File,\n    isSource: boolean,\n    isSchema: boolean,\n    inspectionParameters?: { [key: string]: string }\n  ): Promise<boolean> {\n    return new Promise<boolean>(async (resolve) => {\n      let fileText = '';\n      const reader = new FileReader();\n\n      this.cfg.errorService.clearValidationErrors();\n\n      const userFileComps = selectedFile.name.split('.');\n      const userFile = userFileComps.slice(0, -1).join('.');\n      const userFileSuffix: string =\n        userFileComps[userFileComps.length - 1].toUpperCase();\n\n      // Wait for the async read of the selected ascii document to be completed.\n      try {\n        fileText = await CommonUtil.readFile(selectedFile, reader);\n      } catch (error) {\n        this.cfg.errorService.addError(\n          new ErrorInfo({\n            message: 'Unable to import the specified schema document.',\n            level: ErrorLevel.ERROR,\n            scope: ErrorScope.APPLICATION,\n            type: ErrorType.USER,\n            object: error,\n          })\n        );\n        resolve(false);\n        return;\n      }\n\n      let docType = undefined;\n      try {\n        docType = userFileSuffix as DocumentType;\n        if (!docType) {\n          throw new Error(docType);\n        }\n      } catch (error) {\n        this.handleError(\n          'Unrecognized document suffix (' + userFileSuffix + ')'\n        );\n        resolve(false);\n        return;\n      }\n      this.addNonJavaDocument(\n        fileText,\n        userFile + '-' + Guid.newGuid(),\n        userFile,\n        docType,\n        isSchema ? InspectionType.SCHEMA : InspectionType.INSTANCE,\n        isSource,\n        inspectionParameters\n      ).then((value) => {\n        if (!value) {\n          resolve(false);\n          return;\n        }\n        this.cfg.errorService.addError(\n          new ErrorInfo({\n            message: `${selectedFile.name} ${userFileSuffix} import complete.`,\n            level: ErrorLevel.INFO,\n            scope: ErrorScope.APPLICATION,\n            type: ErrorType.USER,\n          })\n        );\n        resolve(true);\n      });\n    });\n  }\n\n  /**\n   * Import a Java class as a Document source and delegate to {@link addJavaDocument}\n   * to make it available  as a Document for mappings.\n   * JAR file(s) have to be imported and be available in the backend classpath\n   * before doing this.\n   * @see addJavaDocument\n   * @todo https://github.com/atlasmap/atlasmap/issues/2919\n   * A unique Document ID should be assigned with using GUID.\n   *\n   * @param className\n   * @param isSource\n   * @param collectionType\n   * @param collectionClassName\n   */\n  importJavaDocument(\n    className: string,\n    isSource: boolean,\n    collectionType = CollectionType.NONE,\n    collectionClassName?: string\n  ): Promise<boolean> {\n    this.cfg.errorService.clearValidationErrors();\n    return this.addJavaDocument(\n      className,\n      isSource,\n      collectionType,\n      collectionClassName\n    );\n  }\n  /**\n   * Add non-Java Document object into the {@link ConfigModel} store and\n   * delegate to {@link doAddDocument}.\n   * @see doAddDocument\n   *\n   * @param docBody\n   * @param docId\n   * @param docName\n   * @param docType\n   * @param inspectionType\n   * @param isSource\n   * @param parameters\n   */\n  addNonJavaDocument(\n    docBody: any,\n    docId: string,\n    docName: string,\n    docType: DocumentType,\n    inspectionType: InspectionType,\n    isSource: boolean,\n    parameters?: { [key: string]: string }\n  ): Promise<boolean> {\n    const inspectionModel = DocumentInspectionUtil.fromNonJavaProperties(\n      this.cfg,\n      docId,\n      docName,\n      docType,\n      inspectionType,\n      docBody,\n      isSource,\n      parameters\n    );\n    return this.doAddDocument(inspectionModel);\n  }\n\n  /**\n   * Add Java Document object into the {@link ConfigModel} store and\n   * delegate to {@link doAddDocument}.\n   * @see doAddDocument\n   *\n   * @param className\n   * @param isSource\n   * @param collectionType {@link CollectionType}\n   * @param collectionClassName\n   */\n  addJavaDocument(\n    className: string,\n    isSource: boolean,\n    collectionType: CollectionType = CollectionType.NONE,\n    collectionClassName?: string\n  ): Promise<boolean> {\n    const inspectionModel = DocumentInspectionUtil.fromJavaProperties(\n      this.cfg,\n      className,\n      isSource,\n      collectionType,\n      collectionClassName\n    );\n    return this.doAddDocument(inspectionModel);\n  }\n\n  /**\n   * An utility method to look at the {@link DocumentType} passed in as an argument\n   * and see if it's a Java or non-Java Document, then delegate to\n   * {@link addJavaDocument} or {@link addNonJavaDocument}.\n   *\n   * @todo https://github.com/atlasmap/atlasmap/issues/2918\n   * {@link CollectionType} and collectionClassName has to be persisted into digest\n   * so it could be restored here\n   */\n  addDocument(\n    docBody: any,\n    docId: string,\n    docName: string,\n    docType: DocumentType,\n    inspectionType: InspectionType,\n    isSource: boolean,\n    parameters?: { [key: string]: string }\n  ): Promise<boolean> {\n    if (docType === DocumentType.JAVA) {\n      return this.addJavaDocument(docId, isSource);\n    }\n    return this.addNonJavaDocument(\n      docBody,\n      docId,\n      docName,\n      docType,\n      inspectionType,\n      isSource,\n      parameters\n    );\n  }\n\n  /**\n   * Add or replace the {@link DocumentDefinition} object stored in {@link ConfigModel}\n   * and delegate to {@link inspectDocument} to perform an inspection.\n   * Then it gets available for mapping in the canvas.\n   *\n   * @param inspectionModel {@link DocumentInspectionModel}\n   * @returns\n   */\n  private doAddDocument(\n    inspectionModel: DocumentInspectionModel\n  ): Promise<boolean> {\n    return new Promise<boolean>(async (resolve) => {\n      let docdef = inspectionModel.doc;\n      const isSource = docdef.isSource;\n\n      this.inspectDocument(inspectionModel)\n        .then(async (doc: DocumentDefinition) => {\n          if (doc.fields.length === 0) {\n            if (isSource) {\n              CommonUtil.removeItemFromArray(docdef, this.cfg.sourceDocs);\n            } else {\n              CommonUtil.removeItemFromArray(docdef, this.cfg.targetDocs);\n            }\n          }\n          docdef.updateFromMappings(this.cfg.mappings!);\n          resolve(true);\n        })\n        .catch(() => {\n          resolve(false);\n        });\n    });\n  }\n\n  private handleError(message: string, error?: any): void {\n    this.cfg.errorService.addError(\n      new ErrorInfo({\n        message: message,\n        level: ErrorLevel.ERROR,\n        scope: ErrorScope.APPLICATION,\n        type: ErrorType.INTERNAL,\n        object: error,\n      })\n    );\n  }\n\n  /**\n   * Filter Document fields that is shwon in a Source/Target Document tree.\n   * @todo Consolidate with expression field search and Document Details field\n   * search - https://github.com/atlasmap/atlasmap/issues/603\n   * @param searchFilter\n   * @param isSource\n   */\n  filterDocumentFields(searchFilter: string | undefined, isSource: boolean) {\n    const cfg = ConfigModel.getConfig();\n\n    let searchResultsExist = false;\n    const searchIsEmpty: boolean =\n      undefined === searchFilter || '' === searchFilter;\n    const defaultVisibility: boolean = searchIsEmpty;\n    for (const docDef of cfg.getDocs(isSource)) {\n      docDef.visibleInCurrentDocumentSearch = defaultVisibility;\n      for (const field of docDef.getAllFields()) {\n        field.visibleInCurrentDocumentSearch = defaultVisibility;\n      }\n      if (!searchIsEmpty) {\n        let searchFieldCount = 0;\n        for (const field of docDef.getAllFields()) {\n          // Skip this field if it's already determined to be visible.\n          if (field.visibleInCurrentDocumentSearch && !field.collapsed) {\n            continue;\n          }\n          field.visibleInCurrentDocumentSearch = field.name\n            .toLowerCase()\n            .includes(searchFilter!.toLowerCase());\n          searchResultsExist =\n            searchResultsExist || field.visibleInCurrentDocumentSearch;\n\n          // The current field matches the user-specified filter.\n          if (field.visibleInCurrentDocumentSearch) {\n            docDef.visibleInCurrentDocumentSearch = true;\n            let parentField = field.parentField;\n\n            // Direct lineage is then visible.\n            while (\n              parentField != null &&\n              !parentField.visibleInCurrentDocumentSearch\n            ) {\n              parentField.visibleInCurrentDocumentSearch = true;\n              parentField.collapsed = false;\n              parentField = parentField.parentField;\n              searchFieldCount++;\n            }\n\n            // All fields below the matching field are also visible.\n            try {\n              this.markChildrenVisible(field);\n            } catch (error) {\n              cfg.errorService.addError(\n                new ErrorInfo({\n                  message: error.message,\n                  level: ErrorLevel.INFO,\n                  scope: ErrorScope.APPLICATION,\n                  type: ErrorType.USER,\n                })\n              );\n              break;\n            }\n\n            // The total number of matches is limited to allow the UI to perform.\n            if (searchFieldCount++ >= this.MAX_SEARCH_MATCH) {\n              cfg.errorService.addError(\n                new ErrorInfo({\n                  message:\n                    'The maximum number of fields matching the specified search filter has beeen exceeded  ' +\n                    'Try using a longer field filter.',\n                  level: ErrorLevel.INFO,\n                  scope: ErrorScope.APPLICATION,\n                  type: ErrorType.USER,\n                })\n              );\n              break;\n            }\n          }\n        }\n      }\n    }\n    cfg.mappingService.notifyLineRefresh();\n  }\n\n  private markChildrenVisible(field: Field): void {\n    field.visibleInCurrentDocumentSearch = true;\n    field.collapsed = false;\n    // if (this.searchFieldCount++ >= this.maxSearchMatch) {\n    //   throw new Error('The maximum number of fields matching the specified search filter has beeen exceeded  ' +\n    //     'Try using a longer field filter.');\n    // }\n    for (const childField of field.children) {\n      this.markChildrenVisible(childField);\n    }\n  }\n\n  /**\n   * Create a constant field.\n   * @param constName\n   * @param constValue\n   * @param constType\n   * @param addToActiveMapping\n   */\n  createConstant(\n    constName: string,\n    constValue: string,\n    constType: string,\n    addToActiveMapping?: boolean\n  ): void {\n    let field = this.cfg.constantDoc.getField(FIELD_PATH_SEPARATOR + constName);\n    if (!field) {\n      field = new Field();\n    }\n    field.name = constName;\n    field.path = FIELD_PATH_SEPARATOR + constName;\n    field.value = constValue;\n    field.type = FieldType[constType as keyof typeof FieldType];\n    field.docDef = this.cfg.constantDoc;\n    field.userCreated = true;\n    this.cfg.constantDoc.addField(field);\n    if (addToActiveMapping) {\n      this.cfg.mappingService.addFieldToActiveMapping(field);\n    }\n    this.cfg.mappingService.notifyMappingUpdated();\n  }\n\n  /**\n   * Delete a constant field.\n   * @param constName\n   */\n  deleteConstant(constName: string): void {\n    const field = this.cfg.constantDoc.getField(\n      FIELD_PATH_SEPARATOR + constName\n    );\n    if (!field) {\n      return;\n    }\n    this.cfg.mappingService.removeFieldFromAllMappings(field);\n    this.cfg.constantDoc.removeField(field);\n    const activeMapping = this.cfg.mappings?.activeMapping;\n    const expression = activeMapping?.transition?.expression;\n    if (activeMapping && expression) {\n      expression.updateFieldReference(activeMapping);\n    }\n    this.cfg.mappingService.notifyMappingUpdated();\n  }\n\n  /**\n   * Edit a constant field. Look for an existing constant field with the specified name\n   * and update the properties. If {@link origName} is specified and different from\n   * {@link constName}, the name of the constant field will be changed.\n   * @param constName\n   * @param constValue\n   * @param constType\n   * @param origName\n   */\n  editConstant(\n    constName: string,\n    constValue: string,\n    constType: string,\n    origName?: string\n  ): void {\n    let constFieldName = origName ? origName : constName;\n    let field = this.cfg.constantDoc.getField(\n      FIELD_PATH_SEPARATOR + constFieldName\n    );\n    if (!field) {\n      return;\n    }\n    if (constType.length > 0) {\n      field.type = FieldType[constType as keyof typeof FieldType];\n    }\n    if (constValue.length > 0) {\n      field.value = constValue;\n    }\n    if (origName && origName !== constName) {\n      field.name = constName;\n      field.path = FIELD_PATH_SEPARATOR + constName;\n      this.cfg.constantDoc.updateField(field, FIELD_PATH_SEPARATOR + constName);\n    }\n    this.cfg.mappingService.notifyMappingUpdated();\n  }\n\n  /**\n   * Get a {@link FieldType} of the constant field.\n   * @param constName\n   */\n  getConstantType(constName: string): FieldType {\n    const cfg = ConfigModel.getConfig();\n    const field = cfg.constantDoc.getField(FIELD_PATH_SEPARATOR + constName);\n    if (!field) {\n      return FieldType.NONE;\n    }\n    return field.type;\n  }\n\n  /**\n   * Get an index of the constant field type.\n   * @param constName\n   */\n  getConstantTypeIndex(constName: string): number {\n    const cfg = ConfigModel.getConfig();\n    const field = cfg.constantDoc.getField(FIELD_PATH_SEPARATOR + constName);\n    if (!field) {\n      return 0;\n    }\n    for (let i = 0; i < constantTypes.length; i++) {\n      if (constantTypes[i].includes(field.type)) {\n        return i;\n      }\n    }\n    return 0;\n  }\n\n  /**\n   * Create a property field.\n   * @param propName\n   * @param propType\n   * @param propScope\n   * @param isSource\n   * @param addToActiveMapping\n   */\n  createProperty(\n    propName: string,\n    propType: string,\n    propScope: string,\n    isSource: boolean,\n    addToActiveMapping?: boolean\n  ): void {\n    const cfg = ConfigModel.getConfig();\n    const path = this.getPropertyPath(propScope, propName);\n    let field = isSource\n      ? cfg.sourcePropertyDoc.getField(path)\n      : cfg.targetPropertyDoc.getField(path);\n    if (!field) {\n      field = new Field();\n    }\n    field.name = propName;\n    field.type = FieldType[propType as keyof typeof FieldType];\n    field.scope = propScope;\n    field.path = path;\n    field.userCreated = true;\n\n    if (isSource) {\n      field.docDef = cfg.sourcePropertyDoc;\n      cfg.sourcePropertyDoc.addField(field);\n    } else {\n      field.docDef = cfg.targetPropertyDoc;\n      cfg.targetPropertyDoc.addField(field);\n    }\n    if (addToActiveMapping) {\n      this.cfg.mappingService.addFieldToActiveMapping(field);\n    }\n    cfg.mappingService.notifyMappingUpdated();\n  }\n\n  /**\n   * Delete a property field.\n   * @param propName\n   * @param propScope\n   * @param isSource\n   */\n  deleteProperty(propName: string, propScope: string, isSource: boolean): void {\n    const path = this.getPropertyPath(propScope, propName);\n    const field = isSource\n      ? this.cfg.sourcePropertyDoc.getField(path)\n      : this.cfg.targetPropertyDoc.getField(path);\n    if (!field) {\n      return;\n    }\n    this.cfg.mappingService.removeFieldFromAllMappings(field);\n    if (isSource) {\n      this.cfg.sourcePropertyDoc.removeField(field);\n    } else {\n      this.cfg.targetPropertyDoc.removeField(field);\n    }\n    const activeMapping = this.cfg.mappings?.activeMapping;\n    const expression = activeMapping?.transition?.expression;\n    if (activeMapping && expression) {\n      expression.updateFieldReference(activeMapping);\n    }\n    this.cfg.mappingService.notifyMappingUpdated();\n  }\n\n  /**\n   * Edit a property field. When editing a property, the propName/propScope\n   * is needed to fetch the existing field.  The newName and newScope may or\n   * may not be specified.\n   *\n   * @param propName\n   * @param propType\n   * @param propScope\n   * @param isSource\n   * @param newName\n   * @param newScope\n   */\n  editProperty(\n    propName: string,\n    propType: string,\n    propScope: string,\n    isSource: boolean,\n    newName?: string,\n    newScope?: string\n  ): void {\n    let oldPath = this.getPropertyPath(propScope, propName);\n    let field = isSource\n      ? this.cfg.sourcePropertyDoc.getField(oldPath)\n      : this.cfg.targetPropertyDoc.getField(oldPath);\n    if (!field) {\n      return;\n    }\n    if (newName) {\n      field.name = newName;\n    }\n    if (newScope) {\n      field.scope = newScope;\n    }\n    field.type = FieldType[propType as keyof typeof FieldType];\n    field.path = this.getPropertyPath(field.scope, field.name!);\n\n    if (isSource) {\n      this.cfg.sourcePropertyDoc.updateField(field, oldPath);\n    } else {\n      this.cfg.targetPropertyDoc.updateField(field, oldPath);\n    }\n    this.cfg.mappingService.notifyMappingUpdated();\n  }\n\n  /**\n   * Get a {@link FieldType} of the property field.\n   * @param propName\n   * @param propScope\n   * @param isSource\n   */\n  getPropertyType(\n    propName: string,\n    propScope: string,\n    isSource: boolean\n  ): FieldType {\n    const field = isSource\n      ? this.cfg.sourcePropertyDoc.getField(\n          this.getPropertyPath(propScope, propName)\n        )\n      : this.cfg.targetPropertyDoc.getField(\n          this.getPropertyPath(propScope, propName)\n        );\n    if (!field) {\n      return FieldType.NONE;\n    }\n    return field.type;\n  }\n\n  /**\n   * Get an index of the property field type.\n   * @param propName\n   * @param propScope\n   * @param isSource\n   */\n  getPropertyTypeIndex(\n    propName: string,\n    propScope: string,\n    isSource: boolean\n  ): number {\n    const field = isSource\n      ? this.cfg.sourcePropertyDoc.getField(\n          this.getPropertyPath(propScope, propName)\n        )\n      : this.cfg.targetPropertyDoc.getField(\n          this.getPropertyPath(propScope, propName)\n        );\n    if (!field) {\n      return 0;\n    }\n    for (let i = 0; i < propertyTypes.length; i++) {\n      if (propertyTypes[i].includes(field.type)) {\n        return i;\n      }\n    }\n    return 0;\n  }\n\n  getPropertyPath(scope: string | undefined | null, name: string) {\n    let answer = FIELD_PATH_SEPARATOR;\n    if (scope && scope.length > 0) {\n      answer += scope + FIELD_PATH_SEPARATOR;\n    }\n    answer += name;\n    return answer;\n  }\n}\n","/*\n    Copyright (C) 2017 Red Hat, Inc.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n            http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n*/\n\nimport {\n  ErrorInfo,\n  ErrorLevel,\n  ErrorScope,\n  ErrorType,\n} from '../models/error.model';\nimport { Subject, Subscription } from 'rxjs';\nimport { MappingModel } from '../models/mapping.model';\n\n/**\n * ErrorHandlerService handles global errors, mapping validation errors, preview errors,\n * mapped field level errors as well as instant form validation errors in a modal windows.\n * Global errors, mapping validation errors, preview errors and mapped field level errors\n * are stored in a same array at this moment. We might want to split them when we show\n * them grouped by {@link ErrorType}.\n * Errors with {@link ErrorScope.MAPPING} and {@link ErrorScope.FIELD} are cleared\n * everytime active mapping is switched. {@link ErrorScope.FIELD} errors are mostly\n * instant and cleared more frequently.\n * Form validation errors are supposed to be instant. Channel should be created by\n * {@link createFormErrorChannel()} when modal window is initialized, and should be\n * completed when modal window is closed.\n */\nexport class ErrorHandlerService {\n  private errors: ErrorInfo[] = [];\n  private formErrors: ErrorInfo[] = [];\n  private errorUpdatedSource = new Subject<ErrorInfo[]>();\n  private formErrorUpdatedSource: Subject<ErrorInfo[]> | undefined;\n\n  /**\n   * FIlter an array of {@link ErrorInfo} with specified condition.\n   * @param errors An array of {@link ErrorInfo} to filter\n   * @param mapping {@link MappingModel} to filter {@link ErrorScope.MAPPING} errors\n   * @param level {@link ErrorLevel} to filter with\n   */\n  static filterWith(\n    errors: ErrorInfo[],\n    mapping?: MappingModel,\n    level?: ErrorLevel\n  ): ErrorInfo[] {\n    if (!errors || errors.length === 0) {\n      return [];\n    }\n    return errors.filter(\n      (e) =>\n        (!e.mapping || (mapping && e.mapping === mapping)) &&\n        (!level || !e.level || e.level === level)\n    );\n  }\n\n  /**\n   * Add one or more {@link ErrorInfo} object(s) into error store.\n   * @param errors one or more {@link ErrorInfo} object(s)\n   */\n  addError(...errors: ErrorInfo[]): void {\n    errors.forEach((error) => {\n      if (error.object && error.object.message) {\n        // TODO show error.object in more polished way... maybe with better error console\n        error.message += '\\n' + error.object.message;\n      }\n      const store =\n        ErrorScope.FORM === error.scope ? this.formErrors : this.errors;\n      if (store.find((e) => e.message === error.message)) {\n        return;\n      }\n      store.unshift(error);\n    });\n    this.emitUpdatedEvent();\n  }\n\n  /**\n   * An utility method to add backend error. It's a network error if {@link error.status} is 0.\n   *\n   * @param message error message to put if it's not a network error\n   * @param error raw error object\n   */\n  addBackendError(message: string, error?: any): void {\n    if (error?.status === 0) {\n      this.addError(\n        new ErrorInfo({\n          message:\n            'Fatal network error: Unable to connect to the AtlasMap design runtime service.',\n          level: ErrorLevel.ERROR,\n          scope: ErrorScope.APPLICATION,\n          type: ErrorType.INTERNAL,\n          object: error,\n        })\n      );\n    } else {\n      this.addError(\n        new ErrorInfo({\n          message: message,\n          level: ErrorLevel.ERROR,\n          scope: ErrorScope.APPLICATION,\n          type: ErrorType.INTERNAL,\n          object: error,\n        })\n      );\n    }\n  }\n\n  /**\n   * Return all errors in the store.\n   * @return An array of {@link ErrorInfo}\n   */\n  getErrors(): ErrorInfo[] {\n    return Object.assign([], this.errors);\n  }\n\n  /**\n   * Remove one {@link ErrorInfo} by specifying ID.\n   * @param identifier Error ID\n   */\n  removeError(identifier: string, scope?: ErrorScope): void {\n    if (\n      scope === ErrorScope.FORM &&\n      this.formErrorUpdatedSource &&\n      !this.formErrorUpdatedSource.closed\n    ) {\n      this.formErrors = this.excludeByIdentifier(this.formErrors, identifier);\n    } else {\n      this.errors = this.excludeByIdentifier(this.errors, identifier);\n    }\n    this.emitUpdatedEvent();\n  }\n\n  /**\n   * Clear all global/mapping errors as well as form validation erros and its Subject\n   * if it exists.\n   */\n  resetAll(): void {\n    this.clearAllErrors();\n    this.formErrors = [];\n    if (this.formErrorUpdatedSource && !this.formErrorUpdatedSource.closed) {\n      this.formErrorUpdatedSource.complete();\n    }\n  }\n\n  /**\n   * Remova all errors except form validation errors.\n   */\n  clearAllErrors() {\n    this.errors = [];\n    this.emitUpdatedEvent();\n  }\n\n  /**\n   * Remove all preview errors.\n   */\n  clearPreviewErrors(): void {\n    this.errors = this.errors.filter((e) => e.type !== ErrorType.PREVIEW);\n    this.emitUpdatedEvent();\n  }\n\n  /**\n   * Remove all mapping validation errors.\n   */\n  clearValidationErrors(mapping?: MappingModel): void {\n    this.errors = this.errors.filter(\n      (e) =>\n        e.type !== ErrorType.VALIDATION &&\n        (!mapping || !e.mapping || e.mapping !== mapping)\n    );\n    this.emitUpdatedEvent();\n  }\n\n  /**\n   * Remove all field scoped errors.\n   */\n  clearFieldErrors() {\n    this.errors = this.errors.filter((e) => e.scope !== ErrorScope.FIELD);\n    this.emitUpdatedEvent();\n  }\n\n  /**\n   * Remove all form validation errors.\n   */\n  clearFormErrors() {\n    this.formErrors = [];\n    this.emitUpdatedEvent(ErrorScope.FORM);\n  }\n\n  /**\n   * Subscribe an error updated event. Observer will be notified\n   * when an error is added or removed.\n   * @param observer Observer\n   */\n  subscribe(observer: (errors: ErrorInfo[]) => void): Subscription {\n    return this.errorUpdatedSource.subscribe(observer);\n  }\n\n  /**\n   * Create a Subject for form validation error. This ErrorHandlerService assumes only\n   * one form validation happens at once, as it's used in modal window. Revisit this if there\n   * needs to be more than one channel and manage a list of {@link Subject}.\n   */\n  createFormErrorChannel(): Subject<ErrorInfo[]> {\n    if (this.formErrorUpdatedSource && !this.formErrorUpdatedSource.closed) {\n      this.formErrorUpdatedSource.complete();\n    }\n    this.formErrors = [];\n    this.formErrorUpdatedSource = new Subject();\n    this.formErrorUpdatedSource.subscribe({\n      complete: () => (this.formErrors = []),\n    });\n    return this.formErrorUpdatedSource;\n  }\n\n  /**\n   * Validate the specified field value in a form, generating a form validation error if not defined.\n   * @param value - A form field to validate\n   * @param fieldDescription - used in error diagnostic\n   */\n  isRequiredFieldValid(\n    value: string | null,\n    fieldDescription: string\n  ): boolean {\n    if (value == null || '' === value) {\n      const errorMessage: string = fieldDescription + ' is required.';\n      this.addError(\n        new ErrorInfo({\n          message: errorMessage,\n          level: ErrorLevel.ERROR,\n          scope: ErrorScope.FORM,\n        })\n      );\n      this.emitUpdatedEvent(ErrorScope.FORM);\n      return false;\n    }\n    return true;\n  }\n\n  private emitUpdatedEvent(scope?: ErrorScope) {\n    if (ErrorScope.FORM === scope) {\n      if (this.formErrorUpdatedSource && !this.formErrorUpdatedSource.closed) {\n        this.formErrorUpdatedSource.next(this.formErrors);\n      }\n    } else {\n      this.errorUpdatedSource.next(this.errors);\n    }\n  }\n\n  private excludeByIdentifier(\n    errors: ErrorInfo[],\n    identifier: string\n  ): ErrorInfo[] {\n    return errors.filter((e) => e.identifier !== identifier);\n  }\n}\n","/*\n    Copyright (C) 2017 Red Hat, Inc.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n            http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n*/\nimport {\n  ErrorInfo,\n  ErrorLevel,\n  ErrorScope,\n  ErrorType,\n} from '../models/error.model';\nimport {\n  FieldActionArgument,\n  FieldActionDefinition,\n} from '../models/field-action.model';\nimport {\n  IActionDetail,\n  IActionDetailsContainer,\n  Multiplicity,\n} from '../contracts/field-action';\n\nimport { ConfigModel } from '../models/config.model';\nimport { Field } from '../models/field.model';\nimport { FieldType } from '../contracts/common';\nimport { MappingModel } from '../models/mapping.model';\nimport ky from 'ky';\n\nexport class FieldActionService {\n  cfg: ConfigModel = ConfigModel.getConfig();\n  actions: { [key in Multiplicity]: FieldActionDefinition[] } = {\n    [Multiplicity.ONE_TO_ONE]: [],\n    [Multiplicity.ONE_TO_MANY]: [],\n    [Multiplicity.MANY_TO_ONE]: [],\n    [Multiplicity.ZERO_TO_ONE]: [],\n    [Multiplicity.MANY_TO_MANY]: [],\n  };\n\n  isInitialized = false;\n  private headers = {\n    'Content-Type': 'application/json; application/octet-stream',\n    Accept: 'application/json; application/octet-stream',\n  };\n\n  constructor(private api: typeof ky) {}\n\n  async fetchFieldActions(): Promise<boolean> {\n    return new Promise<boolean>((resolve) => {\n      if (this.cfg.preloadedFieldActionMetadata) {\n        this.clearActionDefinitions();\n        if (this.cfg.preloadedFieldActionMetadata.ActionDetails) {\n          for (const actionDetail of this.cfg.preloadedFieldActionMetadata\n            .ActionDetails.actionDetail) {\n            const fieldActionDefinition =\n              this.extractFieldActionDefinition(actionDetail);\n            if (!fieldActionDefinition.multiplicity) {\n              this.cfg.logger!.info(\n                `Field action (${fieldActionDefinition.name}) is missing multiplicity, ingoring`\n              );\n              continue;\n            }\n            if (fieldActionDefinition.name === 'Expression') {\n              // Expression is handled in special manner\n              continue;\n            }\n            this.actions[fieldActionDefinition.multiplicity].push(\n              fieldActionDefinition\n            );\n          }\n        }\n        this.sortFieldActionDefinitions();\n        this.isInitialized = true;\n        resolve(true);\n        return;\n      }\n\n      if (\n        this.cfg.mappingService == null ||\n        this.cfg.initCfg.baseMappingServiceUrl == null\n      ) {\n        this.cfg.errorService.addError(\n          new ErrorInfo({\n            message:\n              'Mapping service URL is not provided. Field Actions will not be used.',\n            level: ErrorLevel.WARN,\n            scope: ErrorScope.APPLICATION,\n            type: ErrorType.INTERNAL,\n          })\n        );\n        this.isInitialized = true;\n        resolve(false);\n        return;\n      }\n\n      // Fetch the field actions from the runtime service.\n      this.doFetchFieldActions()\n        .then((fetchedActionConfigs: FieldActionDefinition[]) => {\n          if (fetchedActionConfigs.length === 1) {\n            this.cfg.logger!.info('No field action was returned from backend');\n            resolve(false);\n          }\n          this.clearActionDefinitions();\n          fetchedActionConfigs.forEach((action) => {\n            if (!action.multiplicity) {\n              this.cfg.logger!.info(\n                `Field action  (${action.name}) is missing multiplicity, ignoring`\n              );\n              return;\n            }\n            if (action.name === 'Expression') {\n              // Expression is handled in special manner\n              return;\n            }\n            this.actions[action.multiplicity].push(action);\n          });\n          this.sortFieldActionDefinitions();\n          this.isInitialized = true;\n          resolve(true);\n        })\n        .catch((error: any) => {\n          this.cfg.errorService.addBackendError(\n            `Could not load field action configs: (${error.message})`,\n            error\n          );\n          resolve(false);\n        });\n    });\n  }\n\n  getActionDefinitionForName(\n    actionName: string,\n    multiplicity?: Multiplicity\n  ): FieldActionDefinition | null {\n    if (!this.actions || !actionName) {\n      return null;\n    }\n    let actions: FieldActionDefinition[] = [];\n    if (multiplicity) {\n      actions = this.actions[multiplicity];\n    } else {\n      Object.values(this.actions).forEach(\n        (arr) => (actions = actions.concat(arr))\n      );\n    }\n    for (const actionDef of actions) {\n      if (actionName === actionDef.name) {\n        return actionDef;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Return the field action Definitions applicable to the specified field mapping pair.\n   * @param mapping\n   * @param isSource\n   * @param multiplicity\n   */\n  getActionsAppliesToField(\n    mapping: MappingModel,\n    isSource: boolean = true,\n    multiplicity: Multiplicity = Multiplicity.ONE_TO_ONE\n  ): FieldActionDefinition[] {\n    if (!mapping || !this.actions) {\n      return [];\n    }\n    return this.actions[multiplicity].filter((d) =>\n      this.appliesToField(d, mapping, isSource)\n    );\n  }\n\n  private doFetchFieldActions(): Promise<FieldActionDefinition[]> {\n    return new Promise<FieldActionDefinition[]>((resolve, reject) => {\n      const actionConfigs: FieldActionDefinition[] = [];\n      const url: string =\n        this.cfg.initCfg.baseMappingServiceUrl + 'fieldActions';\n      this.cfg.logger!.debug('Field Action Config Request');\n      this.api\n        .get(url, { headers: this.headers })\n        .json<IActionDetailsContainer>()\n        .then((body) => {\n          this.cfg.logger!.debug(\n            `Field Action Config Response: ${JSON.stringify(body)}`\n          );\n          if (body?.ActionDetails?.actionDetail?.length) {\n            for (const actionDetail of body.ActionDetails.actionDetail) {\n              const fieldActionConfig =\n                this.extractFieldActionDefinition(actionDetail);\n              actionConfigs.push(fieldActionConfig);\n            }\n          }\n          resolve(actionConfigs);\n        })\n        .catch((error: any) => {\n          reject(error);\n        });\n    });\n  }\n\n  private extractFieldActionDefinition(\n    actionDetail: IActionDetail\n  ): FieldActionDefinition {\n    this.cfg.logger!.trace(\n      `Deserializing field action definition: ${JSON.stringify(actionDetail)}`\n    );\n\n    const fieldActionDefinition = new FieldActionDefinition();\n    fieldActionDefinition.name = actionDetail.name;\n    fieldActionDefinition.isCustom = actionDetail.custom;\n    fieldActionDefinition.sourceType = actionDetail.sourceType;\n    fieldActionDefinition.targetType = actionDetail.targetType;\n    fieldActionDefinition.method = actionDetail.method;\n    fieldActionDefinition.multiplicity = actionDetail.multiplicity;\n    fieldActionDefinition.serviceObject = actionDetail;\n\n    if (actionDetail.actionSchema) {\n      for (const key of Object.keys(actionDetail.actionSchema.properties)) {\n        const propertyObject = actionDetail.actionSchema.properties[key];\n        if (key === '@type') {\n          fieldActionDefinition.name = propertyObject.const;\n          continue;\n        }\n        const argTypeString = (propertyObject.type as string).toUpperCase();\n        const argType = argTypeString\n          ? FieldType[argTypeString as keyof typeof FieldType]\n          : FieldType.STRING;\n        const argumentDefinition = new FieldActionArgument();\n        argumentDefinition.name = key;\n        argumentDefinition.type = argType;\n        if (propertyObject.enum) {\n          argumentDefinition.values = propertyObject.enum;\n        }\n        argumentDefinition.serviceObject = propertyObject;\n        fieldActionDefinition.arguments.push(argumentDefinition);\n      }\n    }\n    return fieldActionDefinition;\n  }\n\n  private sortFieldActionDefinitions() {\n    (Object.keys(this.actions) as [keyof typeof Multiplicity]).forEach(\n      (multiplicity) => {\n        const definitions = this.actions[multiplicity];\n        const sortedActionDefinitions: FieldActionDefinition[] = [];\n        if (definitions == null || definitions.length === 0) {\n          return;\n        }\n\n        const defsByName: { [key: string]: FieldActionDefinition[] } = {};\n        const defNames: string[] = [];\n        for (const fieldActionConfig of definitions) {\n          const name: string = fieldActionConfig.name;\n          let sameNamedDefs: FieldActionDefinition[] = defsByName[name];\n          if (!sameNamedDefs) {\n            sameNamedDefs = [];\n            defNames.push(name);\n          }\n          sameNamedDefs.push(fieldActionConfig);\n          defsByName[name] = sameNamedDefs;\n        }\n\n        defNames.sort();\n\n        for (const name of defNames) {\n          const sameNamedDefs: FieldActionDefinition[] = defsByName[name];\n          for (const fieldActionDefinition of sameNamedDefs) {\n            sortedActionDefinitions.push(fieldActionDefinition);\n          }\n        }\n        this.actions[multiplicity] = sortedActionDefinitions;\n      }\n    );\n  }\n\n  /**\n   * Return true if the action's source/target types and collection types match the respective source/target\n   * field properties for source transformations, or matches the respective target field properties only for\n   * a target transformation.\n   *\n   * @param action\n   * @param mapping\n   * @param isSource\n   */\n  appliesToField(\n    action: FieldActionDefinition,\n    mapping: MappingModel,\n    isSource: boolean\n  ): boolean {\n    if (mapping == null) {\n      return false;\n    }\n    const selectedSourceField: Field = this.getActualField(mapping, true);\n    const selectedTargetField: Field = this.getActualField(mapping, false);\n\n    if (\n      (isSource && selectedSourceField == null) ||\n      (!isSource && selectedTargetField == null)\n    ) {\n      return false;\n    }\n\n    return isSource\n      ? this.appliesToSourceField(action, mapping, selectedSourceField)\n      : this.appliesToTargetField(action, mapping, selectedTargetField);\n  }\n\n  /**\n   * Return the first non-padding field in either the source or target mappings.\n   *\n   * @param mapping\n   * @param isSource\n   */\n  private getActualField(mapping: MappingModel, isSource: boolean): Field {\n    const targetField = mapping\n      .getFields(isSource)\n      .find((f) => f.name !== '<padding field>');\n    // TODO: maybe throw an exception instead of assuming the field will be found?\n    return targetField!;\n  }\n\n  /**\n   * Check if it could be applied to source field.\n   * @param action\n   * @param _\n   * @param selectedSourceField selected source field\n   */\n  private appliesToSourceField(\n    action: FieldActionDefinition,\n    _: MappingModel,\n    selectedSourceField: Field\n  ): boolean {\n    // Check for matching types - date.\n    if (this.matchesDate(action.sourceType, selectedSourceField.type)) {\n      return true;\n    }\n\n    // Check for matching types - numeric.\n    if (this.matchesNumeric(action.sourceType, selectedSourceField.type)) {\n      return true;\n    }\n\n    // First check if the source types match.\n    if (\n      action.sourceType === 'ANY' ||\n      selectedSourceField.type === action.sourceType\n    ) {\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Check if it could be applied for target field. Target type may not change.\n   * @param action\n   * @param _\n   * @param selectedTargetField selected target field\n   */\n  private appliesToTargetField(\n    action: FieldActionDefinition,\n    _: MappingModel,\n    selectedTargetField: Field\n  ): boolean {\n    if (selectedTargetField == null) {\n      return false;\n    }\n\n    if (action.multiplicity !== Multiplicity.ONE_TO_ONE) {\n      return false;\n    }\n\n    // Check for matching types - date.\n    if (\n      this.matchesDate(action.sourceType, selectedTargetField.type) &&\n      this.matchesDate(action.targetType, selectedTargetField.type)\n    ) {\n      return true;\n    }\n\n    // Check for matching types - numeric.\n    if (\n      this.matchesNumeric(action.sourceType, selectedTargetField.type) &&\n      this.matchesNumeric(action.targetType, selectedTargetField.type)\n    ) {\n      return true;\n    }\n\n    if (\n      action.sourceType !== 'ANY' &&\n      action.sourceType !== selectedTargetField.type\n    ) {\n      return false;\n    }\n\n    // All other types must match the selected field types with the candidate field action types.\n    return (\n      action.targetType === 'ANY' ||\n      selectedTargetField.type === action.targetType\n    );\n  }\n\n  /**\n   * Return true if the candidate type and selected type are generically a date, false otherwise.\n   *\n   * @param candidateType\n   * @param selectedType\n   */\n  private matchesDate(candidateType: string, selectedType: string): boolean {\n    return (\n      candidateType === 'ANY' ||\n      (candidateType === 'ANY_DATE' &&\n        ['DATE', 'DATE_TIME', 'DATE_TIME_TZ', 'TIME'].indexOf(selectedType) !==\n          -1)\n    );\n  }\n\n  /**\n   * Return true if the candidate type and selected type are generically numeric, false otherwise.\n   *\n   * @param candidateType\n   * @param selectedType\n   */\n  private matchesNumeric(candidateType: string, selectedType: string): boolean {\n    return (\n      candidateType === 'ANY' ||\n      (candidateType === 'NUMBER' &&\n        [\n          'LONG',\n          'INTEGER',\n          'FLOAT',\n          'DOUBLE',\n          'SHORT',\n          'BYTE',\n          'DECIMAL',\n          'NUMBER',\n        ].indexOf(selectedType) !== -1)\n    );\n  }\n\n  private clearActionDefinitions() {\n    (Object.keys(Multiplicity) as [keyof typeof Multiplicity]).forEach(\n      (m) => (this.actions[m] = [])\n    );\n  }\n}\n","/*\n    Copyright (C) 2017 Red Hat, Inc.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n            http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n*/\nimport {\n  ErrorInfo,\n  ErrorLevel,\n  ErrorScope,\n  ErrorType,\n} from '../models/error.model';\nimport { MappedField, MappingModel } from '../models/mapping.model';\nimport { TransitionMode, TransitionModel } from '../models/transition.model';\n\nimport { CommonUtil } from '../utils/common-util';\nimport { ConfigModel } from '../models/config.model';\nimport { ExpressionModel } from '../models/expression.model';\nimport { Field } from '../models/field.model';\nimport { FieldActionArgumentValue } from '../models/field-action.model';\nimport { FieldType } from '../contracts/common';\nimport { IExpressionNode } from '../contracts/expression';\nimport { MappingUtil } from '../utils/mapping-util';\nimport { Multiplicity } from '../contracts/field-action';\nimport { Subscription } from 'rxjs';\n\n/**\n * Manages conditional mapping expression.\n */\nexport class MappingExpressionService {\n  cfg!: ConfigModel;\n\n  private mappingUpdatedSubscription?: Subscription;\n\n  willClearOutSourceFieldsOnTogglingExpression() {\n    if (this.cfg.mappings?.activeMapping?.transition.enableExpression) {\n      return (\n        this.cfg.mappings.activeMapping.getFirstCollectionField(true) != null\n      );\n    } else {\n      return false;\n    }\n  }\n\n  isExpressionEnabledForActiveMapping(): boolean {\n    return !!this.cfg.mappings?.activeMapping?.transition?.enableExpression;\n  }\n\n  toggleExpressionMode() {\n    if (\n      !this.cfg.mappings ||\n      !this.cfg.mappings.activeMapping ||\n      !this.cfg.mappings.activeMapping.transition\n    ) {\n      this.cfg.errorService.addError(\n        new ErrorInfo({\n          message: 'Please select a mapping first.',\n          level: ErrorLevel.INFO,\n          scope: ErrorScope.MAPPING,\n          type: ErrorType.USER,\n        })\n      );\n      return;\n    }\n    const activeMapping = this.cfg.mappings.activeMapping;\n    if (activeMapping.transition.mode === TransitionMode.ONE_TO_MANY) {\n      this.cfg.errorService.addError(\n        new ErrorInfo({\n          message: `Cannot establish a conditional mapping expression when multiple target fields are selected.\n        Please select only one target field and try again.`,\n          level: ErrorLevel.WARN,\n          scope: ErrorScope.MAPPING,\n          type: ErrorType.USER,\n          mapping: activeMapping,\n        })\n      );\n      return;\n    }\n\n    if (this.willClearOutSourceFieldsOnTogglingExpression()) {\n      // Clear out source fields, if the mapping contains a source collection\n      activeMapping.sourceFields.splice(0, activeMapping.sourceFields.length);\n    }\n\n    activeMapping.transition.enableExpression =\n      !activeMapping.transition.enableExpression;\n    if (activeMapping.transition.enableExpression) {\n      activeMapping.transition.mode = TransitionMode.EXPRESSION;\n      activeMapping.transition.transitionFieldAction = null;\n      this.mappingUpdatedSubscription =\n        this.cfg.mappingService.mappingUpdated$.subscribe(() => {\n          if (\n            !this.cfg ||\n            !this.cfg.mappings ||\n            !this.cfg.mappings.activeMapping\n          ) {\n            return;\n          }\n          if (this.cfg.mappings.activeMapping.isFullyMapped()) {\n            this.updateExpression(this.cfg.mappings.activeMapping);\n          }\n        });\n      if (activeMapping.transition.expression) {\n        this.cfg.mappings.activeMapping.transition.expression.expressionUpdatedSource.next();\n      }\n    } else {\n      this.mappingUpdatedSubscription?.unsubscribe();\n      activeMapping.transition.mode = TransitionMode.ONE_TO_ONE;\n      this.cfg.mappingService.updateActiveMappingTransition();\n    }\n  }\n\n  updateExpression(mapping: MappingModel, position?: string, offset?: number) {\n    // Update conditional expression field references.\n    mapping.transition.expression?.updateFieldReference(\n      mapping,\n      position,\n      offset\n    );\n  }\n\n  /**\n   * Add the specified document ID/field path to the specified mapping/ expression.\n   *\n   * @param mapping\n   * @param docId\n   * @param fieldPath\n   * @param newTextNode\n   * @param atIndex\n   * @param isTrailer\n   */\n  addFieldToExpression(\n    mapping: MappingModel,\n    docId: string,\n    fieldPath: string,\n    newTextNode: IExpressionNode,\n    atIndex: number,\n    isTrailer: boolean\n  ) {\n    let mappedField = mapping.getMappedFieldByPath(fieldPath, true, docId);\n\n    if (!mappedField) {\n      // If the selected field was not part of the original mapping\n      // and is complex then add it as a reference node.\n      mappedField = mapping.getReferenceField(docId, fieldPath);\n      if (!mappedField) {\n        // Try adding the selected field to the active mapping.\n        const docDef = this.cfg.getDocForIdentifier(docId, true);\n        const field = Field.getField(fieldPath, docDef?.getAllFields()!);\n        if (field) {\n          this.updateExpression(\n            mapping,\n            newTextNode.getUuid(),\n            isTrailer ? newTextNode.toText().length : atIndex\n          );\n          this.cfg.mappingService.addFieldToActiveMapping(field);\n        }\n        mappedField = mapping.getMappedFieldByPath(fieldPath, true, docId);\n        if (!mappedField) {\n          return;\n        }\n      }\n    }\n    mapping.transition!.expression?.addConditionalExpressionNode(\n      mappedField,\n      newTextNode.getUuid(),\n      isTrailer ? newTextNode.str.length : atIndex\n    );\n  }\n\n  /**\n   * Return an array of strings representing display names of mapping fields based on the\n   * specified filter.\n   * @todo ATM this is specialized for listing up candidate fields for adding into expression.\n   * We will need to consolidate with field filter on the Document tree when we implement server\n   * side field search - https://github.com/atlasmap/atlasmap/issues/603\n   *\n   * @param filter\n   */\n  executeFieldSearch(\n    configModel: ConfigModel,\n    filter: string,\n    isSource: boolean\n  ): string[][] {\n    const activeMapping = configModel.mappings!.activeMapping;\n    if (!activeMapping) {\n      return [];\n    }\n    const formattedFields: string[][] = [];\n    let fields: Field[] = [];\n    for (const docDef of configModel.getDocs(isSource)) {\n      fields = docDef.getTerminalFields();\n      fields = fields.concat(docDef.getComplexFields());\n      Field.alphabetizeFields(fields);\n      let documentName = '';\n      let fieldCount = -1;\n\n      for (const field of fields) {\n        const formattedField: string[] = [''];\n        let displayName =\n          field == null ? '' : field.getFieldLabel(configModel.showTypes, true);\n\n        if (\n          filter == null ||\n          filter === '' ||\n          displayName.toLowerCase().indexOf(filter.toLowerCase()) !== -1\n        ) {\n          if (\n            !configModel.mappingService.isFieldSelectable(\n              activeMapping,\n              field\n            ) &&\n            field.type !== FieldType.COMPLEX\n          ) {\n            continue;\n          }\n          if (documentName !== field.docDef.name) {\n            if (fieldCount === 0) {\n              formattedFields.pop();\n              continue;\n            } else {\n              const documentField = [''];\n              documentName = field.docDef.name;\n              documentField[0] = documentName;\n              documentField[1] = field.docDef.id;\n              fieldCount = 0;\n              formattedFields.push(documentField);\n            }\n          }\n          displayName = CommonUtil.extractDisplayPath(field.path, 100);\n          formattedField[0] = field.docDef.id;\n          formattedField[1] = field.path;\n          fieldCount++;\n          formattedFields.push(formattedField);\n        }\n        if (formattedFields.length > 19) {\n          break;\n        }\n      }\n    }\n    return formattedFields;\n  }\n\n  /**\n   * Return a string, in either text or HTML form, representing the\n   * expression mapping of either the optionally specified mapping or\n   * the active mapping if it exists, empty string otherwise.\n   * @todo avoid any, use typed mapping object - https://github.com/atlasmap/atlasmap/issues/2975\n   * @param asHTML\n   * @param mapping\n   */\n  getMappingExpressionStr(asHTML: boolean, mapping?: any): string {\n    if (!mapping && !MappingUtil.activeMapping(this.cfg)) {\n      return '';\n    }\n    if (!mapping) {\n      mapping = this.cfg.mappings?.activeMapping;\n    }\n    if (!mapping.transition.expression) {\n      if (\n        mapping.transition.enableExpression &&\n        MappingUtil.hasFieldAction(mapping.sourceFields)\n      ) {\n        this.createMappingExpression(mapping);\n      } else {\n        return '';\n      }\n    }\n\n    if (mapping.transition.expression && mapping.transition.enableExpression) {\n      return asHTML\n        ? mapping.transition.expression.expressionHTML\n        : mapping.transition.expression.toText(true);\n    }\n    return '';\n  }\n\n  /**\n   * Create a conditional mapping expression from the specified mapping model.  Start\n   * with a multiplicity action if applicable, then any field-specific field actions.\n   *\n   * @param mapping\n   */\n  createMappingExpression(mapping: MappingModel): string {\n    let expr = '';\n    const sourceMappedFields = mapping.getMappedFields(true);\n    const sourceMappedCollection = MappingUtil.hasMappedCollection(\n      mapping,\n      true\n    );\n    const targetMappedFields = mapping.getMappedFields(false);\n    const targetMappedCollection = MappingUtil.hasMappedCollection(\n      mapping,\n      false\n    );\n\n    if (\n      sourceMappedFields.length > 1 ||\n      (sourceMappedCollection &&\n        mapping.transition.transitionFieldAction?.definition?.multiplicity ===\n          Multiplicity.MANY_TO_ONE)\n    ) {\n      expr = 'Concatenate (';\n      expr += this.fieldActionsToExpression(mapping);\n      expr +=\n        \", '\" +\n        TransitionModel.delimiterModels[mapping.transition.delimiter]\n          .actualDelimiter +\n        \"')\";\n    } else if (\n      (targetMappedFields.length > 1 || targetMappedCollection) &&\n      mapping.transition.transitionFieldAction?.definition?.multiplicity ===\n        Multiplicity.ONE_TO_MANY\n    ) {\n      expr = 'Split (';\n      expr += this.fieldActionsToExpression(mapping);\n      expr += ')';\n    } else {\n      expr += this.fieldActionsToExpression(mapping);\n    }\n    mapping.transition.expression = new ExpressionModel(mapping, this.cfg);\n    mapping.transition.expression.insertText(expr);\n    return expr;\n  }\n\n  private qualifiedExpressionRef(mappedField: MappedField): string {\n    if (mappedField.field?.path !== null) {\n      return (\n        '${' +\n        mappedField.field?.docDef?.id +\n        ':' +\n        mappedField.field?.path +\n        '}'\n      );\n    } else {\n      return 'null';\n    }\n  }\n\n  /**\n   * Create a conditional expression fragment based on the specified field action\n   * argument and type.\n   *\n   * @param actionArgument\n   * @param actionArgType\n   */\n  private fieldActionArgumentToExpression(\n    actionArgument: FieldActionArgumentValue,\n    actionArgType: string\n  ): string {\n    if (actionArgType === 'string') {\n      return \"'\" + actionArgument.value + \"'\";\n    } else {\n      return actionArgument.value;\n    }\n  }\n\n  /**\n   * Create a conditional expression fragment based on a single field action\n   * and its arguments if any.\n   *\n   * @param mappedField\n   * @param mfActionIndex\n   */\n  private fieldActionToExpression(\n    mappedField: MappedField,\n    mfActionIndex: number\n  ): string {\n    let action = mappedField.actions[mfActionIndex];\n    let expression = action.name + ' (';\n    if (mfActionIndex < mappedField.actions.length - 1) {\n      mfActionIndex++;\n      expression += this.fieldActionToExpression(mappedField, mfActionIndex);\n    } else {\n      expression += this.qualifiedExpressionRef(mappedField);\n    }\n    if (action.argumentValues.length > 0) {\n      for (\n        let actionArgIndex = 0;\n        actionArgIndex < action.argumentValues.length;\n        actionArgIndex++\n      ) {\n        expression +=\n          ', ' +\n          this.fieldActionArgumentToExpression(\n            action.argumentValues[actionArgIndex],\n            action.definition!.arguments[actionArgIndex].type\n          );\n      }\n    }\n    expression += ')';\n    return expression;\n  }\n\n  /**\n   * Create a conditional expression fragment based on the field actions of the specified\n   * mapping model and the root field reference.\n   *\n   * @param mapping\n   */\n  private fieldActionsToExpression(mapping: MappingModel): string {\n    let expression = '';\n    let mappedField: MappedField;\n\n    for (\n      let mappedFieldIndex = 0;\n      mappedFieldIndex < mapping.sourceFields.length;\n      mappedFieldIndex++\n    ) {\n      mappedField = mapping.sourceFields[mappedFieldIndex];\n      if (mappedField.actions.length > 0) {\n        let mfActionIndex = 0;\n        expression += this.fieldActionToExpression(mappedField, mfActionIndex);\n      } else {\n        expression += this.qualifiedExpressionRef(mappedField);\n      }\n      if (mappedFieldIndex !== mapping.sourceFields.length - 1) {\n        expression += ', ';\n      }\n    }\n    return expression;\n  }\n}\n","/*\n    Copyright (C) 2017 Red Hat, Inc.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n            http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n*/\n\nimport {\n  ErrorInfo,\n  ErrorLevel,\n  ErrorScope,\n  ErrorType,\n} from '../models/error.model';\nimport {\n  IAtlasMappingContainer,\n  IValidationsContainer,\n} from '../contracts/mapping';\nimport { LookupTableData, LookupTableUtil } from '../utils/lookup-table-util';\nimport { MappedField, MappingModel } from '../models/mapping.model';\nimport { Subject, Subscription } from 'rxjs';\n\nimport { CommonUtil } from '../utils/common-util';\nimport { ConfigModel } from '../models/config.model';\nimport { Field } from '../models/field.model';\nimport { FieldAction } from '../models/field-action.model';\nimport { MappingDefinition } from '../models/mapping-definition.model';\nimport { MappingSerializer } from '../utils/mapping-serializer';\nimport { MappingUtil } from '../utils/mapping-util';\nimport { Multiplicity } from '../contracts/field-action';\nimport { PaddingField } from '../models/document-definition.model';\nimport { TransitionMode } from '../models/transition.model';\nimport ky from 'ky';\nimport log from 'loglevel';\n\n/**\n * Handles mapping updates. It restores mapping status from backend and reflect in UI,\n * and/or reflect mapping changes caused by the user action made in UI to the backend.\n */\nexport class MappingManagementService {\n  _cfg!: ConfigModel;\n\n  lineRefreshSource = new Subject<void>();\n  lineRefresh$ = this.lineRefreshSource.asObservable();\n  mappingUpdatedSource = new Subject<void>();\n  mappingUpdated$ = this.mappingUpdatedSource.asObservable();\n\n  debugMappingUpdatedSubscription?: Subscription;\n\n  mappingSelectionRequiredSource = new Subject<Field>();\n  mappingSelectionRequired$ =\n    this.mappingSelectionRequiredSource.asObservable();\n\n  constructor(private api: typeof ky) {}\n\n  get cfg() {\n    return this._cfg;\n  }\n\n  set cfg(cfg: ConfigModel) {\n    this._cfg = cfg;\n    if (!this._cfg.logger) {\n      this._cfg.logger = log.getLogger('mapping-management');\n    }\n    if (this._cfg.logger.getLevel() <= this._cfg.logger.levels.DEBUG) {\n      this.mappingUpdated$.subscribe(() => {\n        if (!this.cfg.mappings) {\n          return;\n        }\n        if (this.cfg.mappings && this.cfg.mappings.activeMapping) {\n          this.cfg.logger!.info(\n            'mapping updated: ' +\n              JSON.stringify(MappingSerializer.serializeMappings(this.cfg))\n          );\n        }\n      });\n    }\n  }\n\n  /**\n   * Retrieve current mapping definition JSON file from backend, deserialize it and\n   * load it into AtlasMap UI.\n   *\n   * @param mappingDefinition {@link MappingDefinition}\n   * @returns\n   */\n  fetchMappings(\n    _mappingFiles: string[],\n    mappingDefinition: MappingDefinition\n  ): Promise<boolean> {\n    return new Promise<boolean>((resolve) => {\n      this.cfg.fileService\n        .getCurrentMappingJson()\n        .then(async (mappingJson: any) => {\n          if (!mappingJson) {\n            resolve(false);\n            return;\n          }\n          this.cfg.mappings = mappingDefinition;\n          MappingSerializer.deserializeMappingServiceJSON(\n            mappingJson,\n            this.cfg\n          );\n          this.updateMappingsTransition();\n          resolve(true);\n        })\n        .catch((error) => {\n          this.cfg.errorService.addBackendError(\n            'Failed to load mapping definition from backend:',\n            error\n          );\n          resolve(false);\n        });\n    });\n  }\n\n  updateMappingsTransition() {\n    this.cfg\n      .mappings!.getAllMappings(true)\n      .forEach((m) => this.updateTransition(m)); // TODO: check this non null operator\n  }\n\n  updateActiveMappingTransition() {\n    if (this.cfg.mappings?.activeMapping) {\n      this.updateTransition(this.cfg.mappings?.activeMapping);\n    }\n  }\n\n  /**\n   * Remove the specified mapping model from the mappings array and update the runtime.\n   *\n   * @param mappingModel\n   */\n  async removeMapping(mappingModel: MappingModel): Promise<boolean> {\n    return new Promise<boolean>(async (resolve) => {\n      const mappingWasRemoved: boolean =\n        this.cfg.mappings!.removeMapping(mappingModel); // TODO: check this non null operator\n      if (mappingWasRemoved) {\n        this.deselectMapping();\n        await this.notifyMappingUpdated();\n      } else {\n        this.deselectMapping();\n      }\n      resolve(true);\n    });\n  }\n\n  /**\n   * Remove all mappings from the current session.\n   */\n  async removeAllMappings(): Promise<boolean> {\n    return new Promise<boolean>(async (resolve) => {\n      // TODO: check these non null operator on the mappings\n      for (const mapping of this.cfg.mappings!.getAllMappings(true)) {\n        this.cfg.mappings!.removeMapping(mapping);\n        this.deselectMapping();\n      }\n      await this.notifyMappingUpdated();\n      resolve(true);\n    });\n  }\n\n  async updateMappedField(mapping: MappingModel): Promise<boolean> {\n    return new Promise<boolean>(async (resolve) => {\n      if (mapping.isEmpty()) {\n        this.cfg.mappings!.removeMapping(mapping); // TODO: check this non null operator\n        this.deselectMapping();\n      } else {\n        this.updateTransition(mapping);\n      }\n      await this.notifyMappingUpdated();\n      resolve(true);\n    });\n  }\n\n  /**\n   * Move the specified mapped field in the specified mapping to the specified index.\n   *\n   * @param mapping\n   * @param insertedMappedField\n   * @param targetIndex\n   */\n  moveMappedFieldTo(\n    mapping: MappingModel,\n    insertedMappedField: MappedField,\n    targetIndex: number\n  ): void {\n    if (!mapping || !insertedMappedField) {\n      return;\n    }\n    const mappedFields = mapping.getMappedFields(\n      insertedMappedField.isSource()\n    );\n    mappedFields.splice(\n      mapping.getIndexForMappedField(insertedMappedField)! - 1,\n      1\n    );\n    mappedFields.splice(targetIndex - 1, 0, insertedMappedField);\n    this.clearExtraPaddingFields(mappedFields, true);\n    this.notifyMappingUpdated();\n  }\n\n  /**\n   * Given an index range, fill in the mappings gap with place-holder fields.\n   *\n   * @param count - number of padding fields to add\n   * @param mapping - mapping to modify\n   * @param basePadIndex - 0 based\n   * @param isSource\n   */\n  addPlaceholders(\n    count: number,\n    mapping: MappingModel,\n    basePadIndex: number,\n    isSource: boolean\n  ) {\n    let padField = null;\n    for (let i = 0; i < count; i++) {\n      padField = new MappedField();\n      padField.field = new PaddingField(isSource);\n      if (isSource) {\n        mapping.sourceFields.splice(basePadIndex + i, 0, padField);\n      } else {\n        mapping.targetFields.splice(basePadIndex + i, 0, padField);\n      }\n    }\n  }\n\n  addFieldToActiveMapping(field: Field): void {\n    let mapping: MappingModel | null = this.cfg.mappings!.activeMapping;\n    if (!mapping) {\n      this.cfg.errorService.addError(\n        new ErrorInfo({\n          message: `No mapping is selected to add a field '${field.name}'`,\n          level: ErrorLevel.ERROR,\n          scope: ErrorScope.MAPPING,\n          type: ErrorType.USER,\n        })\n      );\n      return;\n    }\n\n    const exclusionReason = this.getFieldSelectionExclusionReason(\n      mapping,\n      field\n    );\n    if (exclusionReason != null) {\n      this.cfg.errorService.addError(\n        new ErrorInfo({\n          message: `The field '${field.name}' cannot be selected, ${exclusionReason}.`,\n          level: ErrorLevel.ERROR,\n          mapping: mapping,\n          scope: ErrorScope.MAPPING,\n          type: ErrorType.USER,\n        })\n      );\n      return;\n    }\n    mapping.addField(field, false);\n\n    this.updateTransition(mapping);\n    if (mapping.sourceFields.length > 0 || mapping.targetFields.length > 0) {\n      this.notifyMappingUpdated();\n    }\n    return;\n  }\n\n  getFieldSelectionExclusionReason(\n    mapping: MappingModel,\n    field: Field\n  ): string | null {\n    if (!field.isTerminal()) {\n      return 'field is a parent field';\n    }\n\n    if (mapping.getAllMappedFields().length === 0) {\n      // if mapping hasn't had a field selected yet, allow it\n      return null;\n    }\n\n    // Non-collection target fields may only be mapped once.\n    const existingMappedField = mapping.getMappedTarget(field);\n    if (existingMappedField != null && !field.isInCollection) {\n      return (\n        'it is already the target of another mapping (' +\n        existingMappedField +\n        '). '\n      );\n    }\n\n    const lookupMode: boolean = mapping.isLookupMode();\n\n    if (lookupMode) {\n      if (!field.enumeration) {\n        return 'only Enumeration fields are valid for this mapping';\n      }\n      return null;\n    }\n    // enums are not selectable in these modes\n    if (field.enumeration) {\n      return 'Enumeration fields are not valid for this mapping';\n    }\n    // Expression mapping\n    if (\n      mapping.transition.enableExpression &&\n      !field.isSource() &&\n      mapping.getMappedFields(false).length > 0\n    ) {\n      return 'cannot add multiple target fields when conditional mapping is enabled.';\n    }\n\n    return null;\n  }\n\n  isFieldSelectable(mapping: MappingModel, field: Field): boolean {\n    return this.getFieldSelectionExclusionReason(mapping, field) == null;\n  }\n\n  /**\n   * Instantiate a new mapping model and associate the selected field with it.\n   * @param selectedField\n   * @param compoundSelection - indicates a compound-selection (ctrl/cmd-M1) if true, standard mouse click if false.\n   */\n  addNewMapping(selectedField: Field, compoundSelection: boolean): void {\n    if (!compoundSelection) {\n      this.deselectMapping();\n    }\n    const mapping: MappingModel = new MappingModel();\n    if (selectedField != null) {\n      mapping.addField(selectedField, false);\n      this.updateTransition(mapping);\n      this.selectMapping(mapping);\n      this.notifyMappingUpdated();\n    } else {\n      this.selectMapping(mapping);\n    }\n  }\n\n  /**\n   * Instantiate a new mapping model.\n   */\n  newMapping(): void {\n    this.deselectMapping();\n    const mapping: MappingModel = new MappingModel();\n    // Determine type of mapping (i.e., transition mode)\n    this.updateTransition(mapping);\n    // SelectMapping marks new mapping as active mapping, which is necessary so\n    // that it gets added to the existing mappings in notifyMappingUpdated().\n    // TODO: this seems very unintuitive, seems like some step to explicitly\n    // add the new mapping would make more sense\n    this.selectMapping(mapping);\n    this.notifyMappingUpdated();\n  }\n\n  selectMapping(mappingModel: MappingModel) {\n    if (mappingModel == null) {\n      this.deselectMapping();\n      return;\n    }\n    this.cfg.mappings!.activeMapping = mappingModel; // TODO: check this non null operator\n    this.cfg.showMappingDetailTray = true;\n    this.mappingUpdatedSource.next();\n  }\n\n  deselectMapping(): void {\n    this.cfg.showMappingDetailTray = false;\n    this.cfg.mappings!.activeMapping = null; // TODO: check this non null operator\n    this.notifyMappingUpdated();\n  }\n\n  /**\n   * Remove any mappings referencing the specified document ID.\n   *\n   * @param docId - Specified document ID\n   * @param cfg\n   */\n  removeDocumentReferenceFromAllMappings(docId: string) {\n    for (const mapping of this.cfg.mappings!.getAllMappings(true)) {\n      for (const mappedField of mapping.getAllFields()) {\n        if (\n          mappedField instanceof PaddingField ||\n          mappedField.docDef.id !== docId\n        ) {\n          continue;\n        }\n        this.removeFieldFromAllMappings(mappedField);\n        if (\n          mapping.sourceFields.length === 0 ||\n          mapping.targetFields.length === 0\n        ) {\n          this.cfg.mappings!.removeMapping(mapping); // TODO: check this non null operator\n          if (mapping === this.cfg.mappings!.activeMapping) {\n            // TODO: check this non null operator\n            this.cfg.mappingService.deselectMapping();\n          }\n        }\n      }\n    }\n  }\n\n  removeFieldFromAllMappings(field: Field): void {\n    // TODO: check this non null operator\n    for (const mapping of this.cfg.mappings!.getAllMappings(true)) {\n      const mappedField = mapping.getMappedFieldForField(field);\n      if (mappedField != null) {\n        mapping.removeMappedField(mappedField);\n        if (mapping.isEmpty()) {\n          this.cfg.mappings!.removeMapping(mapping); // TODO: check this non null operator\n        }\n      }\n    }\n  }\n\n  /**\n   * Invoke the runtime service to validate the current active mapping.\n   */\n  private async validateMappings(\n    payload: IAtlasMappingContainer\n  ): Promise<boolean> {\n    return new Promise<boolean>((resolve) => {\n      if (\n        this.cfg.initCfg.baseMappingServiceUrl === null ||\n        this.cfg.mappings === null\n      ) {\n        // validation service not configured or required\n        resolve(false);\n        return;\n      }\n\n      this.cfg.errorService.clearValidationErrors();\n      const url: string =\n        this.cfg.initCfg.baseMappingServiceUrl +\n        'mapping/validate/' +\n        this.cfg.mappingDefinitionId;\n      this.cfg.logger!.debug(\n        `Validation Service Request: ${JSON.stringify(payload)}\\n`\n      );\n      this.api\n        .put(url, { json: payload })\n        .json<IValidationsContainer>()\n        .then((body) => {\n          this.cfg.logger!.debug(\n            `Validation Service Response: ${JSON.stringify(body)}\\n`\n          );\n          this.processValidationResponse(body, resolve);\n        })\n        .catch(() => {\n          this.cfg.logger!.warn('Unable to fetch validation data.');\n          resolve(false);\n        });\n    });\n  }\n\n  private processValidationResponse(\n    body: IValidationsContainer,\n    resolve: (value: boolean) => void\n  ) {\n    if (this.cfg.mappings === null) {\n      resolve(false);\n      return;\n    }\n    const errors: ErrorInfo[] = [];\n\n    // This should be eventually turned into mapping entry level validation.\n    // https://github.com/atlasmap/atlasmap-ui/issues/116\n    if (body && body.Validations && body.Validations.validation) {\n      for (const validation of body.Validations.validation) {\n        const level: ErrorLevel =\n          ErrorLevel[validation.status ? validation.status : 'ERROR'];\n        let scope: ErrorScope =\n          ErrorScope[validation.scope ? validation.scope : 'MAPPING'];\n        let validatedMapping: MappingModel | undefined = undefined;\n        if (!scope || scope !== ErrorScope.MAPPING || !validation.id) {\n          scope = ErrorScope.APPLICATION;\n        } else {\n          scope = ErrorScope.MAPPING;\n          if (this.cfg.mappings && this.cfg.mappings.mappings) {\n            validatedMapping = this.cfg.mappings.mappings.find(\n              (m) => m.uuid === validation.id\n            )!; // TODO: check this non null operator\n          }\n        }\n        errors.push(\n          new ErrorInfo({\n            message: validation.message,\n            level: level,\n            scope: scope,\n            mapping: validatedMapping,\n            type: ErrorType.VALIDATION,\n          })\n        );\n      }\n    }\n    this.cfg.errorService.addError(...errors);\n    resolve(true);\n  }\n\n  /**\n   * Notify the line machine to update the lines between panels.  Most widgets require a\n   * small delay to allow the panel to complete forming so add it here.\n   */\n  notifyLineRefresh(): void {\n    setTimeout(() => {\n      this.lineRefreshSource.next();\n    }, 1);\n  }\n\n  /**\n   * Validate and save complete mappings.  Triggered either as an observable\n   * or directly.\n   */\n  notifyMappingUpdated(): Promise<boolean> {\n    return new Promise<boolean>(async (resolve) => {\n      if (this.cfg.mappings) {\n        const activeMapping: MappingModel = this.cfg.mappings.activeMapping!; // TODO: check this non null operator\n        if (\n          activeMapping &&\n          this.cfg.mappings.mappings.indexOf(activeMapping) === -1\n        ) {\n          this.cfg.mappings.mappings.push(activeMapping);\n        }\n        const payload = MappingSerializer.serializeMappings(this.cfg);\n        if (await this.validateMappings(payload)) {\n          await this.cfg.fileService.setMappingToService(payload);\n        }\n      }\n      this.mappingUpdatedSource.next();\n      this.notifyLineRefresh();\n      resolve(true);\n    });\n  }\n\n  /**\n   * Update mode transition from a single mapping to multiple-mappings and back.\n   *\n   * @param mapping\n   * @param position\n   * @param offset\n   */\n  private updateTransition(mapping: MappingModel): void {\n    if (mapping.transition.enableExpression) {\n      return;\n    }\n\n    for (const field of mapping.getAllFields()) {\n      if (field.enumeration) {\n        mapping.transition.mode = TransitionMode.ENUM;\n        LookupTableUtil.populateMappingLookupTable(this.cfg.mappings!, mapping); // TODO: check this non null operator\n        return;\n      }\n    }\n\n    const sourceMappedFields = mapping.getMappedFields(true);\n    const sourceMappedCollection = MappingUtil.hasMappedCollection(\n      mapping,\n      true\n    );\n    const targetMappedFields = mapping.getMappedFields(false);\n    const targetMappedCollection = MappingUtil.hasMappedCollection(\n      mapping,\n      false\n    );\n\n    if (sourceMappedCollection && targetMappedCollection) {\n      mapping.transition.mode = TransitionMode.FOR_EACH;\n      return;\n    }\n    if (sourceMappedFields.length > 1 || sourceMappedCollection) {\n      mapping.transition.mode = TransitionMode.MANY_TO_ONE;\n      if (\n        !mapping.transition.transitionFieldAction ||\n        !mapping.transition.transitionFieldAction.definition ||\n        mapping.transition.transitionFieldAction.definition.multiplicity !==\n          Multiplicity.MANY_TO_ONE\n      ) {\n        mapping.transition.transitionFieldAction = FieldAction.create(\n          this.cfg.fieldActionService.getActionDefinitionForName(\n            'Concatenate',\n            Multiplicity.MANY_TO_ONE\n          )!\n        ); // TODO: check this non null operator\n        mapping.transition.transitionFieldAction.setArgumentValue(\n          'delimiter',\n          ' '\n        );\n        mapping.transition.transitionFieldAction.setArgumentValue(\n          'delimitingEmptyValues',\n          'true'\n        );\n      }\n      return;\n    }\n    if (targetMappedFields.length > 1 || targetMappedCollection) {\n      mapping.transition.mode = TransitionMode.ONE_TO_MANY;\n      if (\n        !mapping.transition.transitionFieldAction ||\n        mapping.transition.transitionFieldAction.definition?.multiplicity !==\n          Multiplicity.ONE_TO_MANY\n      ) {\n        mapping.transition.transitionFieldAction = FieldAction.create(\n          this.cfg.fieldActionService.getActionDefinitionForName(\n            'Split',\n            Multiplicity.ONE_TO_MANY\n          )!\n        ); // TODO: check this non null operator\n        mapping.transition.transitionFieldAction.setArgumentValue(\n          'delimiter',\n          ' '\n        );\n        mapping.transition.transitionFieldAction.setArgumentValue(\n          'collapseRepeatingDelimiters',\n          'false'\n        );\n      }\n      return;\n    }\n    mapping.transition.mode = TransitionMode.ONE_TO_ONE;\n    mapping.transition.transitionFieldAction = null;\n  }\n\n  /**\n   * Remove any trailing padding fields for the mapped field array.  This occurs when a user moves\n   * a mapped element above the last padding field.\n   *\n   * @param mappedFields\n   * @param trailing - Remove trailing padding fields only\n   */\n  private clearExtraPaddingFields(\n    mappedFields: MappedField[],\n    trailing: boolean\n  ): void {\n    let index = 0;\n    let mField = null;\n\n    for (index = mappedFields.length - 1; index >= 0; index--) {\n      mField = mappedFields[index];\n      if (mField.isPadField()) {\n        CommonUtil.removeItemFromArray(mField, mappedFields);\n        continue;\n      }\n      if (trailing) {\n        break;\n      }\n    }\n  }\n\n  /**\n   * Get the enumeration values for the specified mapping and return it in\n   * the form of a lookup table.\n   *\n   * @param cfg\n   * @param mapping\n   */\n  getEnumerationValues(\n    cfg: ConfigModel,\n    mapping: MappingModel\n  ): LookupTableData[] {\n    return LookupTableUtil.getEnumerationValues(cfg, mapping);\n  }\n\n  /**\n   * Set the enumeration field value based on the specified enumeration value index.\n   *\n   * @param enumerationField\n   * @param enumerationValue\n   */\n  setEnumFieldValue(enumerationField: Field, enumerationValue: number) {\n    enumerationField.enumIndexValue = enumerationValue;\n  }\n\n  /**\n   * Update the enumeration values for the specified mapping with the specified\n   * enumeration values.\n   *\n   * @param cfg\n   * @param mapping\n   * @param enumerationValues\n   */\n  updateEnumerationValues(\n    cfg: ConfigModel,\n    mapping: MappingModel,\n    enumerationValues: LookupTableData[]\n  ): void {\n    LookupTableUtil.updateEnumerationValues(cfg, mapping, enumerationValues);\n    this.notifyMappingUpdated();\n  }\n\n  /**\n   * Return true if the specified mapping is an enumeration mapping, false otherwise.\n   *\n   * @param mapping\n   */\n  isEnumerationMapping(mapping: MappingModel): boolean {\n    return mapping.transition.mode === TransitionMode.ENUM;\n  }\n}\n","/*\n    Copyright (C) 2017 Red Hat, Inc.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n            http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n*/\nimport {\n  ErrorInfo,\n  ErrorLevel,\n  ErrorScope,\n  ErrorType,\n} from '../models/error.model';\nimport {\n  IProcessMappingRequestContainer,\n  IProcessMappingResponseContainer,\n  PROCESS_MAPPING_REQUEST_JSON_TYPE,\n} from '../contracts/mapping-preview';\nimport { Subject, Subscription } from 'rxjs';\nimport { ConfigModel } from '../models/config.model';\nimport { MappingModel } from '../models/mapping.model';\nimport { MappingSerializer } from '../utils/mapping-serializer';\nimport ky from 'ky';\n\n/**\n * Manages Mapping Preview.\n */\nexport class MappingPreviewService {\n  cfg!: ConfigModel;\n\n  mappingPreviewInputSource = new Subject<MappingModel>();\n  mappingPreviewInput$ = this.mappingPreviewInputSource.asObservable();\n  mappingPreviewOutputSource = new Subject<MappingModel>();\n  mappingPreviewOutput$ = this.mappingPreviewOutputSource.asObservable();\n  mappingPreviewErrorSource = new Subject<ErrorInfo[]>();\n  mappingPreviewError$ = this.mappingPreviewErrorSource.asObservable();\n\n  private mappingPreviewInputSubscription?: Subscription;\n  private mappingUpdatedSubscription?: Subscription;\n\n  constructor(private api: typeof ky) {}\n\n  /**\n   * Enable Mapping Preview.\n   */\n  enableMappingPreview(): void {\n    if (this.cfg.initCfg.baseMappingServiceUrl == null) {\n      // process mapping service not configured.\n      return;\n    }\n    this.cfg.showMappingPreview = true;\n    this.mappingPreviewInputSubscription =\n      this.createMappingPreviewSubscription();\n    this.mappingUpdatedSubscription = this.createMappingUpdatedSubscription();\n  }\n\n  private createMappingPreviewSubscription(): Subscription {\n    return this.mappingPreviewInput$.subscribe((inputFieldMapping) => {\n      if (!inputFieldMapping || !inputFieldMapping.isFullyMapped()) {\n        return;\n      }\n      let hasValue = false;\n      for (const sourceField of inputFieldMapping.getFields(true)) {\n        if (sourceField.value) {\n          hasValue = true;\n          break;\n        }\n      }\n      if (!hasValue) {\n        for (const targetField of inputFieldMapping.getFields(false)) {\n          if (targetField.value) {\n            hasValue = true;\n            break;\n          }\n        }\n      }\n      if (!hasValue) {\n        return;\n      }\n      const payload = this.createPreviewRequestBody(inputFieldMapping);\n      this.cfg.logger!.debug(\n        `Process Mapping Preview Request: ${JSON.stringify(payload)}`\n      );\n      const url: string =\n        this.cfg.initCfg.baseMappingServiceUrl + 'mapping/process';\n      this.api\n        .put(url, { json: payload })\n        .json<IProcessMappingResponseContainer>()\n        .then((body) => {\n          this.cfg.logger!.debug(\n            `Process Mapping Preview Response: ${JSON.stringify(body)}`\n          );\n          this.processPreviewResponse(inputFieldMapping, body);\n        })\n        .catch((error: any) => {\n          if (\n            this.cfg.mappings &&\n            this.cfg.mappings.activeMapping &&\n            this.cfg.mappings.activeMapping === inputFieldMapping\n          ) {\n            this.cfg.errorService.addError(\n              new ErrorInfo({\n                message: error,\n                level: ErrorLevel.ERROR,\n                mapping: inputFieldMapping,\n                scope: ErrorScope.MAPPING,\n                type: ErrorType.PREVIEW,\n              })\n            );\n          }\n          this.mappingPreviewErrorSource.next([\n            new ErrorInfo({ message: error, level: ErrorLevel.ERROR }),\n          ]);\n        });\n    });\n  }\n\n  private createPreviewRequestBody(\n    inputFieldMapping: MappingModel\n  ): IProcessMappingRequestContainer {\n    return {\n      ProcessMappingRequest: {\n        jsonType: PROCESS_MAPPING_REQUEST_JSON_TYPE,\n        mapping: MappingSerializer.serializeFieldMapping(\n          this.cfg,\n          inputFieldMapping,\n          'preview',\n          false\n        ),\n      },\n    };\n  }\n\n  private processPreviewResponse(\n    inputFieldMapping: MappingModel,\n    body: IProcessMappingResponseContainer\n  ) {\n    const answer = MappingSerializer.deserializeFieldMapping(\n      body.ProcessMappingResponse.mapping,\n      this.cfg\n    );\n    for (const toWrite of inputFieldMapping.targetFields) {\n      for (const toRead of answer.targetFields) {\n        // TODO: check these non null operator\n        if (\n          toWrite.field?.docDef?.id === toRead.field?.docDef.id &&\n          toWrite.field?.path === toRead.field?.path\n        ) {\n          // TODO let field component subscribe mappingPreviewOutputSource instead of doing this\n          // TODO: check this non null operator\n          toWrite.field!.value = toRead.mappingField?.value!;\n          const index = answer.targetFields.indexOf(toRead);\n          if (index !== -1) {\n            answer.targetFields.splice(index, 1);\n            break;\n          }\n        }\n      }\n    }\n    this.mappingPreviewOutputSource.next(answer);\n    const audits = MappingSerializer.deserializeAudits(\n      body.ProcessMappingResponse.audits,\n      ErrorType.PREVIEW\n    );\n    // TODO: check this non null operator\n    if (this.cfg.mappings!.activeMapping === inputFieldMapping) {\n      audits.forEach((a) => (a.mapping = inputFieldMapping));\n      this.cfg.errorService.addError(...audits);\n    }\n    this.mappingPreviewErrorSource.next(audits);\n  }\n\n  private createMappingUpdatedSubscription(): Subscription {\n    return this.cfg.mappingService.mappingUpdated$.subscribe(() => {\n      if (!this.cfg || !this.cfg.mappings || !this.cfg.mappings.activeMapping) {\n        return;\n      }\n      if (this.cfg.mappings.activeMapping.isFullyMapped()) {\n        this.mappingPreviewInputSource.next(this.cfg.mappings.activeMapping);\n      }\n    });\n  }\n\n  /**\n   * On mapping preview disable, clear any preview values and unsubscribe from\n   * both the mapping-updated and mapping-preview subscriptions.\n   */\n  disableMappingPreview(): void {\n    let mappedValueCleared = false;\n    this.cfg.showMappingPreview = false;\n\n    // Clear any preview values on mapping preview disable.\n    if (this.cfg.mappings?.activeMapping?.isFullyMapped()) {\n      for (const mapping of this.cfg.mappings.getAllMappings(true)) {\n        for (const mappedField of mapping.getAllFields()) {\n          if (mappedField.value?.length > 0 && !mappedField.isConstant()) {\n            mappedField.value = '';\n            mappedValueCleared = true;\n          }\n        }\n      }\n    }\n    if (mappedValueCleared) {\n      this.cfg.mappingService.notifyMappingUpdated();\n    }\n    if (this.mappingUpdatedSubscription) {\n      this.mappingUpdatedSubscription.unsubscribe();\n      this.mappingUpdatedSubscription = undefined;\n    }\n    if (this.mappingPreviewInputSubscription) {\n      this.mappingPreviewInputSubscription.unsubscribe();\n      this.mappingPreviewInputSubscription = undefined;\n    }\n  }\n\n  /**\n   * Toggle Mapping Preview.\n   * @param enabled\n   */\n  toggleMappingPreview(enabled: boolean) {\n    if (enabled) {\n      this.enableMappingPreview();\n    } else {\n      this.disableMappingPreview();\n    }\n    return enabled;\n  }\n}\n","/*\n    Copyright (C) 2017 Red Hat, Inc.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n            http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n*/\nimport { DocumentType, IStringContainer } from '../contracts/common';\nimport {\n  ErrorInfo,\n  ErrorLevel,\n  ErrorScope,\n  ErrorType,\n} from '../models/error.model';\nimport { Observable, Subject } from 'rxjs';\n\nimport { ADMDigest } from '../contracts/adm-digest';\nimport { CommonUtil } from '../utils/common-util';\nimport { ConfigModel } from '../models/config.model';\nimport { DocumentManagementService } from './document-management.service';\nimport { ErrorHandlerService } from './error-handler.service';\nimport { FieldActionService } from './field-action.service';\nimport { FileManagementService } from './file-management.service';\nimport { LookupTableUtil } from '../utils/lookup-table-util';\nimport { MappingDefinition } from '../models/mapping-definition.model';\nimport { MappingExpressionService } from './mapping-expression.service';\nimport { MappingManagementService } from './mapping-management.service';\nimport { MappingPreviewService } from './mapping-preview.service';\nimport { MappingSerializer } from '../utils/mapping-serializer';\nimport { MappingUtil } from '../utils/mapping-util';\nimport ky from 'ky/umd';\nimport log from 'loglevel';\n\nlog.setDefaultLevel(log.levels.WARN);\n\n/**\n * Initialize AtlasMap UI core library. It initializes {@link ConfigModel} and core services.\n */\nexport class InitializationService {\n  cfg: ConfigModel = ConfigModel.getConfig();\n\n  systemInitializedSource = new Subject<void>();\n  systemInitialized$: Observable<void> =\n    this.systemInitializedSource.asObservable();\n\n  initializationStatusChangedSource = new Subject<void>();\n  initializationStatusChanged$: Observable<void> =\n    this.initializationStatusChangedSource.asObservable();\n\n  private documentService: DocumentManagementService;\n  private mappingService: MappingManagementService;\n  private errorService: ErrorHandlerService;\n  private fieldActionService: FieldActionService;\n  private fileService: FileManagementService;\n  private previewService: MappingPreviewService;\n  private expressionService: MappingExpressionService;\n\n  constructor(private api: typeof ky) {\n    this.documentService = new DocumentManagementService(this.api);\n    this.mappingService = new MappingManagementService(this.api);\n    this.errorService = new ErrorHandlerService();\n    this.fieldActionService = new FieldActionService(this.api);\n    this.fileService = new FileManagementService(this.api);\n    this.previewService = new MappingPreviewService(this.api);\n    this.expressionService = new MappingExpressionService();\n    this.resetConfig();\n    this.documentService.initialize();\n  }\n\n  resetConfig(): void {\n    this.cfg = new ConfigModel();\n    this.cfg.documentService = this.documentService;\n    this.cfg.documentService.cfg = this.cfg;\n    this.cfg.mappingService = this.mappingService;\n    this.cfg.mappingService.cfg = this.cfg;\n    this.cfg.errorService = this.errorService;\n    this.cfg.fieldActionService = this.fieldActionService;\n    this.cfg.fieldActionService.cfg = this.cfg;\n    this.cfg.fileService = this.fileService;\n    this.cfg.fileService.cfg = this.cfg;\n    this.cfg.previewService = this.previewService;\n    this.cfg.previewService.cfg = this.cfg;\n    this.cfg.expressionService = this.expressionService;\n    this.cfg.expressionService.cfg = this.cfg;\n    this.cfg.initializationService = this;\n    this.cfg.logger = log.getLogger('config');\n    ConfigModel.setConfig(this.cfg);\n  }\n\n  initialize(): Promise<boolean> {\n    return new Promise<boolean>(async (resolve) => {\n      this.cfg.setConstantPropertyDocs();\n      this.cfg.errorService.resetAll();\n      this.cfg.fieldActionService.isInitialized = false;\n      this.cfg.initCfg.initialized = false;\n      this.cfg.initCfg.mappingInitialized = false;\n\n      if (this.cfg.mappingService == null) {\n        this.cfg.errorService.addError(\n          new ErrorInfo({\n            message:\n              'Mapping service is not configured, validation service will not be used.',\n            level: ErrorLevel.WARN,\n            scope: ErrorScope.APPLICATION,\n            type: ErrorType.INTERNAL,\n          })\n        );\n      } else if (this.cfg.initCfg.baseMappingServiceUrl == null) {\n        this.cfg.errorService.addError(\n          new ErrorInfo({\n            message:\n              'Mapping service URL is not configured, validation service will not be used.',\n            level: ErrorLevel.WARN,\n            scope: ErrorScope.APPLICATION,\n            type: ErrorType.INTERNAL,\n          })\n        );\n      }\n\n      if (!this.cfg.fieldActionService) {\n        this.handleError('FieldActionService is not configured');\n        resolve(false);\n        return;\n      }\n\n      // Verify the runtime service is out there.\n      try {\n        if (!(await this.runtimeServiceActive())) {\n          this.handleError('The AtlasMap runtime service is not available.');\n          resolve(false);\n          return;\n        }\n      } catch (error) {\n        this.handleError('The AtlasMap runtime service is not available.');\n        resolve(false);\n        return;\n      }\n\n      // load documents from initialization parameters in embedded mode\n      this.updateLoadingStatus('Loading source/target documents.');\n      this.cfg.documentService.inspectDocuments().subscribe({\n        next: () => {\n          this.updateStatus();\n        },\n      });\n\n      this.initializeWithMappingDigest().finally(() => {\n        this.updateStatus();\n      });\n      resolve(true);\n    });\n  }\n\n  /**\n   * Return true if the runtime service is available, false otherwise.\n   */\n  runtimeServiceActive(): Promise<boolean> {\n    return new Promise<boolean>((resolve, reject) => {\n      const url: string = this.cfg.initCfg.baseMappingServiceUrl + 'ping';\n      this.cfg.logger!.debug('Runtime Service Ping Request');\n      this.api\n        .get(url)\n        .json<IStringContainer>()\n        .then((body) => {\n          this.cfg.logger!.debug(\n            `Runtime Service Ping Response: ${body.String}`\n          );\n          resolve(body?.String === 'pong');\n        })\n        .catch((error: any) => {\n          reject(error);\n        });\n    });\n  }\n\n  /**\n   * Retrieve AtlasMap design time backend runtime version.\n   * @returns\n   */\n  getRuntimeVersion(): Promise<string> {\n    const url = this.cfg.initCfg.baseMappingServiceUrl + 'version';\n    return new Promise<string>((resolve, reject) => {\n      this.api\n        .get(url)\n        .json<IStringContainer>()\n        .then((body) => {\n          this.cfg.logger!.debug(\n            `Runtime Service Version Response: ${body.String}`\n          );\n          resolve(body.String);\n        })\n        .catch((error) => {\n          reject(error);\n        });\n    });\n  }\n\n  /**\n   * Initialize with the {@link ADMDigest} mapping digest from either an imported ADM archive\n   * file or from the DM runtime digest file is presented to update the canvas.\n   *\n   * @param mappingDigest - {@link ADMDigest} mapping digest\n   */\n  private initializeWithMappingDigest(): Promise<boolean> {\n    return new Promise<boolean>((resolve) => {\n      this.cfg.fileService\n        .getCurrentMappingDigest()\n        .then(async (mappingDigest: ADMDigest | null) => {\n          // If digest is null then no compressed mappings digest file is available on the server.\n          if (!mappingDigest) {\n            if (this.cfg.mappings === null) {\n              this.cfg.mappings = new MappingDefinition();\n            }\n\n            // load field actions - do this even with no documents so the default field actions are loaded.\n            await this.cfg.fieldActionService.fetchFieldActions();\n            this.updateStatus();\n            resolve(true);\n            return;\n          }\n\n          await this.addDocumentsFromMappingDigest(mappingDigest);\n\n          if (!mappingDigest || !mappingDigest.exportMappings) {\n            resolve(false);\n            return;\n          }\n          // Reinitialize the model mappings.\n          const digestMappingsName =\n            MappingSerializer.deserializeAtlasMappingName(\n              CommonUtil.objectize(mappingDigest.exportMappings.value)\n            );\n\n          // If the live UI mappings name does not match the UI mappings name extracted from the\n          // catalog file then use the mappings from the catalog file. Otherwise use the live\n          // UI file.\n          this.cfg.fileService\n            .findMappingFiles('UI')\n            .then(async (files: string[]) => {\n              await this.cfg.fileService.setMappingDigestToService(\n                mappingDigest\n              );\n              await this.cfg.fieldActionService.fetchFieldActions();\n              if (digestMappingsName !== files[0]) {\n                await this.cfg.fileService.setMappingStringToService(\n                  mappingDigest.exportMappings.value\n                );\n              }\n              // load both default and custom field actions\n              await this.cfg.fieldActionService.fetchFieldActions();\n\n              // load mappings\n              this.fetchMappings().then((value) => {\n                resolve(value);\n              });\n            })\n            .catch(() => {\n              resolve(false);\n            });\n        })\n        .catch(() => {\n          resolve(false);\n        });\n    });\n  }\n\n  private addDocumentsFromMappingDigest(\n    mappingDigest: ADMDigest\n  ): Promise<boolean> {\n    return new Promise<any>(async (resolve) => {\n      this.cfg.errorService.resetAll();\n\n      let fragIndex = 0;\n\n      // Reinitialize the model documents.\n      for (let metaFragment of mappingDigest.exportMeta) {\n        const fragData = mappingDigest.exportBlockData[fragIndex].value;\n        const docID = metaFragment.id ? metaFragment.id : metaFragment.name;\n        const docType = metaFragment.dataSourceType\n          ? (metaFragment.dataSourceType as DocumentType)\n          : (metaFragment.documentType as DocumentType);\n        const isSource =\n          typeof metaFragment.isSource === 'string'\n            ? (metaFragment.isSource as string).toLowerCase() === 'true'\n            : metaFragment.isSource;\n        await this.cfg.documentService.addDocument(\n          fragData,\n          docID,\n          metaFragment.name,\n          docType,\n          metaFragment.inspectionType,\n          isSource,\n          metaFragment.inspectionParameters\n        );\n        this.updateStatus();\n        fragIndex++;\n      }\n      this.cfg.mappingService.notifyMappingUpdated();\n      resolve(true);\n    });\n  }\n\n  /**\n   * Fetch mapping files and initialize user mappings in the canvas.\n   *\n   * @param mappingFiles\n   */\n  private fetchMappings(): Promise<boolean> {\n    return new Promise<boolean>(async (resolve) => {\n      if (this.cfg.mappings != null) {\n        resolve(true);\n        return;\n      }\n\n      this.cfg.mappings = new MappingDefinition();\n      let mappingFiles = this.cfg.mappingFiles;\n      if (!this.cfg.mappingFiles || this.cfg.mappingFiles.length === 0) {\n        mappingFiles = await this.cfg.fileService.findMappingFiles('UI');\n      }\n      if (mappingFiles.length === 0) {\n        resolve(false);\n      }\n\n      this.cfg.mappingService\n        .fetchMappings(mappingFiles, this.cfg.mappings)\n        .then(() => {\n          this.cfg.initCfg.mappingInitialized = true;\n          this.updateStatus();\n          this.cfg.mappingService\n            .notifyMappingUpdated()\n            .then(() => resolve(true));\n        });\n    });\n  }\n\n  updateStatus(): void {\n    const documentCount: number = this.cfg.getAllDocs().length;\n    let finishedDocCount = 0;\n    for (const docDef of this.cfg.getAllDocs()) {\n      if (docDef.initialized || docDef.errorOccurred) {\n        finishedDocCount++;\n      }\n    }\n\n    if (\n      documentCount === finishedDocCount &&\n      this.cfg.fieldActionService.isInitialized\n    ) {\n      if (this.cfg.preloadedMappingJson) {\n        MappingSerializer.deserializeMappingServiceJSON(\n          JSON.parse(this.cfg.preloadedMappingJson),\n          this.cfg\n        );\n        this.cfg.preloadedMappingJson = null;\n      }\n      if (this.cfg.mappings) {\n        LookupTableUtil.updateLookupTables(this.cfg.mappings);\n        MappingUtil.updateDocumentNamespacesFromMappings(this.cfg);\n        MappingUtil.updateMappingsFromDocuments(this.cfg);\n        for (const d of this.cfg.getAllDocs()) {\n          d.updateFromMappings(this.cfg.mappings);\n        }\n        MappingUtil.removeStaleMappings(this.cfg);\n        this.cfg.mappingService.updateMappingsTransition();\n      }\n      this.updateInitComplete();\n    }\n  }\n\n  private handleError(message: string, error?: any) {\n    message = 'Data Mapper UI Initialization Error: ' + message;\n    this.cfg.errorService.addError(\n      new ErrorInfo({\n        message: message,\n        scope: ErrorScope.APPLICATION,\n        level: ErrorLevel.ERROR,\n        type: ErrorType.INTERNAL,\n        object: error,\n      })\n    );\n    this.updateLoadingStatus(message);\n    this.cfg.initCfg.initializationErrorOccurred = true;\n    this.cfg.initCfg.initialized = true;\n    this.systemInitializedSource.next();\n  }\n\n  updateInitComplete(): void {\n    this.updateLoadingStatus('Initialization complete.');\n    this.cfg.initCfg.initialized = true;\n    this.systemInitializedSource.next();\n  }\n\n  updateLoadingStatus(status: string): void {\n    this.cfg.initCfg.loadingStatus = status;\n    this.initializationStatusChangedSource.next();\n  }\n\n  initializeWithADMArchiveFile(file: File): Promise<boolean> {\n    return new Promise<boolean>((resolve) => {\n      this.updateLoadingStatus('Importing ADM archive file');\n      this.cfg.fileService.importADMArchive(file).then(() => {\n        this.initialize().then((value) => {\n          resolve(value);\n        });\n      });\n    });\n  }\n\n  resetAtlasMap(): Promise<boolean> {\n    return new Promise<boolean>((resolve) => {\n      this.cfg.fileService.resetAll().then((value) => {\n        this.initialize().then((value2) => {\n          resolve(value && value2);\n        });\n      });\n    });\n  }\n}\n","/*\n    Copyright (C) 2017 Red Hat, Inc.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n            http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n*/\n\nimport { IDocument, IField, IParameter } from '../common';\n\n/**\n * The CSV inspection data model contracts between frontend and backend.\n */\n\n/**\n * The root object that carries {@link ICsvInspectionResponse}\n * when it's received from backend.\n */\nexport interface ICsvInspectionResponseContainer {\n  CsvInspectionResponse: ICsvInspectionResponse;\n}\n\n/**\n * The serialized CSV inspection response.\n */\nexport interface ICsvInspectionResponse {\n  csvDocument: IDocument;\n  errorMessage?: string;\n  executionTime?: number;\n}\n\n/**\n * The root object that carries {@link ICsvDocument}\n * when it's inspected with maven plugin.\n */\nexport interface ICsvDocumentContainer {\n  CsvDocument: IDocument;\n}\n\n/**\n * The serialized CSV complex field.\n */\nexport interface ICsvComplexType extends ICsvField {\n  csvFields: ICsvFields;\n  uri?: string;\n}\n\n/**\n * The serialized CSV primitive field.\n */\nexport interface ICsvField extends IField {\n  column: number;\n}\n\n/**\n * The container of {@link ICsvField}.\n */\nexport interface ICsvFields {\n  csvField: ICsvField[];\n}\n\n// TODO: Retrieve from the backend CSV module\nexport function getCsvParameterOptions(): IParameter[] {\n  return [\n    {\n      name: 'format',\n      label: 'CSV File Format',\n      value: 'Default',\n      options: [\n        { label: 'Default', value: 'Default' },\n        { label: 'Excel', value: 'Excel' },\n        { label: 'InformixUnload', value: 'InformixUnload' },\n        { label: 'InformixUnloadCsv', value: 'InformixUnloadCsv' },\n        { label: 'MongoDBCsv', value: 'MongoDBCsv' },\n        { label: 'MongoDBTsv', value: 'MongoDBTsv' },\n        { label: 'MySQL', value: 'MySQL' },\n        { label: 'Oracle', value: 'Oracle' },\n        { label: 'PostgreSQLCsv', value: 'PostgreSQLCsv' },\n        { label: 'PostgreSQLText', value: 'PostgreSQLText' },\n        { label: 'RFC4180', value: 'RFC4180' },\n        { label: 'TDF', value: 'TDF' },\n      ],\n      required: true,\n    },\n    {\n      name: 'allowDuplicateHeaderNames',\n      label: 'Allow Duplicate Header Names',\n      value: 'true',\n      boolean: true,\n      required: false,\n    },\n    {\n      name: 'allowMissingColumnNames',\n      label: 'Allow Missing Column Names',\n      value: 'true',\n      boolean: true,\n      required: false,\n    },\n    {\n      name: 'commentMarker',\n      label: 'Comment Marker',\n      value: '',\n      required: false,\n    },\n    {\n      name: 'delimiter',\n      label: 'Delimiter',\n      value: '',\n      required: false,\n    },\n    { name: 'escape', label: 'Escape', value: '', required: false },\n    {\n      name: 'firstRecordAsHeader',\n      label: 'First Record As Header',\n      value: 'true',\n      boolean: true,\n      required: false,\n    },\n    { name: 'headers', label: 'Headers', value: '', required: false },\n    {\n      name: 'ignoreEmptyLines',\n      label: 'Ignore Empty Lines',\n      value: 'true',\n      boolean: true,\n      required: false,\n    },\n    {\n      name: 'ignoreHeaderCase',\n      label: 'Ignore Header Case',\n      value: 'true',\n      boolean: true,\n      required: false,\n    },\n    {\n      name: 'ignoreSurroundingSpaces',\n      label: 'Ignore Surrounding Spaces',\n      value: 'true',\n      boolean: true,\n      required: false,\n    },\n    {\n      name: 'nullString',\n      label: 'Null String',\n      value: '',\n      required: false,\n    },\n    {\n      name: 'skipHeaderRecord',\n      label: 'Skip Header Record',\n      value: 'true',\n      boolean: true,\n      required: false,\n    },\n  ];\n}\n"],"names":["DataSourceType","CollectionType","FieldStatus","FieldType","DocumentType","InspectionType","DocumentDefaultName","Modifier","Multiplicity","MappingType","ValidationScope","ValidationStatus","AuditStatus","collectionTypes","ARRAY","LIST","MAP","NONE","constantTypes","propertyTypes","CommonUtil","removeItemFromArray","item","items","length","i","itemWasRemoved","splice","splitByString","inStr","splitMarker","splitLoc","splitLocEnd","fragment","splitMarkerLen","result","indexOf","substring","push","str2bytes","str","bytes","Uint8Array","charCodeAt","readFile","file","reader","Promise","resolve","onload","readAsText","readBinaryFile","fileBody","Int8Array","readAsArrayBuffer","writeFile","fileContent","fName","saveAs","toDisplayable","camelCaseString","displayableString","charAt","toUpperCase","index","chr","toLowerCase","extractDisplayPath","path","fieldWidth","MAX_PATH_WIDTH","segmentedPath","split","leaf","substr","sanitizeJSON","buffer","JSON","stringify","replace","toString","objectize","parse","EnumValue","Field","jsonType","uuid","uuidCounter","fieldHasUnmappedChild","field","isTerminal","partOfMapping","children","childField","hasUnmappedChildren","getFieldPaths","fields","paths","getFieldNames","name","getField","fieldPath","find","alphabetizeFields","fieldsByPath","fieldPaths","fieldKey","sort","expandToRoot","parent","this","collapsed","isPropertyOrConstant","docDef","showFields","parentField","getNameWithNamespace","namespaceAlias","isParentField","isCollection","isPrimitive","type","isStringField","enumeration","copy","Object","assign","documentField","copyFrom","that","getCollectionParentField","isInCollection","getCollectionCount","count","isSource","getCollectionType","isArray","getFieldLabel","showTypes","includePath","pathComps","isAttribute","startsWith","isProperty","value","PROPERTY","isConstant","CONSTANT","ErrorLevel","ErrorScope","ErrorType","NamespaceModel","getUnqualifiedNamespace","unqualifiedNamespace","ns","alias","getPrettyLabel","isTarget","uri","PaddingField","_isSource","classIdentifier","displayName","DocumentDefinition","getComplexField","complexFieldsByClassIdentifier","getEnumField","enumFieldsByClassIdentifier","getAllFields","allFields","fieldExists","targetField","targetFieldDocDefType","isFieldsExist","foundFields","getFields","getName","getNamespaceForAlias","namespaces","originalPath","currentParentPath","currentPathSection","populateChildren","getComplexFields","discoverAllComplexFields","getTerminalFields","terminalFields","initializeFromFields","JAVA","prepareComplexFields","populateFieldData","initialized","updateField","oldPath","addField","cachedField","rewriteFieldPath","pathSegments","slice","clearFields","getFieldIndex","removeField","targetIndex","oldFieldPath","updateFromMappings","mappingDefinition","partOfTransformation","getAllMappings","mapping","getMappedFieldForField","actions","newFieldKey","key","discoverComplexFields","hasOwnProperty","complexFields","status","concat","_type","DataMapperInitializationModel","DocumentInitializationModel","ConfigModel","setConstantPropertyDocs","getConfig","cfg","setConfig","initializePropertyDoc","propertyDoc","PROPERTIES","id","Math","floor","random","sourcePropertyDoc","targetPropertyDoc","constantDoc","CONSTANTS","addDocument","docInitModel","initModel","description","inspectionType","inspectionSource","inspectionResult","inspectionParameters","selectedRoot","XSD","collectionType","collectionClassName","sourceDocs","targetDocs","addDocuments","docModels","docDefs","getDocsWithoutPropertyDoc","getDocs","docs","clearDocs","mappingFiles","hasJavaDocuments","getAllDocs","getDocForIdentifier","documentId","d","getFirstXmlDoc","doc","XML","documentsAreLoaded","_showMappingPreview","show","ErrorInfo","init","_identifier","errorIdentifierCounter","Examples","ExpressionUpdatedEvent","node","offset","ExpressionNode","prefix","sequence","getUuid","TextNode","PREFIX","toText","toHTML","FieldNode","mappedField","metaStr","collectionContextPath","fieldParts","getMappedFieldByPath","_this2","getReferenceField","getMappedFieldForIndex","_ref","enumValues","enumIndexValue","textStr","referenceFields","_this$mapping$referen","titleAddendum","mappedFieldName","getIndexForMappedField","hasComplexField","fieldType","TransitionMode","TransitionDelimiter","ExpressionModel","Subject","expressionUpdatedSource","asObservable","generateInitialExpression","getUserMappedFields","forEach","f","_this3","appendFieldNode","getLastNodeIndex","_nodes","getLastNode","getNode","nodeId","n","setConfigModel","clearText","startOffset","endOffset","targetNode","cleanStr","lastNode","keyPos","updateCache","next","insertText","insertNodes","createNodesFromText","newNodes","insertPosition","last","updatedEvent","targetNodeIndex","pre","post","mergedTextNode","lastNewNodeIndex","lastAddedIndex","nodes","space","nextNodeIndex","nextNode","pop","removeToken","tokenPosition","removeNext","removed","mappingService","updateMappedField","targetFieldNode","newOffset","glue","undefined","targetString","clearToEnd","updateFieldReference","mappedFields","getReferenceMappedFields","fieldNodes","filter","includes","mfield","r","_this4","clear","textCache","expressionHTML","addConditionalExpressionNode","answer","text","position","collectionContextFieldNode","search","nodeMetaVal","fn","isNaN","Number","_collectionContextFie","_collectionContextFie2","parseInt","_fn$mappedField","_fn$mappedField$field","errorService","addError","message","level","ERROR","scope","MAPPING","INTERNAL","_hasComplexField","FieldActionArgument","STRING","FieldActionArgumentValue","FieldActionDefinition","ONE_TO_ONE","populateFieldAction","action","definition","argumentValues","arguments","arg","setArgumentValue","getArgumentForName","argument","FieldAction","create","instance","getArgumentValue","argumentName","argValue","newArgValue","DocumentInspectionModel","parseFieldFromDocument","WARN","APPLICATION","USER","parsedField","DocumentInspectionRequestModel","DocumentInspectionRequestOptions","CsvInspectionModel","CsvInspectionRequestModel","_this","isOnlineInspectionCapable","initCfg","baseCSVInspectionServiceUrl","object","parseResponse","responseJson","CsvInspectionResponse","extractCSVDocumentDefinitionFromInspectionResponse","CsvDocument","Error","extractCSVDocumentDefinition","body","errorMessage","errorOccurred","csvDocument","params","URLSearchParams","parseCSVFieldFromDocument","column","COMPLEX","csvFields","_csvComplexType$csvFi","csvField","_csvComplexType$csvFi2","CsvInspectionRequestOptions","JavaInspectionModel","JavaInspectionRequestModel","baseJavaInspectionServiceUrl","javaClass","ClassInspectionResponse","JavaClass","docIdentifier","className","lastIndexOf","rootField","valueOf","parseJavaFieldFromDocument","javaFields","javaField","javaEnumFields","_javaClass$javaEnumFi","javaEnumField","enumValue","parsedEnumValue","ordinal","_javaClass$javaFields","_javaClass$javaFields2","JavaInspectionRequestOptions","request","ClassInspectionRequest","JAVA_MODEL_PACKAGE_PREFIX","disablePrivateOnlyFields","disableProtectedOnlyFields","disablePublicOnlyFields","disablePublicGetterSetterFields","json","fieldNameExclusions","string","classNameExclusions","JsonInspectionModel","JsonInspectionRequestModel","baseJSONInspectionServiceUrl","JsonInspectionResponse","extractJSONDocumentDefinitionFromInspectionResponse","JsonDocument","extractJSONDocumentDefinition","jsonDocument","parseJSONFieldFromDocument","complex","jsonEnumFields","_complex$jsonEnumFiel","jsonEnumField","jsonFields","_complex$jsonFields","jsonField","JsonInspectionRequestOptions","JsonInspectionRequest","JSON_MODEL_PACKAGE_PREFIX","jsonData","XmlInspectionModel","XmlInspectionRequestModel","baseXMLInspectionServiceUrl","XmlInspectionResponse","extractXMLDocumentDefinitionFromInspectionResponse","XmlDocument","extractXMLDocumentDefinition","xmlDocument","xmlNamespaces","_xmlDocument$xmlNames","xmlNamespace","_xmlDocument$xmlNames2","serviceNS","locationUri","targetNamespace","isSelectedRootElement","parseXMLFieldFromDocument","xmlEnumFields","_complex$xmlEnumField","xmlEnumField","xmlFields","_complex$xmlFields","xmlField","XmlInspectionRequestOptions","XmlInspectionRequest","XML_MODEL_PACKAGE_PREFIX","xmlData","LookupTableEntry","LookupTable","Date","getTime","getInputOutputKey","sourceIdentifier","targetIdentifier","getEntryForSource","sourceValue","autocreate","lookupEntry","entry","counter","targetValue","TransitionDelimiterModel","delimiter","serializedValue","prettyName","actualDelimiter","SPACE","TransitionModel","initialize","delimiterModels","models","AMPERSAND","AT_SIGN","BACKSLASH","COLON","COMMA","DASH","EQUAL","HASH","PERIOD","PIPE","SEMICOLON","SLASH","UNDERSCORE","USER_DEFINED","delimiterToModel","model","getMappingModeName","mode","actionName","MANY_TO_ONE","ONE_TO_MANY","ENUM","FOR_EACH","EXPRESSION","getPrettyName","transitionFieldActionName","transitionFieldAction","lookupTableName","expression","_this$expression","isOneToManyMode","isOneToOneMode","isManyToOneMode","isForEachMode","isEnumerationMode","isExpressionMode","MappingDefinition","templateExists","templateText","addTable","table","tablesBySourceTargetKey","tablesByName","tables","getTableByName","getTableBySourceTarget","getTables","removeTableByName","iokey","includeActiveMapping","mappings","activeMapping","findMappingsForField","mappingsForField","m","isFieldMapped","removeMapping","transition","MappedField","sortMappedFieldsByPath","isPadField","removeAction","MappingModel","getFirstCollectionField","sourceFields","targetFields","isLookupMode","first","getMappedFields","unshift","mf","getUserFieldCount","userFieldCount","hasMappedField","isEmpty","isFullyMapped","addMappedField","removeMappedField","removeReferenceField","notifyMappingUpdated","docId","createReferenceField","_field$documentField","referenceFieldExists","referenceField","workingFields","resultFields","shift","getLastMappedField","names","hasFieldActions","getAllMappedFields","hasTransformation","getMappedTarget","mappedOutputField","_m$sourceFields$","_Pact","prototype","then","onFulfilled","onRejected","state","s","callback","_settle","v","e","o","pact","bind","observer","_isSettledPact","thenable","_iteratorSymbol","Symbol","iterator","_catch","recover","asyncIterator","FileName","FileType","DocumentInspectionUtil","fromDocumentDefinition","CSV","fromJavaProperties","simpleName","JAVA_CLASS","removeDocumentIfAlreadyExists","fromNonJavaProperties","documentType","existing","Guid","newGuid","c","LookupTableData","LookupTableUtil","populateMappingLookupTable","inputIdentifier","outputIdentifier","inputField","outputField","updateLookupTables","t","getFirstMappingForLookupTable","errorNoTable","_mapping$transition","getEnumerationValues","targetValues","_mapping$transition2","enumVals","sourceEnum","tableData","sourceEnumValue","targetEnumValues","selected","selectedTargetEnumValue","updateEnumerationValues","enumerationValues","_mapping$transition3","lte","MappingDigestUtil","generateMappingDigest","mappingJson","mappingDigest","exportMappings","exportMeta","exportBlockData","jsonBuffer","dataSourceType","MappingUtil","updateMappingsFromDocuments","updateMappedFieldsFromDocuments","mappedFieldIndex","mappingField","isPropertyField","isConstantField","constantField","userCreated","propMappingField","propertyField","fieldName","zeroBasedIndex","addPlaceholders","removeStaleMappings","sourceFieldPaths","targetSourcePaths","isMappingStale","updateDocumentNamespacesFromMappings","parsedDocs","parsedDoc","getDocById","identifier","_cfg$mappings","hasFieldAction","hasMappedCollection","MODEL_PACKAGE_PREFIX","MappingSerializer","serializeMappings","ignoreValue","jsonMappings","serializedFieldMapping","serializeFieldMapping","input","error","serializedLookupTables","serializeLookupTables","constantDescriptions","serializeConstants","sourcePropertyDescriptions","serializeProperties","targetPropertyDescriptions","AtlasMapping","dataSource","serializeDocuments","lookupTables","lookupTable","constants","constant","properties","property","jsonMapping","serializedInputFields","serializeFields","serializedOutputFields","mappingExpression","expressionService","getMappingExpressionStr","serializeAction","inputFieldGroup","mappingAction","_serializedInputField","serializedInputFieldGroup","_serializedInputField2","serializedFieldGroup0","serializedFieldGroupi","mappingType","LOOKUP","deserializeMappingServiceJSON","deserializeConstants","deserializeProperties","deserializeAtlasMappingName","deserializeDocs","deserializeMappings","deserializeLookupTables","_json$AtlasMapping","addInputFieldGroupFields","deserializeMappedField","deserializeFieldMapping","isLookupMapping","deserializeFieldMappingFromType","deserializeInputFieldGroup","enableExpression","_mappingJson$inputFie","_mappingJson$inputFie2","_TransitionModel$deli","firstAction","Expression","parsedAction","parseAction","fieldActionService","getActionDefinitionForName","deserializeAudits","audits","errorType","errors","audit","createInputFieldGroup","isComplex","serializedDocs","serializedDoc","SOURCE","TARGET","characterEncoding","locale","xmlDoc","template","jsonDoc","propertyDescriptions","serializedTables","lookupEntries","sourceType","targetType","processCollectionPreview","serializedField","fieldsJson","collectionInstanceInputFieldGroup","processActionArguments","actionArguments","isCustom","argumentConfig","collectionInputFieldGroup","_field$documentField$","attribute","documentService","getPropertyPath","includeIndexes","serializeActions","collectionParentField","actionJson","docRef","xmlDocRef","svcNS","createdByUser","_json$AtlasMapping$ma","fieldMapping","_jsonMapping$AtlasMap","_jsonMapping$AtlasMap2","_jsonMapping$AtlasMap3","_jsonMapping$AtlasMap4","parsedTable","parsedEntry","deserializeFieldActions","multiplicity","logger","warn","parseNewAction","parseOldAction","keys","actionParams","paramName","parsedArgumentValue","entries","valueString","DocumentManagementService","api","mappingUpdatedSubscription","mappingUpdated$","subscribe","uninitialize","unsubscribe","inspectDocuments","Observable","inspectionModel","inspectDocument","reject","debug","options","url","addBackendError","getLibraryClassNames","baseMappingServiceUrl","get","ArrayList","importNonJavaDocument","selectedFile","isSchema","docType","userFileSuffix","handleError","addNonJavaDocument","fileText","userFile","SCHEMA","INSTANCE","INFO","FileReader","clearValidationErrors","userFileComps","join","importJavaDocument","addJavaDocument","docBody","docName","parameters","doAddDocument","docdef","_this6","filterDocumentFields","searchFilter","searchIsEmpty","defaultVisibility","visibleInCurrentDocumentSearch","searchFieldCount","markChildrenVisible","MAX_SEARCH_MATCH","notifyLineRefresh","createConstant","constName","constValue","constType","addToActiveMapping","addFieldToActiveMapping","deleteConstant","removeFieldFromAllMappings","_this$cfg$mappings","_activeMapping$transi","editConstant","origName","getConstantType","getConstantTypeIndex","createProperty","propName","propType","propScope","deleteProperty","_this$cfg$mappings2","_activeMapping$transi2","editProperty","newName","newScope","getPropertyType","getPropertyTypeIndex","ErrorHandlerService","filterWith","store","FORM","formErrors","emitUpdatedEvent","getErrors","removeError","formErrorUpdatedSource","closed","excludeByIdentifier","resetAll","clearAllErrors","complete","clearPreviewErrors","PREVIEW","VALIDATION","clearFieldErrors","FIELD","clearFormErrors","errorUpdatedSource","createFormErrorChannel","isRequiredFieldValid","fieldDescription","FieldActionService","ZERO_TO_ONE","MANY_TO_MANY","Accept","fetchFieldActions","preloadedFieldActionMetadata","clearActionDefinitions","ActionDetails","actionDetail","fieldActionDefinition","extractFieldActionDefinition","info","sortFieldActionDefinitions","isInitialized","doFetchFieldActions","fetchedActionConfigs","values","arr","actionDef","getActionsAppliesToField","appliesToField","actionConfigs","headers","_body$ActionDetails","_body$ActionDetails$a","fieldActionConfig","trace","custom","method","serviceObject","actionSchema","propertyObject","argTypeString","argType","argumentDefinition","definitions","_this5","sortedActionDefinitions","defsByName","defNames","sameNamedDefs","selectedSourceField","getActualField","selectedTargetField","appliesToSourceField","appliesToTargetField","_","matchesDate","matchesNumeric","candidateType","selectedType","FileManagementService","findMappingFiles","StringMap","stringMapEntry","map","getCurrentMappingDigest","getCurrentFile","DIGEST","gzipped","gunzipped","inflate","stringified","reduce","data","byte","String","fromCharCode","admDigest","getCurrentADMArchive","ADM","fileName","fileType","arrayBuffer","byteLength","resetMappings","res","resetLibs","fileService","setMappingToService","atlasMappingContainer","setMappingStringToService","_this7","put","statusText","setMappingDigestToService","compressedBuffer","strBuffer","binBuffer","gzip","error1","_this8","Blob","setBinaryFileToService","setADMArchiveFileToService","_this9","importJarFile","binaryBuffer","_this10","JAR","jarUpdated","updateDigestFile","_this11","getCurrentMappingJson","exportADMArchive","mappingsFileName","_this12","value2","importADMArchive","admFile","_this13","fileBin","_this14","baseURL","_cfg","log","getLogger","MappingExpressionService","willClearOutSourceFieldsOnTogglingExpression","_this$cfg$mappings$ac","isExpressionEnabledForActiveMapping","_this$cfg$mappings2$a","_this$cfg$mappings2$a2","toggleExpressionMode","updateExpression","updateActiveMappingTransition","addFieldToExpression","newTextNode","atIndex","isTrailer","executeFieldSearch","configModel","formattedFields","documentName","fieldCount","formattedField","isFieldSelectable","asHTML","_this$cfg$mappings3","createMappingExpression","expr","sourceMappedFields","sourceMappedCollection","targetMappedFields","targetMappedCollection","fieldActionsToExpression","qualifiedExpressionRef","_mappedField$field2","_mappedField$field2$d","_mappedField$field3","fieldActionArgumentToExpression","actionArgument","actionArgType","fieldActionToExpression","mfActionIndex","actionArgIndex","MappingManagementService","lineRefreshSource","mappingUpdatedSource","mappingSelectionRequiredSource","fetchMappings","_mappingFiles","updateMappingsTransition","updateTransition","mappingModel","mappingWasRemoved","deselectMapping","removeAllMappings","moveMappedFieldTo","insertedMappedField","clearExtraPaddingFields","basePadIndex","padField","exclusionReason","getFieldSelectionExclusionReason","existingMappedField","addNewMapping","selectedField","compoundSelection","selectMapping","newMapping","showMappingDetailTray","removeDocumentReferenceFromAllMappings","validateMappings","payload","mappingDefinitionId","processValidationResponse","Validations","validation","validatedMapping","setTimeout","trailing","mField","setEnumFieldValue","enumerationField","enumerationValue","isEnumerationMapping","getLevel","levels","DEBUG","MappingPreviewService","mappingPreviewInputSource","mappingPreviewOutputSource","mappingPreviewErrorSource","enableMappingPreview","showMappingPreview","mappingPreviewInputSubscription","createMappingPreviewSubscription","createMappingUpdatedSubscription","mappingPreviewInput$","inputFieldMapping","hasValue","createPreviewRequestBody","processPreviewResponse","ProcessMappingRequest","ProcessMappingResponse","toWrite","toRead","_toRead$field","_toRead$field2","_toRead$mappingField","a","disableMappingPreview","mappedValueCleared","toggleMappingPreview","enabled","setDefaultLevel","InitializationService","systemInitializedSource","initializationStatusChangedSource","previewService","resetConfig","initializationService","updateLoadingStatus","updateStatus","initializeWithMappingDigest","mappingInitialized","runtimeServiceActive","getRuntimeVersion","addDocumentsFromMappingDigest","digestMappingsName","files","fragIndex","target","check","step","_cycle","done","_fixup","TypeError","array","_forTo","metaFragment","fragData","docID","documentCount","finishedDocCount","preloadedMappingJson","updateInitComplete","initializationErrorOccurred","loadingStatus","initializeWithADMArchiveFile","resetAtlasMap","label","required"],"mappings":"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"}