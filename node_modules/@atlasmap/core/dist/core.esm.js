import { saveAs } from 'file-saver';
import { Subject, Observable } from 'rxjs';
import { inflate, gzip } from 'pako';
import log from 'loglevel';

/*
    Copyright (C) 2017 Red Hat, Inc.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

            http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
*/
var FIELD_PATH_SEPARATOR = '/';
var MODEL_PACKAGE_PREFIX = 'io.atlasmap.v2';
var DATA_SOURCE_JSON_TYPE = MODEL_PACKAGE_PREFIX + '.DataSource';
/** SOURCE or TARGET. */

var DataSourceType;

(function (DataSourceType) {
  DataSourceType["SOURCE"] = "SOURCE";
  DataSourceType["TARGET"] = "TARGET";
})(DataSourceType || (DataSourceType = {}));
/**
 * The type of collection, such as {@link ARRAY} and {@link LIST}.
 */


var CollectionType;

(function (CollectionType) {
  CollectionType["ALL"] = "ALL";
  CollectionType["ARRAY"] = "ARRAY";
  CollectionType["LIST"] = "LIST";
  CollectionType["MAP"] = "MAP";
  CollectionType["NONE"] = "NONE";
})(CollectionType || (CollectionType = {}));
/**
 * The field status held by {@link IField}.
 */


var FieldStatus;

(function (FieldStatus) {
  FieldStatus["SUPPORTED"] = "SUPPORTED";
  FieldStatus["UNSUPPORTED"] = "UNSUPPORTED";
  FieldStatus["CACHED"] = "CACHED";
  FieldStatus["ERROR"] = "ERROR";
  FieldStatus["NOT_FOUND"] = "NOT_FOUND";
  FieldStatus["EXCLUDED"] = "EXCLUDED";
})(FieldStatus || (FieldStatus = {}));
/**
 * The field type held by {@link IField}.
 */


var FieldType;

(function (FieldType) {
  FieldType["ANY"] = "ANY";
  FieldType["ANY_DATE"] = "ANY_DATE";
  FieldType["BIG_INTEGER"] = "BIG_INTEGER";
  FieldType["BOOLEAN"] = "BOOLEAN";
  FieldType["BYTE"] = "BYTE";
  FieldType["BYTE_ARRAY"] = "BYTE_ARRAY";
  FieldType["CHAR"] = "CHAR";
  FieldType["COMPLEX"] = "COMPLEX";
  FieldType["DATE"] = "DATE";
  FieldType["DATE_TIME"] = "DATE_TIME";
  FieldType["DATE_TIME_TZ"] = "DATE_TIME_TZ";
  FieldType["DATE_TZ"] = "DATE_TZ";
  FieldType["DECIMAL"] = "DECIMAL";
  FieldType["DOUBLE"] = "DOUBLE";
  FieldType["FLOAT"] = "FLOAT";
  FieldType["INTEGER"] = "INTEGER";
  FieldType["LONG"] = "LONG";
  FieldType["NONE"] = "NONE";
  FieldType["NUMBER"] = "NUMBER";
  FieldType["SHORT"] = "SHORT";
  FieldType["STRING"] = "STRING";
  FieldType["TIME"] = "TIME";
  FieldType["TIME_TZ"] = "TIME_TZ";
  FieldType["UNSIGNED_BYTE"] = "UNSIGNED_BYTE";
  FieldType["UNSIGNED_INTEGER"] = "UNSIGNED_INTEGER";
  FieldType["UNSIGNED_LONG"] = "UNSIGNED_LONG";
  FieldType["UNSIGNED_SHORT"] = "UNSIGNED_SHORT";
  FieldType["UNSUPPORTED"] = "UNSUPPORTED";
})(FieldType || (FieldType = {}));

var DocumentType;

(function (DocumentType) {
  DocumentType["JAVA"] = "JAVA";
  DocumentType["XML"] = "XML";
  DocumentType["XSD"] = "XSD";
  DocumentType["JSON"] = "JSON";
  DocumentType["CORE"] = "Core";
  DocumentType["CSV"] = "CSV";
  DocumentType["CONSTANT"] = "Constants";
  DocumentType["PROPERTY"] = "Property";
})(DocumentType || (DocumentType = {}));

var InspectionType;

(function (InspectionType) {
  InspectionType["JAVA_CLASS"] = "JAVA_CLASS";
  InspectionType["SCHEMA"] = "SCHEMA";
  InspectionType["INSTANCE"] = "INSTANCE";
  InspectionType["UNKNOWN"] = "UNKNOWN";
})(InspectionType || (InspectionType = {}));

/*
    Copyright (C) 2017 Red Hat, Inc.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

            http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
*/
var DocumentDefaultName;

(function (DocumentDefaultName) {
  DocumentDefaultName["CONSTANTS"] = "Constants";
  DocumentDefaultName["PROPERTIES"] = "Properties";
})(DocumentDefaultName || (DocumentDefaultName = {}));

var collectionTypes = [[CollectionType[CollectionType.ARRAY], 'Array'], [CollectionType[CollectionType.LIST], 'List'], [CollectionType[CollectionType.MAP], 'Map'], [CollectionType[CollectionType.NONE], 'None']];
var constantTypes = [['STRING', 'String'], ['BOOLEAN', 'Boolean'], ['BIG_INTEGER', 'Big Integer'], ['BYTE', 'Byte'], ['BYTE_ARRAY', 'ByteArray'], ['CHAR', 'Char'], ['COMPLEX', 'Complex'], ['DECIMAL', 'Decimal'], ['DOUBLE', 'Double'], ['FLOAT', 'Float'], ['INTEGER', 'Integer'], ['LONG', 'Long'], ['SHORT', 'Short'], ['TIME', 'Time'], ['DATE', 'Date'], ['DATE_TIME', 'DateTime'], ['DATE_TZ', 'DateTZ'], ['TIME_TZ', 'TimeTZ'], ['DATE_TIME_TZ', 'DateTimeTZ'], ['UNSIGNED_BYTE', 'Unsigned Byte'], ['UNSIGNED_INTEGER', 'Unsigned Integer'], ['UNSIGNED_LONG', 'Unsigned Long'], ['UNSIGNED_SHORT', 'Unsigned Short']];
var propertyTypes = [['STRING', 'String'], ['ANY', 'Any'], ['BOOLEAN', 'Boolean'], ['BIG_INTEGER', 'Big Integer'], ['BYTE', 'Byte'], ['BYTE_ARRAY', 'ByteArray'], ['CHAR', 'Char'], ['COMPLEX', 'Complex'], ['DECIMAL', 'Decimal'], ['DOUBLE', 'Double'], ['FLOAT', 'Float'], ['INTEGER', 'Integer'], ['LONG', 'Long'], ['SHORT', 'Short'], ['TIME', 'Time'], ['DATE', 'Date'], ['DATE_TIME', 'DateTime'], ['DATE_TZ', 'DateTZ'], ['TIME_TZ', 'TimeTZ'], ['DATE_TIME_TZ', 'DateTimeTZ'], ['UNSIGNED_BYTE', 'Unsigned Byte'], ['UNSIGNED_INTEGER', 'Unsigned Integer'], ['UNSIGNED_LONG', 'Unsigned Long'], ['UNSIGNED_SHORT', 'Unsigned Short']];
var HTTP_STATUS_OK = 200;
var HTTP_STATUS_NO_CONTENT = 204;

/*
    Copyright (C) 2017 Red Hat, Inc.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

            http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
*/
// TODO: Retrieve from the backend CSV module
function getCsvParameterOptions() {
  return [{
    name: 'format',
    label: 'CSV File Format',
    value: 'Default',
    options: [{
      label: 'Default',
      value: 'Default'
    }, {
      label: 'Excel',
      value: 'Excel'
    }, {
      label: 'InformixUnload',
      value: 'InformixUnload'
    }, {
      label: 'InformixUnloadCsv',
      value: 'InformixUnloadCsv'
    }, {
      label: 'MongoDBCsv',
      value: 'MongoDBCsv'
    }, {
      label: 'MongoDBTsv',
      value: 'MongoDBTsv'
    }, {
      label: 'MySQL',
      value: 'MySQL'
    }, {
      label: 'Oracle',
      value: 'Oracle'
    }, {
      label: 'PostgreSQLCsv',
      value: 'PostgreSQLCsv'
    }, {
      label: 'PostgreSQLText',
      value: 'PostgreSQLText'
    }, {
      label: 'RFC4180',
      value: 'RFC4180'
    }, {
      label: 'TDF',
      value: 'TDF'
    }],
    required: true
  }, {
    name: 'allowDuplicateHeaderNames',
    label: 'Allow Duplicate Header Names',
    value: 'true',
    "boolean": true,
    required: false
  }, {
    name: 'allowMissingColumnNames',
    label: 'Allow Missing Column Names',
    value: 'true',
    "boolean": true,
    required: false
  }, {
    name: 'commentMarker',
    label: 'Comment Marker',
    value: '',
    required: false
  }, {
    name: 'delimiter',
    label: 'Delimiter',
    value: '',
    required: false
  }, {
    name: 'escape',
    label: 'Escape',
    value: '',
    required: false
  }, {
    name: 'firstRecordAsHeader',
    label: 'First Record As Header',
    value: 'true',
    "boolean": true,
    required: false
  }, {
    name: 'headers',
    label: 'Headers',
    value: '',
    required: false
  }, {
    name: 'ignoreEmptyLines',
    label: 'Ignore Empty Lines',
    value: 'true',
    "boolean": true,
    required: false
  }, {
    name: 'ignoreHeaderCase',
    label: 'Ignore Header Case',
    value: 'true',
    "boolean": true,
    required: false
  }, {
    name: 'ignoreSurroundingSpaces',
    label: 'Ignore Surrounding Spaces',
    value: 'true',
    "boolean": true,
    required: false
  }, {
    name: 'nullString',
    label: 'Null String',
    value: '',
    required: false
  }, {
    name: 'skipHeaderRecord',
    label: 'Skip Header Record',
    value: 'true',
    "boolean": true,
    required: false
  }];
}

/**
 * The Java class inspection data model contracts between frontend and backend.
 */
var JAVA_MODEL_PACKAGE_PREFIX = 'io.atlasmap.java.v2';
var JAVA_INSPECTION_REQUEST_JSON_TYPE = JAVA_MODEL_PACKAGE_PREFIX + '.ClassInspectionRequest';
var JAVA_CLASS_JSON_TYPE = JAVA_MODEL_PACKAGE_PREFIX + '.JavaClass';
var JAVA_ENUM_FIELD_JSON_TYPE = JAVA_MODEL_PACKAGE_PREFIX + '.JavaEnumField';
/**
 * The serialized Java modifier.
 */

var Modifier;

(function (Modifier) {
  Modifier["ALL"] = "ALL";
  Modifier["ABSTRACT"] = "ABSTRACT";
  Modifier["FINAL"] = "FINAL";
  Modifier["INTERFACE"] = "INTERFACE";
  Modifier["NATIVE"] = "NATIVE";
  Modifier["PACKAGE_PRIVATE"] = "Package Private";
  Modifier["PUBLIC"] = "PUBLIC";
  Modifier["PROTECTED"] = "PROTECTED";
  Modifier["PRIVATE"] = "PRIVATE";
  Modifier["STATIC"] = "STATIC";
  Modifier["STRICT"] = "STRICT";
  Modifier["SYNCHRONIZED"] = "SYNCHRONIZED";
  Modifier["TRANSIENT"] = "TRANSIENT";
  Modifier["VOLATILE"] = "VOLATILE";
  Modifier["NONE"] = "NONE";
})(Modifier || (Modifier = {}));

/*
    Copyright (C) 2017 Red Hat, Inc.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

            http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
*/

/**
 * The JSON inspection data model contracts between frontend and backend.
 */
var JSON_MODEL_PACKAGE_PREFIX = 'io.atlasmap.json.v2';
var JSON_DATA_SOURCE_JSON_TYPE = JSON_MODEL_PACKAGE_PREFIX + '.JsonDataSource';
var JSON_ENUM_FIELD_JSON_TYPE = JSON_MODEL_PACKAGE_PREFIX + '.JsonEnumField';
var JSON_INSPECTION_REQUEST_JSON_TYPE = JSON_MODEL_PACKAGE_PREFIX + '.JsonInspectionRequest';

/*
    Copyright (C) 2017 Red Hat, Inc.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

            http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
*/

/**
 * The XML inspection data model contracts between frontend and backend.
 */
var XML_MODEL_PACKAGE_PREFIX = 'io.atlasmap.xml.v2';
var XML_DATA_SOURCE_JSON_TYPE = XML_MODEL_PACKAGE_PREFIX + '.XmlDataSource';
var XML_ENUM_FIELD_JSON_TYPE = XML_MODEL_PACKAGE_PREFIX + '.XmlEnumField';
var XML_INSPECTION_REQUEST_JSON_TYPE = XML_MODEL_PACKAGE_PREFIX + '.XmlInspectionRequest';

/*
    Copyright (C) 2017 Red Hat, Inc.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

            http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
*/

/**
 * The multiplicity of the field action.
 */
var Multiplicity;

(function (Multiplicity) {
  Multiplicity["ONE_TO_ONE"] = "ONE_TO_ONE";
  Multiplicity["ONE_TO_MANY"] = "ONE_TO_MANY";
  Multiplicity["MANY_TO_ONE"] = "MANY_TO_ONE";
  Multiplicity["ZERO_TO_ONE"] = "ZERO_TO_ONE";
  Multiplicity["MANY_TO_MANY"] = "MANY_TO_MANY";
})(Multiplicity || (Multiplicity = {}));

/*
    Copyright (C) 2017 Red Hat, Inc.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

            http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
*/
/**
 * The mapping Data model contracts between frontend and backend.
 */

var ATLAS_MAPPING_JSON_TYPE = MODEL_PACKAGE_PREFIX + '.AtlasMapping';
var MAPPING_JSON_TYPE = MODEL_PACKAGE_PREFIX + '.Mapping';
var COLLECTION_JSON_TYPE = MODEL_PACKAGE_PREFIX + '.Collection';
var FIELD_GROUP_JSON_TYPE = MODEL_PACKAGE_PREFIX + '.FieldGroup';
var PROPERTY_FIELD_JSON_TYPE = MODEL_PACKAGE_PREFIX + '.PropertyField';
var CONSTANT_FIELD_JSON_TYPE = MODEL_PACKAGE_PREFIX + '.ConstantField';
/**
 * The mapping mode, such as {@link LOOKUP}, {@link COLLECTION}, etc.
 * @deprecated {@link COMBINE}, {@link MAP}, {@link SEPARATE}
 */

var MappingType;

(function (MappingType) {
  MappingType["ALL"] = "ALL";
  MappingType["COLLECTION"] = "COLLECTION";
  MappingType["COMBINE"] = "COMBINE";
  MappingType["LOOKUP"] = "LOOKUP";
  MappingType["MAP"] = "MAP";
  MappingType["SEPARATE"] = "SEPARATE";
  MappingType["NONE"] = "NONE";
})(MappingType || (MappingType = {}));
/**
 * The validation scope.
 */


var ValidationScope;

(function (ValidationScope) {
  ValidationScope["DATA_SOURCE"] = "DATA_SOURCE";
  ValidationScope["MAPPING"] = "MAPPING";
  ValidationScope["LOOKUP_TABLE"] = "LOOKUP_TABLE";
  ValidationScope["CONSTANT"] = "CONSTANT";
  ValidationScope["PROPERTY"] = "PROPERTY";
})(ValidationScope || (ValidationScope = {}));
/**
 * The validation status.
 */


var ValidationStatus;

(function (ValidationStatus) {
  ValidationStatus["INFO"] = "INFO";
  ValidationStatus["WARN"] = "WARN";
  ValidationStatus["ERROR"] = "ERROR";
})(ValidationStatus || (ValidationStatus = {}));

/**
 * The mapping Data model contracts between frontend and backend.
 */

var PROCESS_MAPPING_REQUEST_JSON_TYPE = MODEL_PACKAGE_PREFIX + '.ProcessMappingRequest';
var AuditStatus;

(function (AuditStatus) {
  AuditStatus["INFO"] = "INFO";
  AuditStatus["WARN"] = "WARN";
  AuditStatus["ERROR"] = "ERROR";
})(AuditStatus || (AuditStatus = {}));

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;

  _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (it) return (it = it.call(o)).next.bind(it);

  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
    if (it) o = it;
    var i = 0;
    return function () {
      if (i >= o.length) return {
        done: true
      };
      return {
        done: false,
        value: o[i++]
      };
    };
  }

  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

/*
    Copyright (C) 2017 Red Hat, Inc.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

            http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
*/
var CommonUtil = /*#__PURE__*/function () {
  function CommonUtil() {}

  CommonUtil.removeItemFromArray = function removeItemFromArray(item, items) {
    if (item == null || items == null || items.length === 0) {
      return false;
    }

    var i = 0;
    var itemWasRemoved = false;

    while (i < items.length) {
      if (items[i] === item) {
        items.splice(i, 1);
        itemWasRemoved = true;
      } else {
        i++;
      }
    }

    return itemWasRemoved;
  }
  /**
   * Split a source string by the specified substring into a string array.
   *
   * @param inStr
   * @param splitMarker
   */
  ;

  CommonUtil.splitByString = function splitByString(inStr, splitMarker) {
    var splitLoc = 0;
    var splitLocEnd = 0;
    var fragment = null;
    var splitMarkerLen = splitMarker.length;
    var result = [];

    if (inStr === null || inStr.length === 0 || splitMarker === null || splitMarkerLen === 0) {
      return [];
    }

    while (splitLoc !== -1) {
      splitLoc = inStr.indexOf(splitMarker);
      splitLocEnd = inStr.indexOf(splitMarker, splitLoc + 1);
      fragment = inStr.substring(splitLoc, splitLocEnd);
      result.push(fragment);
      inStr = inStr.substring(splitLocEnd + splitMarkerLen);
    }

    return result;
  }
  /**
   * Turn a string into a byte array.
   *
   * @param str
   */
  ;

  CommonUtil.str2bytes = function str2bytes(str) {
    var bytes = new Uint8Array(str.length);

    for (var i = 0; i < str.length; i++) {
      bytes[i] = str.charCodeAt(i);
    }

    return bytes;
  }
  /**
   * Asynchronously read from the specified file and return as a string.
   *
   * @param fileName
   * @param reader
   */
  ;

  CommonUtil.readFile = function readFile(file, reader) {
    try {
      return Promise.resolve(new Promise(function (resolve) {
        reader.onload = function () {
          var fileBody = reader.result;
          resolve(fileBody);
        };

        reader.readAsText(file);
      }));
    } catch (e) {
      return Promise.reject(e);
    }
  }
  /**
   *  Perform an asynchronous binary read of the specified file name with the specified reader object.
   *
   * @param fileName - file to read
   * @param reader - reader object
   */
  ;

  CommonUtil.readBinaryFile = function readBinaryFile(file, reader) {
    try {
      return Promise.resolve(new Promise(function (resolve) {
        reader.onload = function () {
          var fileBody = new Int8Array(reader.result);
          resolve(fileBody);
        };

        reader.readAsArrayBuffer(file);
      }));
    } catch (e) {
      return Promise.reject(e);
    }
  }
  /**
   * Asynchronously write the specified file content (Blob) to the specified file name.  It will appear
   * in the user's local Downloads directory (or equivalent).
   *
   * @param fileContent
   * @param fName
   */
  ;

  CommonUtil.writeFile = function writeFile(fileContent, fName) {
    try {
      return Promise.resolve(new Promise(function (resolve) {
        saveAs(fileContent, fName);
        resolve(true);
      }));
    } catch (e) {
      return Promise.reject(e);
    }
  }
  /**
   * Convert a camel-case string into human-readable form.
   *
   * @param camelCaseString
   */
  ;

  CommonUtil.toDisplayable = function toDisplayable(camelCaseString) {
    if (typeof camelCaseString === 'undefined' || !camelCaseString || camelCaseString.indexOf(' ') >= 0) {
      return camelCaseString;
    }

    var displayableString = camelCaseString.charAt(0).toUpperCase();

    for (var index = 1; index < camelCaseString.length; index++) {
      var chr = camelCaseString.charAt(index);

      if (chr !== chr.toLowerCase()) {
        displayableString += ' ';
      }

      displayableString += chr;
    }

    return displayableString;
  }
  /**
   * Return a string path that fits into the width provided.  Capture as much of the leaf
   * as possible, then as much of the beginning with the remaining space.
   *
   * @param path
   * @param fieldWidth
   */
  ;

  CommonUtil.extractDisplayPath = function extractDisplayPath(path, fieldWidth) {
    var MAX_PATH_WIDTH = fieldWidth - 4; // account for length of ellipsis

    if (!path || MAX_PATH_WIDTH <= 0) {
      return '';
    }

    if (path.length <= MAX_PATH_WIDTH) {
      return path;
    }

    var segmentedPath = path.split('/');
    var leaf = '/' + segmentedPath[segmentedPath.length - 1];

    if (leaf.length >= MAX_PATH_WIDTH) {
      return leaf.substr(0, MAX_PATH_WIDTH);
    }

    var delta = MAX_PATH_WIDTH - leaf.length;
    return path.substr(0, delta) + '...' + leaf;
  }
  /**
   * Use the JSON utility to translate the specified buffer into a JSON buffer - then replace any
   * non-ascii character encodings with unicode escape sequences.
   *
   * @param buffer
   */
  ;

  CommonUtil.sanitizeJSON = function sanitizeJSON(buffer) {
    var jsonBuffer = JSON.stringify(buffer);
    jsonBuffer = jsonBuffer.replace(/[\u007F-\uFFFF]/g, function (chr) {
      return "\\u" + ('0000' + chr.charCodeAt(0).toString(16)).substr(-4);
    });
    return jsonBuffer;
  }
  /**
   * Restrict JSON parsing to the document management service.
   *
   * @param buffer
   */
  ;

  CommonUtil.objectize = function objectize(buffer) {
    if (typeof buffer === 'string') {
      return JSON.parse(buffer);
    } else {
      return buffer;
    }
  };

  return CommonUtil;
}();

var EnumValue = function EnumValue() {};
var Field = /*#__PURE__*/function () {
  function Field() {
    // The field properties read from document inspection result.
    this.documentField = {
      jsonType: ''
    };
    this.partOfMapping = false;
    this.partOfTransformation = false;
    this.visibleInCurrentDocumentSearch = true;
    this.enumeration = false;
    this.enumValues = [];
    this.children = [];
    this.fieldDepth = 0;
    this.collapsed = true;
    this.hasUnmappedChildren = false;
    this.isCollection = false;
    this.isArray = false;
    this.isAttribute = false;
    this.isPrimitive = false;
    this.userCreated = false;
    this.uuid = Field.uuidCounter.toString();
    Field.uuidCounter++;
  }

  Field.fieldHasUnmappedChild = function fieldHasUnmappedChild(field) {
    if (field == null) {
      return false;
    }

    if (field.isTerminal()) {
      return field.partOfMapping === false;
    }

    for (var _iterator = _createForOfIteratorHelperLoose(field.children), _step; !(_step = _iterator()).done;) {
      var childField = _step.value;

      if (childField.hasUnmappedChildren || Field.fieldHasUnmappedChild(childField)) {
        return true;
      }
    }

    return false;
  };

  Field.getFieldPaths = function getFieldPaths(fields) {
    var paths = [];

    for (var _iterator2 = _createForOfIteratorHelperLoose(fields), _step2; !(_step2 = _iterator2()).done;) {
      var field = _step2.value;
      paths.push(field.path);
    }

    return paths;
  };

  Field.getFieldNames = function getFieldNames(fields) {
    var paths = [];

    for (var _iterator3 = _createForOfIteratorHelperLoose(fields), _step3; !(_step3 = _iterator3()).done;) {
      var field = _step3.value;
      paths.push(field.name);
    }

    return paths;
  };

  Field.getField = function getField(fieldPath, fields) {
    // TODO: check this non null operator
    return fields.find(function (field) {
      return fieldPath === field.path;
    });
  };

  Field.alphabetizeFields = function alphabetizeFields(fields) {
    var fieldsByPath = {};
    var fieldPaths = [];

    for (var _iterator4 = _createForOfIteratorHelperLoose(fields), _step4; !(_step4 = _iterator4()).done;) {
      var field = _step4.value;
      var fieldKey = field.path; // Discard duplicate field keys, field names are repeatable.

      if (fieldsByPath[fieldKey] != null) {
        continue;
      }

      fieldsByPath[fieldKey] = field;
      fieldPaths.push(fieldKey);
    }

    fieldPaths.sort();
    fields.length = 0;

    for (var _i = 0, _fieldPaths = fieldPaths; _i < _fieldPaths.length; _i++) {
      var path = _fieldPaths[_i];
      fields.push(fieldsByPath[path]);
    }

    for (var _iterator5 = _createForOfIteratorHelperLoose(fields), _step5; !(_step5 = _iterator5()).done;) {
      var _field = _step5.value;

      if (_field.children && _field.children.length) {
        this.alphabetizeFields(_field.children);
      }
    }
  }
  /**
   * Expand all fields above the current field.
   */
  ;

  var _proto = Field.prototype;

  _proto.expandToRoot = function expandToRoot() {
    var parent = this;

    while (parent != null) {
      parent.collapsed = false;

      if (parent.isPropertyOrConstant()) {
        if (parent.docDef) {
          parent.docDef.showFields = true;
        }
      }

      parent = parent.parentField;
    }
  };

  _proto.getNameWithNamespace = function getNameWithNamespace() {
    if (!this.namespaceAlias) {
      return this.name;
    }

    return this.namespaceAlias + ':' + this.name;
  };

  _proto.isParentField = function isParentField() {
    if (this.isCollection && !this.isPrimitive) {
      return true;
    }

    return this.type === 'COMPLEX';
  };

  _proto.isStringField = function isStringField() {
    return this.type === 'STRING';
  };

  _proto.isTerminal = function isTerminal() {
    if (this.enumeration) {
      return true;
    }

    if (this.isCollection && !this.isPrimitive) {
      return false;
    }

    return this.type !== 'COMPLEX';
  };

  _proto.copy = function copy() {
    var copy = new Field();
    Object.assign(copy, this); // make these pointers to the same object, not copies

    copy.documentField = this.documentField;
    copy.parentField = this.parentField;
    copy.docDef = this.docDef;
    copy.children = [];

    for (var _iterator6 = _createForOfIteratorHelperLoose(this.children), _step6; !(_step6 = _iterator6()).done;) {
      var childField = _step6.value;
      copy.children.push(childField.copy());
    } // console.log("Copied: " + this.name, { "src": this, "target": copy });


    return copy;
  };

  _proto.copyFrom = function copyFrom(that) {
    Object.assign(this, that); // make these pointers to the same object, not copies

    this.documentField = that.documentField;
    this.parentField = that.parentField;
    this.docDef = that.docDef;
    this.children = [];

    for (var _iterator7 = _createForOfIteratorHelperLoose(that.children), _step7; !(_step7 = _iterator7()).done;) {
      var childField = _step7.value;
      this.children.push(childField.copy());
    }
  } // @ts-ignore
  ;

  _proto.getCollectionParentField = function getCollectionParentField() {
    var parent = this;

    while (parent != null) {
      if (parent.isCollection) {
        return parent;
      }

      parent = parent.parentField;
    }
  };

  _proto.isInCollection = function isInCollection() {
    return this.getCollectionParentField() != null;
  };

  _proto.getCollectionCount = function getCollectionCount() {
    var count = 0;
    var field = this;

    while (field != null) {
      if (field.isCollection) {
        count++;
      }

      field = field.parentField;
    }

    return count;
  };

  _proto.isSource = function isSource() {
    return this.docDef != null && this.docDef.isSource;
  };

  _proto.getCollectionType = function getCollectionType() {
    return this.isCollection ? this.isArray ? 'ARRAY' : 'LIST' : null;
  };

  _proto.getFieldLabel = function getFieldLabel(showTypes, includePath) {
    var fieldPath = '';

    if (includePath) {
      fieldPath = this.path;
    } else {
      var pathComps = this.path.split(FIELD_PATH_SEPARATOR); // Check for a leaf path attribute field starting with '@'

      if (this.isAttribute && pathComps.length > 0 && pathComps[pathComps.length - 1].startsWith('@')) {
        fieldPath = this.path.split('@')[1];
      } else {
        fieldPath = this.getNameWithNamespace();
      }
    }

    if (showTypes && this.type && !this.isPropertyOrConstant()) {
      fieldPath += ' (' + this.type + ')';
    } else if (this.isProperty() && this.value != null) {
      fieldPath += ' = ' + this.value;

      if (showTypes && this.type) {
        fieldPath += ' (' + this.type + ')';
      }
    }

    if (!fieldPath && !this.parentField) {
      fieldPath = '< Document Root >';
    }

    return fieldPath;
  };

  _proto.isPropertyOrConstant = function isPropertyOrConstant() {
    return this.docDef == null ? false : this.docDef.isPropertyOrConstant;
  };

  _proto.isProperty = function isProperty() {
    return this.docDef == null ? false : this.docDef.type === DocumentType.PROPERTY;
  };

  _proto.isConstant = function isConstant() {
    return this.docDef == null ? false : this.docDef.type === DocumentType.CONSTANT;
  };

  return Field;
}();
Field.uuidCounter = 0;

var NamespaceModel = /*#__PURE__*/function () {
  function NamespaceModel() {
    this.createdByUser = false;
    this.isTarget = false;
  }

  NamespaceModel.getUnqualifiedNamespace = function getUnqualifiedNamespace() {
    if (NamespaceModel.unqualifiedNamespace == null) {
      var ns = new NamespaceModel();
      ns.alias = 'Unqualified';
      NamespaceModel.unqualifiedNamespace = ns;
    }

    return NamespaceModel.unqualifiedNamespace;
  };

  var _proto = NamespaceModel.prototype;

  _proto.getPrettyLabel = function getPrettyLabel() {
    if (this === NamespaceModel.getUnqualifiedNamespace()) {
      return this.alias;
    }

    return (this.isTarget ? 'Target' : this.alias) + ' [' + (this.uri == null ? 'NO URI' : this.uri) + ']';
  };

  _proto.copy = function copy() {
    var copy = new NamespaceModel();
    Object.assign(copy, this);
    return copy;
  };

  _proto.copyFrom = function copyFrom(that) {
    Object.assign(this, that);
  };

  return NamespaceModel;
}();
var PaddingField = /*#__PURE__*/function (_Field) {
  _inheritsLoose(PaddingField, _Field);

  function PaddingField(_isSource) {
    var _this;

    _this = _Field.call(this) || this;
    _this._isSource = _isSource;
    _this.name = '<padding field>';
    _this.classIdentifier = '<padding field>';
    _this.type = FieldType.NONE;
    _this.displayName = '<padding field>';
    _this.path = '';
    return _this;
  }

  var _proto2 = PaddingField.prototype;

  _proto2.isSource = function isSource() {
    return this._isSource;
  };

  return PaddingField;
}(Field);
var DocumentDefinition = /*#__PURE__*/function () {
  function DocumentDefinition() {
    this.LEFT_BRACKET = '\x5b';
    this.RIGHT_BRACKET = '\x5d';
    this.initialized = false;
    this.errorOccurred = false;
    this.fields = [];
    this.allFields = [];
    this.terminalFields = [];
    this.complexFieldsByClassIdentifier = {};
    this.enumFieldsByClassIdentifier = {};
    this.fieldsByPath = {};
    this.fieldPaths = [];
    this.showFields = true;
    this.visibleInCurrentDocumentSearch = true;
    this.namespaces = [];
  }

  var _proto3 = DocumentDefinition.prototype;

  _proto3.getComplexField = function getComplexField(classIdentifier) {
    return this.complexFieldsByClassIdentifier[classIdentifier];
  };

  _proto3.getEnumField = function getEnumField(classIdentifier) {
    return this.enumFieldsByClassIdentifier[classIdentifier];
  };

  _proto3.getAllFields = function getAllFields() {
    return [].concat(this.allFields);
  }
  /**
   * Return true if the specified field name already exists in the specified document definition,
   * false otherwise.
   *
   * @param targetField
   * @param targetFieldDocDefType
   */
  ;

  _proto3.fieldExists = function fieldExists(targetField, targetFieldDocDefType) {
    for (var _iterator = _createForOfIteratorHelperLoose(this.getAllFields()), _step; !(_step = _iterator()).done;) {
      var field = _step.value;

      if (field.name === targetField.name && field.docDef.type === targetFieldDocDefType) {
        return true;
      }
    }

    return false;
  };

  _proto3.isFieldsExist = function isFieldsExist(fields) {
    if (fields == null || fields.length === 0) {
      return true;
    }

    var foundFields = this.getFields(Field.getFieldPaths(fields));
    return foundFields != null && fields.length === foundFields.length;
  };

  _proto3.getFields = function getFields(fieldPaths) {
    var fields = [];

    for (var _iterator2 = _createForOfIteratorHelperLoose(fieldPaths), _step2; !(_step2 = _iterator2()).done;) {
      var fieldPath = _step2.value;
      var field = this.getField(fieldPath);

      if (field != null) {
        fields.push(field);
      }
    }

    return fields;
  };

  _proto3.getName = function getName(showTypes) {
    var name = this.name;

    if (showTypes && !this.isPropertyOrConstant) {
      var type = this.type;

      if (type) {
        name += ' (' + type + ')';
      }
    }

    return name;
  };

  _proto3.getNamespaceForAlias = function getNamespaceForAlias(alias) {
    // TODO: check this non null operator
    return this.namespaces.find(function (ns) {
      return alias === ns.alias;
    });
  };

  _proto3.getField = function getField(fieldPath) {
    if (!fieldPath) {
      return null;
    }

    var field = this.fieldsByPath[fieldPath]; // if we can't find the field we're looking for, find parent fields and populate their children

    var pathSeparator = FIELD_PATH_SEPARATOR;
    var originalPath = fieldPath; // strip beginning path separator from path

    if (originalPath != null && originalPath.indexOf(pathSeparator) === 0) {
      originalPath = originalPath.substring(1);
    }

    if (field == null && originalPath.indexOf(pathSeparator) !== -1) {
      var currentParentPath = '';

      while (originalPath.indexOf(pathSeparator) !== -1) {
        var currentPathSection = originalPath.substr(0, originalPath.indexOf(pathSeparator));
        currentParentPath += pathSeparator + currentPathSection;
        var parentField = this.fieldsByPath[currentParentPath];

        if (parentField == null) {
          if (originalPath.indexOf(pathSeparator) !== -1) {
            originalPath = originalPath.substr(originalPath.indexOf(pathSeparator) + 1);
            continue;
          } else {
            break;
          } // https://github.com/atlasmap/atlasmap/issues/1128
          // throw new Error('Could not populate parent field with path \''
          //  + currentParentPath + '\' (for: ' + fieldPath + ')');

        }

        this.populateChildren(parentField);

        if (originalPath.indexOf(pathSeparator) !== -1) {
          originalPath = originalPath.substr(originalPath.indexOf(pathSeparator) + 1);
        }
      }

      field = this.fieldsByPath[fieldPath];
    }

    return field;
  };

  _proto3.getComplexFields = function getComplexFields() {
    return this.discoverAllComplexFields(this.fields);
  };

  _proto3.getTerminalFields = function getTerminalFields() {
    return [].concat(this.terminalFields);
  };

  _proto3.initializeFromFields = function initializeFromFields() {
    if (this.type === DocumentType.JAVA) {
      this.prepareComplexFields();
    }

    Field.alphabetizeFields(this.fields);

    for (var _iterator3 = _createForOfIteratorHelperLoose(this.fields), _step3; !(_step3 = _iterator3()).done;) {
      var field = _step3.value;
      this.populateFieldData(field);
      this.allFields.push(field);
      this.populateChildren(field);
    }

    this.fieldPaths.sort();
    this.initialized = true;
  };

  _proto3.updateField = function updateField(field, oldPath) {
    Field.alphabetizeFields(this.fields);

    if (oldPath != null && oldPath.length > 0 && this.fieldsByPath[oldPath] != null) {
      delete this.fieldsByPath[oldPath];
      CommonUtil.removeItemFromArray(oldPath, this.fieldPaths);
    } else {
      CommonUtil.removeItemFromArray(field.path, this.fieldPaths);
    }

    this.populateFieldData(field);
    this.fieldPaths.sort();
  };

  _proto3.addField = function addField(field) {
    if (!field.parentField || this.isPropertyOrConstant) {
      this.fields.push(field);
      Field.alphabetizeFields(this.fields);
    } else {
      this.populateChildren(field.parentField);
      field.parentField.children.push(field);
      Field.alphabetizeFields(field.parentField.children);
    }

    this.populateFieldData(field);
    this.allFields.push(field);
    this.fieldPaths.sort();
  }
  /**
   * Return true if the passed field is terminal or children are detected, false otherwise.
   * @param field - target field
   */
  ;

  _proto3.populateChildren = function populateChildren(field) {
    // populate complex fields
    if (field.isTerminal() || field.children.length > 0) {
      return true;
    }

    var cachedField = this.getComplexField(field.classIdentifier);

    if (cachedField == null) {
      return false;
    } // copy cached field contents


    cachedField = cachedField.copy();

    for (var _iterator4 = _createForOfIteratorHelperLoose(cachedField.children), _step4; !(_step4 = _iterator4()).done;) {
      var childField = _step4.value;
      childField = childField.copy();
      childField.parentField = field;
      this.rewriteFieldPath(childField);
      this.populateFieldData(childField);
      field.children.push(childField);
    }

    if (field.children.length > 0) {
      this.fieldPaths.sort();
      return true;
    } else {
      return false;
    }
  };

  _proto3.rewriteFieldPath = function rewriteFieldPath(field) {
    var parent = field.parentField;
    var pathSegments = field.path.split(FIELD_PATH_SEPARATOR);
    field.path = parent.path + FIELD_PATH_SEPARATOR + pathSegments.slice(-1)[0];

    for (var _iterator5 = _createForOfIteratorHelperLoose(field.children), _step5; !(_step5 = _iterator5()).done;) {
      var child = _step5.value;
      this.rewriteFieldPath(child);
    }
  }
  /**
   * Clear all fields in this document.
   */
  ;

  _proto3.clearFields = function clearFields() {
    this.initialized = false;
    this.fields = [];
    this.allFields = [];
    this.terminalFields = [];
    this.fieldPaths = [];
    this.namespaces = [];
    this.fieldsByPath = {};
    this.complexFieldsByClassIdentifier = {};
    this.enumFieldsByClassIdentifier = {};
  };

  _proto3.getFieldIndex = function getFieldIndex(field, fields) {
    for (var i = 0; i < fields.length; i++) {
      if (fields[i].path === field.path) {
        return i;
      }
    }

    return -1;
  }
  /**
   * Remove the specified field from this document definition.
   *
   * @param field
   */
  ;

  _proto3.removeField = function removeField(field) {
    if (field == null) {
      return;
    }

    var targetIndex = this.getFieldIndex(field, this.fields);

    if (targetIndex > -1) {
      this.fields.splice(targetIndex, 1);
    }

    targetIndex = this.getFieldIndex(field, this.allFields);

    if (targetIndex > -1) {
      this.allFields.splice(targetIndex, 1);
    }

    targetIndex = this.getFieldIndex(field, this.terminalFields);

    if (targetIndex > -1) {
      this.terminalFields.splice(targetIndex, 1);
    }

    var oldFieldPath = field.path;
    CommonUtil.removeItemFromArray(oldFieldPath, this.fieldPaths);
    delete this.fieldsByPath[oldFieldPath];

    if (field.parentField != null) {
      CommonUtil.removeItemFromArray(field, field.parentField.children);
    }
  };

  _proto3.updateFromMappings = function updateFromMappings(mappingDefinition) {
    if (mappingDefinition === null) {
      return;
    }

    for (var _iterator6 = _createForOfIteratorHelperLoose(this.allFields), _step6; !(_step6 = _iterator6()).done;) {
      var field = _step6.value;
      field.partOfMapping = false;
      field.hasUnmappedChildren = false;
      field.partOfTransformation = false;
    } // FIXME: some of this work is happening N times for N source/target docs, should only happen once.


    for (var _iterator7 = _createForOfIteratorHelperLoose(mappingDefinition.getAllMappings(true)), _step7; !(_step7 = _iterator7()).done;) {
      var mapping = _step7.value;

      for (var _iterator9 = _createForOfIteratorHelperLoose(mapping.getAllFields()), _step9; !(_step9 = _iterator9()).done;) {
        var _field = _step9.value;
        var parentField = _field; // TODO: check this non null operator

        var partOfTransformation = mapping.getMappedFieldForField(_field).actions.length > 0;

        while (parentField != null) {
          parentField.partOfMapping = true;
          parentField.partOfTransformation = parentField.partOfTransformation || partOfTransformation;
          parentField = parentField.parentField;
        }
      }
    }

    for (var _iterator8 = _createForOfIteratorHelperLoose(this.allFields), _step8; !(_step8 = _iterator8()).done;) {
      var _field2 = _step8.value;
      _field2.hasUnmappedChildren = Field.fieldHasUnmappedChild(_field2);
    }
  };

  _proto3.populateFieldData = function populateFieldData(field) {
    field.docDef = this;
    var newFieldKey = field.path;
    this.fieldPaths.push(newFieldKey);
    this.fieldsByPath[newFieldKey] = field;

    if (field.enumeration) {
      this.enumFieldsByClassIdentifier[field.classIdentifier] = field;
    }

    if (field.isTerminal()) {
      this.terminalFields.push(field);
    } else {
      for (var _iterator10 = _createForOfIteratorHelperLoose(field.children), _step10; !(_step10 = _iterator10()).done;) {
        var childField = _step10.value;
        this.populateFieldData(childField);
        this.allFields.push(childField);
      }
    }
  };

  _proto3.prepareComplexFields = function prepareComplexFields() {
    var fields = this.fields; // build complex field cache

    this.discoverComplexFields(fields);

    for (var key in this.complexFieldsByClassIdentifier) {
      if (!this.complexFieldsByClassIdentifier.hasOwnProperty(key)) {
        continue;
      }

      var cachedField = this.complexFieldsByClassIdentifier[key]; // remove children more than one level deep in cached fields

      for (var _iterator11 = _createForOfIteratorHelperLoose(cachedField.children), _step11; !(_step11 = _iterator11()).done;) {
        var childField = _step11.value;
        childField.children = [];
      } // alphabetize complex field's childrein


      Field.alphabetizeFields(cachedField.children);
    }
  };

  _proto3.discoverAllComplexFields = function discoverAllComplexFields(fields) {
    var complexFields = [];

    for (var _iterator12 = _createForOfIteratorHelperLoose(fields), _step12; !(_step12 = _iterator12()).done;) {
      var field = _step12.value;

      if (field.type === 'COMPLEX' && (field.documentField.status === 'SUPPORTED' || field.documentField.status === 'CACHED')) {
        complexFields.push(field.copy());
      }

      if (field.children) {
        complexFields = complexFields.concat(this.discoverAllComplexFields(field.children));
      }
    }

    return complexFields;
  };

  _proto3.discoverComplexFields = function discoverComplexFields(fields) {
    for (var _iterator13 = _createForOfIteratorHelperLoose(fields), _step13; !(_step13 = _iterator13()).done;) {
      var field = _step13.value;

      if (field.type !== 'COMPLEX') {
        continue;
      }

      if (field.documentField.status === 'SUPPORTED') {
        this.complexFieldsByClassIdentifier[field.classIdentifier] = field.copy();
      }

      if (field.children) {
        this.discoverComplexFields(field.children);
      }
    }
  };

  _createClass(DocumentDefinition, [{
    key: "type",
    get: function get() {
      return this._type;
    },
    set: function set(type) {
      this._type = type;
      this.isPropertyOrConstant = type === DocumentType.CONSTANT || type === DocumentType.PROPERTY;
    }
  }]);

  return DocumentDefinition;
}();

var DataMapperInitializationModel = function DataMapperInitializationModel() {
  this.dataMapperVersion = '0.9.2017.07.28';
  this.initialized = false;
  this.loadingStatus = 'Loading.';
  this.admHttpTimeout = 30000; // 30 seconds

  this.initializationErrorOccurred = false;
  /* class path fetching configuration */

  this.classPathFetchTimeoutInMilliseconds = 30000;
  /* inspection service filtering flags */

  this.fieldNameExclusions = [];
  this.classNameExclusions = [];
  this.disablePrivateOnlyFields = false;
  this.disableProtectedOnlyFields = false;
  this.disablePublicOnlyFields = false;
  this.disablePublicGetterSetterFields = false;
  this.disableMappingPreviewMode = false;
  /* enable the navigation bar and import/export */

  this.disableNavbar = true;
  this.mappingInitialized = false;
};
var DocumentInitializationModel = function DocumentInitializationModel() {
  this.showFields = true;
};
/**
 * The central store of the AtlasMap UI core library. It is expected to be initialized through
 * {@link InitializationService}.
 */

var ConfigModel = /*#__PURE__*/function () {
  function ConfigModel() {
    this.initCfg = new DataMapperInitializationModel();
    /* current ui state config */

    this.showMappingDetailTray = false;
    this.showMappingTable = false;
    this.showNamespaceTable = false;
    this.showLinesAlways = true;
    this.showTypes = false;
    this.showMappedFields = true;
    this.showUnmappedFields = true;
    this._showMappingPreview = false;
    this.currentDraggedField = null;
    this.sourceDocs = [];
    this.targetDocs = [];
    this.sourcePropertyDoc = new DocumentDefinition();
    this.targetPropertyDoc = new DocumentDefinition();
    this.constantDoc = new DocumentDefinition();
    this.mappingFiles = [];
    this.mappingDefinitionId = 0;
    this.mappings = null;
    this.preloadedMappingJson = null;
    this.setConstantPropertyDocs();
  }

  ConfigModel.getConfig = function getConfig() {
    return ConfigModel.cfg;
  };

  ConfigModel.setConfig = function setConfig(cfg) {
    ConfigModel.cfg = cfg;
  };

  var _proto = ConfigModel.prototype;

  _proto.initializePropertyDoc = function initializePropertyDoc(propertyDoc, isSource) {
    propertyDoc.clearFields();
    propertyDoc.type = DocumentType.PROPERTY;
    propertyDoc.name = DocumentDefaultName.PROPERTIES;
    propertyDoc.id = 'DOC.' + propertyDoc.name + '.' + Math.floor(Math.random() * 1000000 + 1).toString();
    propertyDoc.isSource = isSource;
    propertyDoc.showFields = false;
    propertyDoc.isPropertyOrConstant = true;
  };

  _proto.setConstantPropertyDocs = function setConstantPropertyDocs() {
    this.initializePropertyDoc(this.sourcePropertyDoc, true);
    this.initializePropertyDoc(this.targetPropertyDoc, false);
    this.constantDoc.clearFields();
    this.constantDoc.type = DocumentType.CONSTANT;
    this.constantDoc.name = DocumentDefaultName.CONSTANTS;
    this.constantDoc.id = 'DOC.' + this.constantDoc.name + '.' + Math.floor(Math.random() * 1000000 + 1).toString();
    this.constantDoc.isSource = true;
    this.constantDoc.showFields = false;
    this.constantDoc.isPropertyOrConstant = true;
  };

  _proto.addDocument = function addDocument(docInitModel) {
    var docDef = new DocumentDefinition();
    docDef.initModel = docInitModel;
    docDef.id = docInitModel.id;
    docDef.type = docInitModel.type;
    docDef.name = docInitModel.name;
    docDef.description = docInitModel.description;
    docDef.isSource = docInitModel.isSource;
    docDef.showFields = docInitModel.showFields;
    docDef.inspectionType = docInitModel.inspectionType;
    docDef.inspectionSource = docInitModel.inspectionSource;
    docDef.inspectionResult = docInitModel.inspectionResult;
    docDef.inspectionParameters = docInitModel.inspectionParameters;
    docDef.selectedRoot = docInitModel.selectedRoot;

    if (docDef.type === DocumentType.XSD) {
      docDef.uri = 'atlas:xml:' + docDef.id;
    } else if (docDef.type === DocumentType.JAVA) {
      docDef.uri = "atlas:java:" + docDef.id + "?className=" + docDef.inspectionSource;

      if (docInitModel.collectionType && docInitModel.collectionType !== CollectionType.NONE) {
        docDef.uri += '&collectionType=' + docInitModel.collectionType;

        if (docInitModel.collectionClassName) {
          docDef.uri += '&collectionClassName=' + docInitModel.collectionClassName;
        }
      }
    } else {
      docDef.uri = 'atlas:' + docDef.type.toLowerCase() + ':' + docDef.id;
    }

    if (docInitModel.isSource) {
      this.sourceDocs.push(docDef);
    } else {
      this.targetDocs.push(docDef);
    }

    return docDef;
  };

  _proto.addDocuments = function addDocuments(docModels) {
    var docDefs = [];

    for (var _iterator = _createForOfIteratorHelperLoose(docModels), _step; !(_step = _iterator()).done;) {
      var docModel = _step.value;
      docDefs.push(this.addDocument(docModel));
    }

    return docDefs;
  };

  _proto.getDocsWithoutPropertyDoc = function getDocsWithoutPropertyDoc(isSource) {
    return isSource ? [].concat(this.sourceDocs) : [].concat(this.targetDocs);
  };

  _proto.getDocs = function getDocs(isSource) {
    var docs = this.getDocsWithoutPropertyDoc(isSource);
    return isSource ? [this.sourcePropertyDoc, this.constantDoc].concat(docs) : [this.targetPropertyDoc].concat(docs);
  }
  /**
   * Clear source/target/mapping documents from the model.  Reset constant and property document definitions.
   */
  ;

  _proto.clearDocs = function clearDocs() {
    this.sourceDocs = [];
    this.targetDocs = [];
    this.sourcePropertyDoc.clearFields();
    this.targetPropertyDoc.clearFields();
    this.constantDoc.clearFields();
    this.mappingFiles = [];
  };

  _proto.hasJavaDocuments = function hasJavaDocuments() {
    for (var _iterator2 = _createForOfIteratorHelperLoose(this.getAllDocs()), _step2; !(_step2 = _iterator2()).done;) {
      var doc = _step2.value;

      if (doc.type === DocumentType.JAVA) {
        return true;
      }
    }

    return false;
  };

  _proto.getDocForIdentifier = function getDocForIdentifier(documentId, isSource) {
    // TODO: check this non null operator
    return this.getDocs(isSource).find(function (d) {
      return d.id === documentId;
    });
  };

  _proto.getFirstXmlDoc = function getFirstXmlDoc(isSource) {
    var docs = this.getDocsWithoutPropertyDoc(isSource); // TODO: check this non null operator

    return docs.find(function (doc) {
      return doc.type === DocumentType.XML;
    });
  };

  _proto.getAllDocs = function getAllDocs() {
    return [this.sourcePropertyDoc, this.constantDoc].concat(this.sourceDocs).concat(this.targetPropertyDoc).concat(this.targetDocs);
  };

  _proto.documentsAreLoaded = function documentsAreLoaded() {
    for (var _iterator3 = _createForOfIteratorHelperLoose(this.getAllDocs()), _step3; !(_step3 = _iterator3()).done;) {
      var doc = _step3.value;

      if (!doc.initialized) {
        return false;
      }
    }

    return true;
  };

  _createClass(ConfigModel, [{
    key: "showMappingPreview",
    get: function get() {
      return this._showMappingPreview;
    },
    set: function set(show) {
      this._showMappingPreview = show;
    }
  }]);

  return ConfigModel;
}();
ConfigModel.cfg = /*#__PURE__*/new ConfigModel();

/*
    Copyright (C) 2017 Red Hat, Inc.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

            http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
*/
var ErrorLevel;

(function (ErrorLevel) {
  ErrorLevel["DEBUG"] = "DEBUG";
  ErrorLevel["INFO"] = "INFO";
  ErrorLevel["WARN"] = "WARN";
  ErrorLevel["ERROR"] = "ERROR";
})(ErrorLevel || (ErrorLevel = {}));

var ErrorScope;

(function (ErrorScope) {
  ErrorScope["APPLICATION"] = "APPLICATION";
  ErrorScope["DATA_SOURCE"] = "DATA_SOURCE";
  ErrorScope["LOOKUP_TABLE"] = "LOOKUP_TABLE";
  ErrorScope["MAPPING"] = "MAPPING";
  ErrorScope["FIELD"] = "FIELD";
  ErrorScope["FORM"] = "FORM";
  ErrorScope["CONSTANT"] = "CONSTANT";
  ErrorScope["PROPERTY"] = "PROPERTY";
})(ErrorScope || (ErrorScope = {}));

var ErrorType;

(function (ErrorType) {
  ErrorType["INTERNAL"] = "INTERNAL";
  ErrorType["USER"] = "USER";
  ErrorType["VALIDATION"] = "VALIDATION";
  ErrorType["PREVIEW"] = "PREVIEW";
  ErrorType["FORM"] = "FORM";
})(ErrorType || (ErrorType = {}));

var ErrorInfo = /*#__PURE__*/function () {
  function ErrorInfo(init) {
    this._identifier = ErrorInfo.errorIdentifierCounter.toString();
    ErrorInfo.errorIdentifierCounter++;
    Object.assign(this, init);
  }

  _createClass(ErrorInfo, [{
    key: "identifier",
    get: function get() {
      return this._identifier;
    }
  }]);

  return ErrorInfo;
}();
ErrorInfo.errorIdentifierCounter = 0;

/*
    Copyright (C) 2017 Red Hat, Inc.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

            http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
*/
var Examples = function Examples() {};
Examples.pom = "\n    <project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n        xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n        xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n\n        <modelVersion>4.0.0</modelVersion>\n        <groupId>foo.bar</groupId>\n        <artifactId>test.model</artifactId>\n        <version>1.10.0</version>\n        <packaging>jar</packaging>\n        <name>Test :: Model</name>\n\n        <dependencies>\n            <dependency>\n                <groupId>com.fasterxml.jackson.core</groupId>\n                <artifactId>jackson-annotations</artifactId>\n                <version>2.8.5</version>\n            </dependency>\n            <dependency>\n                <groupId>com.fasterxml.jackson.core</groupId>\n                <artifactId>jackson-databind</artifactId>\n                <version>2.8.5</version>\n            </dependency>\n            <dependency>\n                <groupId>com.fasterxml.jackson.core</groupId>\n                <artifactId>jackson-core</artifactId>\n                <version>2.8.5</version>\n            </dependency>\n        </dependencies>\n    </project>\n  ";

var ExpressionUpdatedEvent = function ExpressionUpdatedEvent(node, offset) {
  this.node = node;
  this.offset = offset;
};
var ExpressionNode = /*#__PURE__*/function () {
  function ExpressionNode(prefix) {
    this.uuid = prefix + ExpressionNode.sequence++;
  }

  var _proto = ExpressionNode.prototype;

  _proto.getUuid = function getUuid() {
    return this.uuid;
  };

  return ExpressionNode;
}();
ExpressionNode.sequence = 0;
var TextNode = /*#__PURE__*/function (_ExpressionNode) {
  _inheritsLoose(TextNode, _ExpressionNode);

  function TextNode(str) {
    var _this;

    _this = _ExpressionNode.call(this, TextNode.PREFIX) || this;
    _this.str = str;
    return _this;
  }

  var _proto2 = TextNode.prototype;

  _proto2.toText = function toText() {
    return this.str;
  };

  _proto2.toHTML = function toHTML() {
    return "<span id=\"" + this.uuid + "\">" + this.str.replace(/ /g, '&nbsp;') + "</span>";
  };

  return TextNode;
}(ExpressionNode);
TextNode.PREFIX = 'expression-text-';
var FieldNode = /*#__PURE__*/function (_ExpressionNode2) {
  _inheritsLoose(FieldNode, _ExpressionNode2);

  function FieldNode(mapping, mappedField, metaStr, index, collectionContextPath) {
    var _this2;

    if (index === void 0) {
      index = 0;
    }

    _this2 = _ExpressionNode2.call(this, FieldNode.PREFIX) || this;
    _this2.mapping = mapping;
    _this2.mappedField = mappedField;
    _this2.metaStr = metaStr;
    _this2.collectionContextPath = collectionContextPath;

    if (!mappedField) {
      if (metaStr) {
        var fieldParts = metaStr.split(':'); // Relative paths will not have the full field path in the meta data.

        if (fieldParts.length === 1) {
          if (collectionContextPath) {
            _this2.mappedField = mapping.getMappedFieldByPath(collectionContextPath + fieldParts[0], true);
          } else {
            _this2.mappedField = mapping.getMappedFieldByPath(fieldParts[0], true);
          }
        } else {
          _this2.mappedField = mapping.getMappedFieldByPath(fieldParts[1], true, fieldParts[0]);
        }

        if (!_this2.mappedField) {
          _this2.mappedField = mapping.getReferenceField(fieldParts[0], fieldParts[1]);
        }
      } else {
        var _ref;

        _this2.mappedField = mapping.getMappedFieldForIndex((_ref = index + 1) === null || _ref === void 0 ? void 0 : _ref.toString(), true);
      }

      mappedField = _this2.mappedField;
    }

    return _this2;
  }

  var _proto3 = FieldNode.prototype;

  _proto3.toText = function toText() {
    if (!this.mappedField || !this.mappedField.field) {
      return '';
    }

    if (this.mappedField.field.enumeration) {
      // Convert enumeration field/index pairs into a string literal.
      var enumIdxVal = this.mappedField.field.enumIndexValue ? this.mappedField.field.enumIndexValue : 0;
      return '"' + this.mappedField.field.enumValues[enumIdxVal].name + '"';
    } else {
      var _this$mapping$referen;

      var textStr = '${'; // If the mapped field's parent is a complex reference field then only use the leaf.

      if (this.mappedField.field.parentField && this.mappedField.field.parentField === ((_this$mapping$referen = this.mapping.referenceFields[0]) === null || _this$mapping$referen === void 0 ? void 0 : _this$mapping$referen.field)) {
        textStr += '/' + this.mappedField.field.name + '}';
      } else {
        textStr += this.mappedField.field.docDef.id + ':' + this.mappedField.field.path + '}';
      }

      return textStr;
    }
  };

  _proto3.toHTML = function toHTML() {
    if (this.mappedField && this.mappedField.field) {
      var titleAddendum = '';
      var mappedFieldName = this.mappedField.field.name;

      if (this.mappedField.field.enumeration) {
        var enumIdxVal = this.mappedField.field.enumIndexValue ? this.mappedField.field.enumIndexValue : 0;
        mappedFieldName += '.' + this.mappedField.field.enumValues[enumIdxVal].name;
        titleAddendum = ':  Click to select an enumeration value.';
      }

      return "<span style=\"font-weight:bold\" contenteditable=\"false\" id=\"" + this.uuid + "\" title=\"" + this.mappedField.field.docDef.name + ":" + this.mappedField.field.path + titleAddendum + "\"\n        class=\"expressionFieldLabel label label-default\">" + mappedFieldName + "</span>";
    } else {
      // TODO: check this non null operator
      return "<span contenteditable=\"false\" id=\"" + this.uuid + "\"\n        title=\"Field index '" + (this.mapping.getIndexForMappedField(this.mappedField) - 1) + "' is not available\"\n        class=\"expressionFieldLabel label label-danger\">N/A</span>";
    }
  };

  _proto3.hasComplexField = function hasComplexField() {
    var _this$mappedField, _this$mappedField$fie, _this$mappedField2, _this$mappedField2$fi, _this$mappedField3, _this$mappedField3$fi;

    return ((_this$mappedField = this.mappedField) === null || _this$mappedField === void 0 ? void 0 : (_this$mappedField$fie = _this$mappedField.field) === null || _this$mappedField$fie === void 0 ? void 0 : _this$mappedField$fie.documentField.fieldType) === 'COMPLEX' && (((_this$mappedField2 = this.mappedField) === null || _this$mappedField2 === void 0 ? void 0 : (_this$mappedField2$fi = _this$mappedField2.field) === null || _this$mappedField2$fi === void 0 ? void 0 : _this$mappedField2$fi.documentField.status) === 'SUPPORTED' || ((_this$mappedField3 = this.mappedField) === null || _this$mappedField3 === void 0 ? void 0 : (_this$mappedField3$fi = _this$mappedField3.field) === null || _this$mappedField3$fi === void 0 ? void 0 : _this$mappedField3$fi.documentField.status) === 'CACHED');
  };

  return FieldNode;
}(ExpressionNode);
FieldNode.PREFIX = 'expression-field-';
var ExpressionModel = /*#__PURE__*/function () {
  function ExpressionModel(mapping, cfg) {
    this.mapping = mapping;
    this.cfg = cfg;
    this.expressionHTML = '';
    this.expressionUpdatedSource = new Subject();
    this.expressionUpdated$ = this.expressionUpdatedSource.asObservable();
    this._nodes = [];
    this.textCache = '';
  }

  var _proto4 = ExpressionModel.prototype;

  _proto4.generateInitialExpression = function generateInitialExpression() {
    var _this3 = this;

    this.mapping.getUserMappedFields(true).forEach(function (f) {
      return _this3.appendFieldNode(f);
    });
  };

  _proto4.getLastNodeIndex = function getLastNodeIndex() {
    return this._nodes.length - 1;
  };

  _proto4.getLastNode = function getLastNode() {
    return this._nodes[this.getLastNodeIndex()];
  };

  _proto4.getNode = function getNode(nodeId) {
    if (!nodeId) {
      return this.getLastNode();
    }

    return this._nodes.find(function (n) {
      return n.getUuid() === nodeId;
    });
  };

  _proto4.setConfigModel = function setConfigModel(cfg) {
    this.cfg = cfg;
  }
  /**
   * Clear all text from the specified TextNode offset range or from the '@' to
   * the end of the text node if no node ID is specified.
   *
   * Return the new UUID position indicator string or null.
   *
   * @param nodeId
   * @param startOffset
   * @param endOffset
   */
  ;

  _proto4.clearText = function clearText(nodeId, startOffset, endOffset) {
    var targetNode = null;

    if (!nodeId) {
      var lastNode = this.getLastNode();

      if (!(lastNode instanceof TextNode)) {
        return null;
      }

      var keyPos = lastNode.str.indexOf('@');

      if (keyPos !== -1) {
        targetNode = lastNode;
        targetNode.str = targetNode.str.substring(0, keyPos);
      }
    } else {
      var node = this._nodes.find(function (n) {
        return n.getUuid() === nodeId;
      });

      if (!(node instanceof TextNode) || !endOffset) {
        return null;
      }

      targetNode = node; // TODO: check this non null operator

      var cleanStr = targetNode.str.replace(targetNode.str.substring(startOffset, endOffset), '');
      targetNode.str = cleanStr;
    }

    this.updateCache();
    this.expressionUpdatedSource.next();
    return targetNode;
  }
  /**
   * Insert text into expression at specified position. If nodeId is not specified,
   * it will be added to the end of expression. It parses the string
   * and insert a set of TextNode & FieldNode if it contains field reference like ${0},
   * otherwise just one TextNode.
   * This emits ExpressionUpdatedEvent which contains the latest node and offset it
   * worked on, so that the subscriber can determine where to put the caret in
   * the expression input widget. If ExpressionUpdatedEvent is undefined, it means that
   * it worked on the end of the expression.
   * @param str string to insert
   * @param nodeId target node to insert the string
   * @param offset position offset in the target node to insert the string
   */
  ;

  _proto4.insertText = function insertText(str, nodeId, offset) {
    this.insertNodes(this.createNodesFromText(str), nodeId, offset);
  }
  /**
   * Insert an array of ExpressionNodes at the specified position. If insertPosition is
   * not specified the nodes will be appended to the end of the expression.
   * This emits an ExpressionUpdatedEvent which contains the latest node and offset it
   * worked on, so that the subscriber can determine where to put the caret in
   * the expression input widget. If ExpressionUpdatedEvent is undefined, it means that
   * it worked on the end of the expression.
   *
   * @param newNodes an array of ExpressionNode to add
   * @param insertPosition target node to insert the string
   * @param offset position offset in the target node to insert the string
   */
  ;

  _proto4.insertNodes = function insertNodes(newNodes, insertPosition, offset) {
    // No position was specified - append to the end
    if (!insertPosition) {
      var last = this.getLastNode();

      if (!last) {
        var _this$_nodes;

        (_this$_nodes = this._nodes).push.apply(_this$_nodes, newNodes);
      } else if (last instanceof TextNode && newNodes[0] instanceof TextNode) {
        var _this$_nodes2;

        last.str += newNodes[0].str;
        newNodes.splice(0, 1, last);

        (_this$_nodes2 = this._nodes).splice.apply(_this$_nodes2, [this.getLastNodeIndex(), 1].concat(newNodes));
      } else if (last instanceof FieldNode && newNodes[0] instanceof FieldNode) {
        var _this$_nodes3;

        (_this$_nodes3 = this._nodes).splice.apply(_this$_nodes3, [this.getLastNodeIndex(), 0, new TextNode(' + ')].concat(newNodes));
      } else {
        var _this$_nodes4;

        (_this$_nodes4 = this._nodes).push.apply(_this$_nodes4, newNodes);
      }

      this.updateCache();
      this.expressionUpdatedSource.next();
      return;
    } // Requires position handling


    var updatedEvent = new ExpressionUpdatedEvent();

    var targetNode = this._nodes.find(function (n) {
      return n.getUuid() === insertPosition;
    }); // TODO: check this non null operator


    var targetNodeIndex = this._nodes.indexOf(targetNode);

    if (targetNode instanceof TextNode) {
      var _this$_nodes5;

      if (offset === undefined || offset === null || offset < 0) {
        offset = targetNode.str.length;
      }

      var pre = targetNode.str.substring(0, offset);
      var post = targetNode.str.substring(offset);

      if (pre.length > 0) {
        if (newNodes[0] instanceof TextNode) {
          targetNode.str = pre + newNodes[0].str;
          newNodes.splice(0, 1, targetNode);
        } else {
          targetNode.str = pre;
          newNodes.splice(0, 0, targetNode);
        }
      }

      if (post.length > 0) {
        var lastNewNodeIndex = newNodes.length - 1;

        if (newNodes[lastNewNodeIndex] instanceof TextNode) {
          var mergedTextNode;

          if (pre.length > 0) {
            mergedTextNode = newNodes[lastNewNodeIndex];
            mergedTextNode.str += post;
          } else {
            mergedTextNode = targetNode;
            mergedTextNode.str = newNodes[lastNewNodeIndex].str + post;
          }

          newNodes.splice(lastNewNodeIndex, 1, mergedTextNode);
        } else {
          if (pre.length > 0) {
            newNodes.push(new TextNode(post));
          } else {
            targetNode.str = post;
            newNodes.push(targetNode);
          }
        }
      }

      (_this$_nodes5 = this._nodes).splice.apply(_this$_nodes5, [targetNodeIndex, 1].concat(newNodes));

      var lastAddedIndex = targetNodeIndex + newNodes.length - 1;

      if (this._nodes[lastAddedIndex] instanceof FieldNode && this.nodes[lastAddedIndex + 1] instanceof FieldNode) {
        // insert a glue in between FieldNodes so that it won't break syntax and caret can go into
        var space = new TextNode(' + ');

        this._nodes.splice(lastAddedIndex + 1, 0, space);

        updatedEvent.node = space;
        updatedEvent.offset = 1;
      } else if (this._nodes[lastAddedIndex] instanceof FieldNode) {
        updatedEvent.node = this._nodes[lastAddedIndex + 1];
        updatedEvent.offset = 0;
      } else {
        updatedEvent.node = this._nodes[lastAddedIndex];
        updatedEvent.offset = this._nodes[lastAddedIndex].str.length - post.length;
      }

      this.updateCache();
      this.expressionUpdatedSource.next(updatedEvent);
      return;
    } // targetNode is a FieldNode - insert the text before it if offset is 0, otherwise after it


    if (offset !== 0 && newNodes[0] instanceof FieldNode) {
      // insert a glue in between FieldNodes so that it won't break syntax and caret can go into
      newNodes.splice(0, 0, new TextNode(' + '));
    }

    var nextNodeIndex = offset === 0 ? targetNodeIndex : targetNodeIndex + 1;
    var nextNode = this._nodes[nextNodeIndex];

    if (nextNode instanceof TextNode && newNodes[newNodes.length - 1] instanceof TextNode) {
      var _this$_nodes6;

      updatedEvent.offset = newNodes[newNodes.length - 1].str.length;
      nextNode.str = newNodes[newNodes.length - 1].str + nextNode.str;
      newNodes.pop();

      (_this$_nodes6 = this._nodes).splice.apply(_this$_nodes6, [nextNodeIndex, 1].concat(newNodes));

      updatedEvent.node = nextNode;
    } else if (nextNode instanceof FieldNode && newNodes[newNodes.length - 1] instanceof FieldNode) {
      var _this$_nodes7;

      // insert a glue in between FieldNodes so that it won't break syntax and caret can go into
      var _space = new TextNode(' + ');

      (_this$_nodes7 = this._nodes).splice.apply(_this$_nodes7, [nextNodeIndex, 0].concat(newNodes, [_space]));

      updatedEvent.node = _space;
      updatedEvent.offset = 1;
    } else {
      var _this$_nodes8;

      (_this$_nodes8 = this._nodes).splice.apply(_this$_nodes8, [nextNodeIndex, 0].concat(newNodes));

      if (nextNode instanceof TextNode) {
        updatedEvent.node = nextNode;
        updatedEvent.offset = 0;
      } else {
        updatedEvent.node = newNodes[newNodes.length - 1];
        updatedEvent.offset = newNodes[newNodes.length - 1].str.length;
      }
    }

    this.updateCache();
    this.expressionUpdatedSource.next(updatedEvent);
  };

  _proto4.removeToken = function removeToken(tokenPosition, offset, removeNext) {
    // No position was specified - remove from the end
    if (!tokenPosition) {
      var last = this.getLastNode();

      if (!last) {
        return;
      }

      if (last instanceof FieldNode) {
        var removed = this._nodes.pop();

        if (!this._nodes.find(function (n) {
          return n instanceof FieldNode && n.mappedField === removed.mappedField;
        })) {
          // TODO: check this non null operator
          this.mapping.removeField(removed.mappedField.field);
          this.cfg.mappingService.updateMappedField(this.mapping);
        }
      } else if (last instanceof TextNode) {
        if (last.str.length > 0) {
          last.str = last.str.substring(0, last.str.length - 1);
        }

        if (last.str.length === 0) {
          this._nodes.pop();
        }
      }

      this.updateCache();
      this.expressionUpdatedSource.next();
      return;
    } // Requires position handling


    var updatedEvent = new ExpressionUpdatedEvent();

    var targetNode = this._nodes.find(function (n) {
      return n.getUuid() === tokenPosition;
    }); // TODO: check this non null operator


    var targetNodeIndex = this._nodes.indexOf(targetNode);

    if (removeNext) {
      targetNodeIndex++;
      targetNode = this._nodes[targetNodeIndex];
    }

    if (!targetNode || offset === -1) {
      if (targetNodeIndex < 1) {
        return;
      }

      targetNode = this._nodes[--targetNodeIndex];
      offset = targetNode instanceof TextNode ? targetNode.str.length : 1;
    }

    if (targetNode instanceof FieldNode) {
      var _removed = this._nodes.splice(targetNodeIndex, 1);

      var targetFieldNode = _removed[0];

      if (!this._nodes.find(function (n) {
        return n instanceof FieldNode && n.mappedField === targetFieldNode.mappedField;
      })) {
        // TODO: check this non null operator
        this.mapping.removeField(targetFieldNode.mappedField.field);
        this.cfg.mappingService.updateMappedField(this.mapping);
      }

      if (this._nodes.length > targetNodeIndex) {
        if (this._nodes[targetNodeIndex - 1] instanceof TextNode && this._nodes[targetNodeIndex] instanceof TextNode) {
          var newOffset = this._nodes[targetNodeIndex - 1].str.length;
          this._nodes[targetNodeIndex - 1].str += this._nodes[targetNodeIndex].str;

          this._nodes.splice(targetNodeIndex, 1);

          updatedEvent.node = this._nodes[targetNodeIndex - 1];
          updatedEvent.offset = newOffset;
        } else if (this._nodes[targetNodeIndex - 1] instanceof FieldNode && this._nodes[targetNodeIndex] instanceof FieldNode) {
          var glue = new TextNode(' + ');

          this._nodes.splice(targetNodeIndex, 0, glue);

          updatedEvent.node = glue;
          updatedEvent.offset = 3;
        } else if (this._nodes[targetNodeIndex - 1] instanceof TextNode) {
          updatedEvent.node = this._nodes[targetNodeIndex - 1];
          updatedEvent.offset = this._nodes[targetNodeIndex - 1].str.length;
        } else if (this._nodes[targetNodeIndex] instanceof TextNode) {
          updatedEvent.node = this._nodes[targetNodeIndex];
          updatedEvent.offset = 0;
        }
      } else {
        // end of line
        updatedEvent = undefined;
      }
    } else {
      var targetString = targetNode.str; // Remove empty string text node.

      if (targetString.length === 1) {
        this._nodes.splice(targetNodeIndex, 1);
      } else {
        targetNode.str = offset === 0 ? targetString.substr(1) : targetString.substring(0, offset) + targetString.substring(offset + 1);
        updatedEvent.node = targetNode;
        updatedEvent.offset = offset;
      }
    }

    this.updateCache();
    this.expressionUpdatedSource.next(updatedEvent);
  }
  /**
   * Replace the content of the last text node with a substring terminating at the
   * specified index.
   *
   * @param index
   */
  ;

  _proto4.clearToEnd = function clearToEnd(index) {
    var last = this.getLastNode();

    if (!(last instanceof TextNode)) {
      return;
    }

    last.str = last.str.substring(0, index);
  }
  /**
   * Reflect mapped source fields to the field references in the expression.
   * Selected source fields are inserted into or appended to the expression,
   * and unselected source fields are removed from expression.
   *
   * @param mapping Corresponding MappingModel object
   * @param insertPosition
   * @param offset
   */
  ;

  _proto4.updateFieldReference = function updateFieldReference(mapping, insertPosition, offset) {
    var _this4 = this;

    var mappedFields = mapping.getUserMappedFields(true);
    var referenceFields = mapping.getReferenceMappedFields();

    var fieldNodes = this._nodes.filter(function (n) {
      return n instanceof FieldNode;
    }); // Remove non-reference fields from the expression if unmapped.


    for (var _iterator = _createForOfIteratorHelperLoose(fieldNodes), _step; !(_step = _iterator()).done;) {
      var node = _step.value;

      // TODO: check this non null operator
      if (mappedFields.includes(node.mappedField) || referenceFields.includes(node.mappedField) || node.hasComplexField()) {
        continue;
      }

      var index = this._nodes.indexOf(node);

      this._nodes.splice(index, 1);

      if (this._nodes.length > index && this._nodes[index - 1] instanceof TextNode && this._nodes[index] instanceof TextNode) {
        this._nodes[index - 1].str += this._nodes[index].str;

        this._nodes.splice(index, 1);
      }
    } // Add any non-reference mapped fields into the expression - append if no insert
    // position is specified.


    fieldNodes = this._nodes.filter(function (n) {
      return n instanceof FieldNode;
    });

    var _loop = function _loop() {
      var mfield = _step2.value;

      if (!fieldNodes.find(function (n) {
        return n.mappedField === mfield;
      }) && !referenceFields.find(function (r) {
        return r.field === mfield.field;
      })) {
        if (insertPosition) {
          _this4.insertNodes([new FieldNode(_this4.mapping, mfield)], insertPosition, offset);
        } else {
          _this4.appendFieldNode(mfield);
        }
      }
    };

    for (var _iterator2 = _createForOfIteratorHelperLoose(mappedFields), _step2; !(_step2 = _iterator2()).done;) {
      _loop();
    }

    this.updateCache();
    this.expressionUpdatedSource.next();
  };

  _proto4.clear = function clear() {
    this._nodes = [];
    this.updateCache();
    this.expressionUpdatedSource.next();
  };

  _proto4.toText = function toText() {
    if (this.textCache.length === 0) {
      this.updateCache();
    }

    return this.textCache;
  };

  _proto4.toHTML = function toHTML() {
    if (this.expressionHTML.length === 0) {
      this.updateCache();
    }

    return this.expressionHTML;
  };

  _proto4.addConditionalExpressionNode = function addConditionalExpressionNode(mappedField, nodeId, offset) {
    this.insertNodes([new FieldNode(this.mapping, mappedField)], nodeId, offset);
  };

  _proto4.updateCache = function updateCache() {
    var answer = '';

    this._nodes.forEach(function (node) {
      return answer += node.toText();
    });

    this.textCache = answer;
    answer = '';

    this._nodes.forEach(function (node) {
      return answer += node.toHTML();
    });

    this.expressionHTML = answer; // trigger expr box render
  }
  /**
   * Translate an expression string into an array of text nodes and field nodes.  Handle
   * relative paths for collection-based field references.
   *
   * @param text
   */
  ;

  _proto4.createNodesFromText = function createNodesFromText(text) {
    var answer = [];
    var position = -1;
    var collectionContextFieldNode = null;

    while (text.search(/\$\{[a-zA-Z0-9.:/<>[\]_-]+\}/) !== -1) {
      position = text.search(/\$/);

      if (position !== 0) {
        answer.push(new TextNode(text.substring(0, position)));
      }

      var nodeMetaVal = text.substring(position + 2, text.indexOf('}'));
      var fn = null;

      if (isNaN(Number(nodeMetaVal))) {
        var _collectionContextFie, _collectionContextFie2;

        fn = collectionContextFieldNode ? new FieldNode(this.mapping, undefined, nodeMetaVal, undefined, (_collectionContextFie = collectionContextFieldNode.mappedField) === null || _collectionContextFie === void 0 ? void 0 : (_collectionContextFie2 = _collectionContextFie.field) === null || _collectionContextFie2 === void 0 ? void 0 : _collectionContextFie2.path) : new FieldNode(this.mapping, undefined, nodeMetaVal);
      } else {
        var index = parseInt(nodeMetaVal, 10);
        fn = new FieldNode(this.mapping, undefined, undefined, index);
      }

      if (!fn || !fn.mappedField) {
        this.cfg.errorService.addError(new ErrorInfo({
          message: "Unable to map expression element '" + nodeMetaVal + "' to a field node.",
          level: ErrorLevel.ERROR,
          scope: ErrorScope.MAPPING,
          type: ErrorType.INTERNAL,
          mapping: this.mapping
        }));
      } else {
        var _fn$mappedField, _fn$mappedField$field;

        if ((_fn$mappedField = fn.mappedField) !== null && _fn$mappedField !== void 0 && (_fn$mappedField$field = _fn$mappedField.field) !== null && _fn$mappedField$field !== void 0 && _fn$mappedField$field.isCollection) {
          collectionContextFieldNode = fn;
        }

        answer.push(fn);
      }

      text = text.substring(text.indexOf('}') + 1);
    }

    if (text.length > 0) {
      answer.push(new TextNode(text));
    }

    return answer;
  };

  _proto4.appendFieldNode = function appendFieldNode(mfield) {
    var lastNode = this._nodes.pop();

    if (lastNode instanceof FieldNode) {
      this._nodes.push(lastNode, new TextNode(' + '));
    } else if (lastNode instanceof TextNode) {
      if (lastNode.str.length === 0) {
        this._nodes.push(new TextNode(' + '));
      } else {
        this._nodes.push(lastNode);
      }
    }

    this._nodes.push(new FieldNode(this.mapping, mfield));
  };

  _createClass(ExpressionModel, [{
    key: "hasComplexField",
    get: function get() {
      return this._hasComplexField;
    },
    set: function set(value) {
      this._hasComplexField = value;
    }
  }, {
    key: "nodes",
    get: function get() {
      return this._nodes;
    }
  }]);

  return ExpressionModel;
}();

var FieldActionArgument = function FieldActionArgument() {
  this.type = FieldType.STRING;
  this.values = null;
  this.serviceObject = {};
};
var FieldActionArgumentValue = function FieldActionArgumentValue() {};
var FieldActionDefinition = /*#__PURE__*/function () {
  function FieldActionDefinition() {
    this.arguments = [];
    this.sourceType = FieldType.NONE;
    this.targetType = FieldType.NONE;
    this.multiplicity = Multiplicity.ONE_TO_ONE;
    this.serviceObject = {};
  }

  var _proto = FieldActionDefinition.prototype;

  _proto.populateFieldAction = function populateFieldAction(action) {
    action.name = this.name;
    action.definition = this; // Use the parsed values if present, otherwise set to '0'.

    if (action.argumentValues == null || action.argumentValues.length === 0) {
      action.argumentValues = [];

      for (var _iterator = _createForOfIteratorHelperLoose(this.arguments), _step; !(_step = _iterator()).done;) {
        var arg = _step.value;

        // Default the input field to 0 for numerics
        if (['LONG', 'INTEGER', 'FLOAT', 'DOUBLE', 'SHORT', 'BYTE', 'DECIMAL', 'NUMBER'].indexOf(arg.type.toUpperCase()) !== -1) {
          action.setArgumentValue(arg.name, '0'); // TODO: check this non null operator
        } else {
          action.setArgumentValue(arg.name, ''); // TODO: check this non null operator
        }
      }
    }
  };

  _proto.getArgumentForName = function getArgumentForName(name) {
    // TODO: check this non null operator
    return this.arguments.find(function (argument) {
      return argument.name === name;
    });
  };

  return FieldActionDefinition;
}();
var FieldAction = /*#__PURE__*/function () {
  function FieldAction() {
    this.argumentValues = [];
  }

  FieldAction.create = function create(definition) {
    var instance = new FieldAction();
    instance.definition = definition;
    instance.name = definition === null || definition === void 0 ? void 0 : definition.name;
    return instance;
  };

  var _proto2 = FieldAction.prototype;

  _proto2.getArgumentValue = function getArgumentValue(argumentName) {
    for (var _iterator2 = _createForOfIteratorHelperLoose(this.argumentValues), _step2; !(_step2 = _iterator2()).done;) {
      var argValue = _step2.value;

      if (argValue.name === argumentName) {
        return argValue;
      }
    }

    var newArgValue = new FieldActionArgumentValue();
    newArgValue.name = argumentName;
    newArgValue.value = '0';
    this.argumentValues.push(newArgValue);
    return newArgValue;
  };

  _proto2.setArgumentValue = function setArgumentValue(argumentName, value) {
    this.getArgumentValue(argumentName).value = value;
  };

  return FieldAction;
}();

/*
    Copyright (C) 2017 Red Hat, Inc.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

            http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
*/
/**
 * Encapsulates Document inspection context.
 */

var DocumentInspectionModel = /*#__PURE__*/function () {
  function DocumentInspectionModel(cfg, doc) {
    this.cfg = cfg;
    this.doc = doc;
  }

  var _proto = DocumentInspectionModel.prototype;

  _proto.parseFieldFromDocument = function parseFieldFromDocument(field, parentField) {
    if (field != null && field.status === 'NOT_FOUND') {
      this.cfg.errorService.addError(new ErrorInfo({
        message: "Ignoring unknown field: " + field.name + " (" + field.path + "), document: " + this.doc.name,
        level: ErrorLevel.WARN,
        scope: ErrorScope.APPLICATION,
        type: ErrorType.USER
      }));
      return null;
    } else if (field != null && field.status === 'EXCLUDED') {
      return null;
    }

    var parsedField = new Field();
    parsedField.name = field.name;
    parsedField.type = field.fieldType;
    parsedField.path = field.path;
    parsedField.isPrimitive = field.fieldType !== 'COMPLEX';
    parsedField.documentField = field;

    if ('LIST' === field.collectionType || 'ARRAY' === field.collectionType) {
      parsedField.isCollection = true;

      if ('ARRAY' === field.collectionType) {
        parsedField.isArray = true;
      }
    }

    if (parentField != null) {
      parsedField.parentField = parentField;
      parentField.children.push(parsedField);
    } else {
      this.doc.fields.push(parsedField);
    }

    return parsedField;
  };

  return DocumentInspectionModel;
}();
var DocumentInspectionRequestModel = function DocumentInspectionRequestModel(cfg, doc) {
  this.cfg = cfg;
  this.doc = doc;
};
var DocumentInspectionRequestOptions = function DocumentInspectionRequestOptions(cfg, doc) {
  this.cfg = cfg;
  this.doc = doc;
  this.headers = {
    'Content-Type': 'application/json'
  };
  this.searchParams = {};
};

var CsvInspectionModel = /*#__PURE__*/function (_DocumentInspectionMo) {
  _inheritsLoose(CsvInspectionModel, _DocumentInspectionMo);

  function CsvInspectionModel() {
    var _this;

    _this = _DocumentInspectionMo.apply(this, arguments) || this;
    _this.request = new CsvInspectionRequestModel(_this.cfg, _this.doc);
    return _this;
  }

  var _proto = CsvInspectionModel.prototype;

  _proto.isOnlineInspectionCapable = function isOnlineInspectionCapable() {
    if (this.cfg.initCfg.baseCSVInspectionServiceUrl == null) {
      this.cfg.errorService.addError(new ErrorInfo({
        message: "CSV inspection service is not configured. Document will not be loaded: " + this.doc.name,
        level: ErrorLevel.WARN,
        scope: ErrorScope.APPLICATION,
        type: ErrorType.INTERNAL,
        object: this.doc
      }));
      return false;
    }

    return true;
  };

  _proto.parseResponse = function parseResponse(responseJson) {
    if (typeof responseJson.CsvInspectionResponse !== 'undefined') {
      this.extractCSVDocumentDefinitionFromInspectionResponse(responseJson.CsvInspectionResponse);
    } else if (typeof responseJson.CsvDocument !== 'undefined') {
      this.extractCSVDocumentDefinition(responseJson.CsvDocument);
    } else {
      throw new Error("Unknown CSV inspection result format: " + responseJson);
    }
  };

  _proto.extractCSVDocumentDefinitionFromInspectionResponse = function extractCSVDocumentDefinitionFromInspectionResponse(body) {
    if (body.errorMessage) {
      this.doc.errorOccurred = true;
      throw new Error("Could not load JSON document, error: " + body.errorMessage);
    }

    this.extractCSVDocumentDefinition(body.csvDocument);
  };

  _proto.extractCSVDocumentDefinition = function extractCSVDocumentDefinition(csvDocument) {
    if (!this.doc.description) {
      this.doc.description = this.doc.id;
    }

    if (!this.doc.name) {
      this.doc.name = this.doc.id;
    }

    if (this.doc.inspectionParameters) {
      var params = new URLSearchParams(this.doc.inspectionParameters);
      this.doc.uri = this.doc.uri + '?' + params;
    }

    for (var _iterator = _createForOfIteratorHelperLoose(csvDocument.fields.field), _step; !(_step = _iterator()).done;) {
      var field = _step.value;
      this.parseCSVFieldFromDocument(field, null);
    }
  };

  _proto.parseCSVFieldFromDocument = function parseCSVFieldFromDocument(field, parentField) {
    var _csvComplexType$csvFi, _csvComplexType$csvFi2;

    var parsedField = this.parseFieldFromDocument(field, parentField);

    if (parsedField == null) {
      return;
    }

    parsedField.column = field.column;

    if (field.fieldType !== FieldType.COMPLEX) {
      return;
    }

    var csvComplexType = field;

    if ((_csvComplexType$csvFi = csvComplexType.csvFields) !== null && _csvComplexType$csvFi !== void 0 && (_csvComplexType$csvFi2 = _csvComplexType$csvFi.csvField) !== null && _csvComplexType$csvFi2 !== void 0 && _csvComplexType$csvFi2.length) {
      for (var _iterator2 = _createForOfIteratorHelperLoose(csvComplexType.csvFields.csvField), _step2; !(_step2 = _iterator2()).done;) {
        var childField = _step2.value;
        this.parseCSVFieldFromDocument(childField, parsedField);
      }
    }
  };

  return CsvInspectionModel;
}(DocumentInspectionModel);
var CsvInspectionRequestModel = /*#__PURE__*/function (_DocumentInspectionRe) {
  _inheritsLoose(CsvInspectionRequestModel, _DocumentInspectionRe);

  function CsvInspectionRequestModel() {
    var _this2;

    _this2 = _DocumentInspectionRe.apply(this, arguments) || this;
    _this2.url = _this2.cfg.initCfg.baseCSVInspectionServiceUrl + 'inspect';
    _this2.options = new CsvInspectionRequestOptions(_this2.cfg, _this2.doc);
    return _this2;
  }

  return CsvInspectionRequestModel;
}(DocumentInspectionRequestModel);
var CsvInspectionRequestOptions = /*#__PURE__*/function (_DocumentInspectionRe2) {
  _inheritsLoose(CsvInspectionRequestOptions, _DocumentInspectionRe2);

  function CsvInspectionRequestOptions() {
    var _this3;

    _this3 = _DocumentInspectionRe2.apply(this, arguments) || this;
    _this3.body = _this3.doc.inspectionSource;
    _this3.searchParams = _this3.doc.inspectionParameters;
    return _this3;
  }

  return CsvInspectionRequestOptions;
}(DocumentInspectionRequestOptions);

/**
 * Encapsulates Java class inspection context.
 */

var JavaInspectionModel = /*#__PURE__*/function (_DocumentInspectionMo) {
  _inheritsLoose(JavaInspectionModel, _DocumentInspectionMo);

  function JavaInspectionModel() {
    var _this;

    _this = _DocumentInspectionMo.apply(this, arguments) || this;
    _this.request = new JavaInspectionRequestModel(_this.cfg, _this.doc);
    return _this;
  }

  var _proto = JavaInspectionModel.prototype;

  _proto.isOnlineInspectionCapable = function isOnlineInspectionCapable() {
    if (this.cfg.initCfg.baseJavaInspectionServiceUrl == null) {
      this.cfg.errorService.addError(new ErrorInfo({
        message: "Java inspection service is not configured. Document will not be loaded: " + this.doc.name,
        level: ErrorLevel.WARN,
        scope: ErrorScope.APPLICATION,
        type: ErrorType.INTERNAL,
        object: this.doc
      }));
      return false;
    }

    return true;
  };

  _proto.parseResponse = function parseResponse(responseJson) {
    var javaClass;

    if (responseJson.ClassInspectionResponse) {
      if (responseJson.errorMessage) {
        this.doc.errorOccurred = true;
        throw new Error("Could not load JSON document, error: " + responseJson.errorMessage);
      }

      javaClass = responseJson.ClassInspectionResponse.javaClass;
    } else {
      javaClass = responseJson.JavaClass;
    }

    var docIdentifier = this.doc.id;

    if (!javaClass || javaClass.status === 'NOT_FOUND') {
      this.doc.errorOccurred = true;
      throw new Error("Could not load JAVA document. Document is not found: " + docIdentifier);
    }

    if (!this.doc.description) {
      this.doc.description = javaClass.className;
    }

    if (!this.doc.name) {
      this.doc.name = javaClass.className; // Make doc name the class name rather than fully qualified name

      if (this.doc.name && this.doc.name.indexOf('.') !== -1) {
        this.doc.name = this.doc.name.substr(this.doc.name.lastIndexOf('.') + 1);
      }
    }

    if (javaClass.uri && (!this.doc.uri || this.doc.uri.length === 0)) {
      this.doc.uri = javaClass.uri;
    }

    var rootField = null;

    if (javaClass.collectionType && javaClass.collectionType !== CollectionType.NONE.valueOf()) {
      this.parseJavaFieldFromDocument(javaClass, null);
      rootField = this.doc.fields[0];
    }

    for (var _iterator = _createForOfIteratorHelperLoose(javaClass.javaFields.javaField), _step; !(_step = _iterator()).done;) {
      var field = _step.value;
      this.parseJavaFieldFromDocument(field, rootField);
    }
  };

  _proto.parseJavaFieldFromDocument = function parseJavaFieldFromDocument(field, parentField) {
    var _javaClass$javaEnumFi, _javaClass$javaFields, _javaClass$javaFields2;

    var parsedField = this.parseFieldFromDocument(field, parentField);

    if (parsedField == null) {
      return;
    }

    if (field.className) {
      parsedField.classIdentifier = field.className;
    }

    if (field.fieldType !== FieldType.COMPLEX) {
      return;
    }

    var javaClass = field;
    parsedField.enumeration = javaClass.enumeration;

    if (javaClass.enumeration && (_javaClass$javaEnumFi = javaClass.javaEnumFields) !== null && _javaClass$javaEnumFi !== void 0 && _javaClass$javaEnumFi.javaEnumField) {
      for (var _iterator2 = _createForOfIteratorHelperLoose(javaClass.javaEnumFields.javaEnumField), _step2; !(_step2 = _iterator2()).done;) {
        var enumValue = _step2.value;
        var parsedEnumValue = new EnumValue();
        parsedEnumValue.name = enumValue.name;
        parsedEnumValue.ordinal = enumValue.ordinal;
        parsedField.enumValues.push(parsedEnumValue);
      }
    }

    if ((_javaClass$javaFields = javaClass.javaFields) !== null && _javaClass$javaFields !== void 0 && (_javaClass$javaFields2 = _javaClass$javaFields.javaField) !== null && _javaClass$javaFields2 !== void 0 && _javaClass$javaFields2.length) {
      for (var _iterator3 = _createForOfIteratorHelperLoose(javaClass.javaFields.javaField), _step3; !(_step3 = _iterator3()).done;) {
        var childField = _step3.value;
        this.parseJavaFieldFromDocument(childField, parsedField);
      }
    }
  };

  return JavaInspectionModel;
}(DocumentInspectionModel);
var JavaInspectionRequestModel = /*#__PURE__*/function (_DocumentInspectionRe) {
  _inheritsLoose(JavaInspectionRequestModel, _DocumentInspectionRe);

  function JavaInspectionRequestModel() {
    var _this2;

    _this2 = _DocumentInspectionRe.apply(this, arguments) || this;
    _this2.url = _this2.cfg.initCfg.baseJavaInspectionServiceUrl + 'class';
    _this2.options = new JavaInspectionRequestOptions(_this2.cfg, _this2.doc);
    return _this2;
  }

  return JavaInspectionRequestModel;
}(DocumentInspectionRequestModel);
var JavaInspectionRequestOptions = /*#__PURE__*/function (_DocumentInspectionRe2) {
  _inheritsLoose(JavaInspectionRequestOptions, _DocumentInspectionRe2);

  function JavaInspectionRequestOptions(cfg, doc) {
    var _this3;

    _this3 = _DocumentInspectionRe2.call(this, cfg, doc) || this;
    _this3.cfg = cfg;
    _this3.doc = doc;
    var request = {
      ClassInspectionRequest: {
        jsonType: JAVA_INSPECTION_REQUEST_JSON_TYPE,
        className: _this3.doc.inspectionSource,
        disablePrivateOnlyFields: _this3.cfg.initCfg.disablePrivateOnlyFields,
        disableProtectedOnlyFields: _this3.cfg.initCfg.disableProtectedOnlyFields,
        disablePublicOnlyFields: _this3.cfg.initCfg.disablePublicOnlyFields,
        disablePublicGetterSetterFields: _this3.cfg.initCfg.disablePublicGetterSetterFields
      }
    };
    _this3.json = request;

    if (_this3.doc.initModel.collectionType && _this3.doc.initModel.collectionType !== CollectionType.NONE) {
      request.ClassInspectionRequest.collectionType = _this3.doc.initModel.collectionType;

      if (_this3.doc.initModel.collectionClassName) {
        request.ClassInspectionRequest.collectionClassName = _this3.doc.initModel.collectionClassName;
      }
    }

    if (_this3.cfg.initCfg.fieldNameExclusions && _this3.cfg.initCfg.fieldNameExclusions.length) {
      request.ClassInspectionRequest.fieldNameExclusions = {
        string: _this3.cfg.initCfg.fieldNameExclusions
      };
    }

    if (_this3.cfg.initCfg.classNameExclusions && _this3.cfg.initCfg.classNameExclusions.length) {
      request.ClassInspectionRequest.classNameExclusions = {
        string: _this3.cfg.initCfg.classNameExclusions
      };
    }

    return _this3;
  }

  return JavaInspectionRequestOptions;
}(DocumentInspectionRequestOptions);

/**
 * Encapsulates JSON inspection context.
 */

var JsonInspectionModel = /*#__PURE__*/function (_DocumentInspectionMo) {
  _inheritsLoose(JsonInspectionModel, _DocumentInspectionMo);

  function JsonInspectionModel() {
    var _this;

    _this = _DocumentInspectionMo.apply(this, arguments) || this;
    _this.request = new JsonInspectionRequestModel(_this.cfg, _this.doc);
    return _this;
  }

  var _proto = JsonInspectionModel.prototype;

  _proto.isOnlineInspectionCapable = function isOnlineInspectionCapable() {
    if (this.cfg.initCfg.baseJSONInspectionServiceUrl == null) {
      this.cfg.errorService.addError(new ErrorInfo({
        message: "JSON inspection service is not configured. Document will not be loaded: " + this.doc.name,
        level: ErrorLevel.WARN,
        scope: ErrorScope.APPLICATION,
        type: ErrorType.INTERNAL,
        object: this.doc
      }));
      return false;
    }

    return true;
  };

  _proto.parseResponse = function parseResponse(responseJson) {
    if (typeof responseJson.JsonInspectionResponse !== 'undefined') {
      this.extractJSONDocumentDefinitionFromInspectionResponse(responseJson.JsonInspectionResponse);
    } else if (typeof responseJson.JsonDocument !== 'undefined') {
      this.extractJSONDocumentDefinition(responseJson.JsonDocument);
    } else {
      throw new Error("Unknown JSON inspection result format: " + responseJson);
    }
  };

  _proto.extractJSONDocumentDefinitionFromInspectionResponse = function extractJSONDocumentDefinitionFromInspectionResponse(body) {
    if (body.errorMessage) {
      this.doc.errorOccurred = true;
      throw new Error("Could not load JSON document, error: " + body.errorMessage);
    }

    this.extractJSONDocumentDefinition(body.jsonDocument);
  };

  _proto.extractJSONDocumentDefinition = function extractJSONDocumentDefinition(jsonDocument) {
    if (!this.doc.description) {
      this.doc.description = this.doc.id;
    }

    if (!this.doc.name) {
      this.doc.name = this.doc.id;
    }

    for (var _iterator = _createForOfIteratorHelperLoose(jsonDocument.fields.field), _step; !(_step = _iterator()).done;) {
      var field = _step.value;
      this.parseJSONFieldFromDocument(field, null);
    }
  };

  _proto.parseJSONFieldFromDocument = function parseJSONFieldFromDocument(field, parentField) {
    var _complex$jsonEnumFiel, _complex$jsonFields;

    var parsedField = this.parseFieldFromDocument(field, parentField);

    if (parsedField == null) {
      return;
    }

    if (field.fieldType !== FieldType.COMPLEX) {
      return;
    }

    var complex = field;
    parsedField.enumeration = complex.enumeration;
    /** FIXME enumIndexValue doesn't exist on JsonField/JsonComplexType
    parsedField.enumIndexValue = complex.enumIndexValue
      ? complex.enumIndexValue
      : 0;
    */

    if (parsedField.enumeration && (_complex$jsonEnumFiel = complex.jsonEnumFields) !== null && _complex$jsonEnumFiel !== void 0 && _complex$jsonEnumFiel.jsonEnumField) {
      for (var _iterator2 = _createForOfIteratorHelperLoose(complex.jsonEnumFields.jsonEnumField), _step2; !(_step2 = _iterator2()).done;) {
        var enumValue = _step2.value;
        var parsedEnumValue = new EnumValue();
        parsedEnumValue.name = enumValue.name;
        parsedEnumValue.ordinal = enumValue.ordinal;
        parsedField.enumValues.push(parsedEnumValue);
      }
    }

    if ((_complex$jsonFields = complex.jsonFields) !== null && _complex$jsonFields !== void 0 && _complex$jsonFields.jsonField.length) {
      for (var _iterator3 = _createForOfIteratorHelperLoose(complex.jsonFields.jsonField), _step3; !(_step3 = _iterator3()).done;) {
        var childField = _step3.value;
        this.parseJSONFieldFromDocument(childField, parsedField);
      }
    }
  };

  return JsonInspectionModel;
}(DocumentInspectionModel);
var JsonInspectionRequestModel = /*#__PURE__*/function (_DocumentInspectionRe) {
  _inheritsLoose(JsonInspectionRequestModel, _DocumentInspectionRe);

  function JsonInspectionRequestModel() {
    var _this2;

    _this2 = _DocumentInspectionRe.apply(this, arguments) || this;
    _this2.url = _this2.cfg.initCfg.baseJSONInspectionServiceUrl + 'inspect';
    _this2.options = new JsonInspectionRequestOptions(_this2.cfg, _this2.doc);
    return _this2;
  }

  return JsonInspectionRequestModel;
}(DocumentInspectionRequestModel);
var JsonInspectionRequestOptions = /*#__PURE__*/function (_DocumentInspectionRe2) {
  _inheritsLoose(JsonInspectionRequestOptions, _DocumentInspectionRe2);

  function JsonInspectionRequestOptions() {
    var _this3;

    _this3 = _DocumentInspectionRe2.apply(this, arguments) || this;
    _this3.json = {
      JsonInspectionRequest: {
        jsonType: JSON_INSPECTION_REQUEST_JSON_TYPE,
        type: _this3.doc.inspectionType,
        jsonData: _this3.doc.inspectionSource
      }
    };
    return _this3;
  }

  return JsonInspectionRequestOptions;
}(DocumentInspectionRequestOptions);

var XmlInspectionModel = /*#__PURE__*/function (_DocumentInspectionMo) {
  _inheritsLoose(XmlInspectionModel, _DocumentInspectionMo);

  function XmlInspectionModel() {
    var _this;

    _this = _DocumentInspectionMo.apply(this, arguments) || this;
    _this.request = new XmlInspectionRequestModel(_this.cfg, _this.doc);
    return _this;
  }

  var _proto = XmlInspectionModel.prototype;

  _proto.isOnlineInspectionCapable = function isOnlineInspectionCapable() {
    if (this.cfg.initCfg.baseXMLInspectionServiceUrl == null) {
      this.cfg.errorService.addError(new ErrorInfo({
        message: "XML inspection service is not configured. Document will not be loaded: " + this.doc.name,
        level: ErrorLevel.WARN,
        scope: ErrorScope.APPLICATION,
        type: ErrorType.INTERNAL,
        object: this.doc
      }));
      return false;
    }

    return true;
  };

  _proto.parseResponse = function parseResponse(responseJson) {
    if (typeof responseJson.XmlInspectionResponse !== 'undefined') {
      this.extractXMLDocumentDefinitionFromInspectionResponse(responseJson.XmlInspectionResponse);
    } else if (typeof responseJson.XmlDocument !== 'undefined') {
      this.extractXMLDocumentDefinition(responseJson.XmlDocument);
    } else {
      throw new Error("Unknown XML inspection result format: " + responseJson);
    }
  };

  _proto.extractXMLDocumentDefinitionFromInspectionResponse = function extractXMLDocumentDefinitionFromInspectionResponse(body) {
    if (body.errorMessage) {
      this.doc.errorOccurred = true;
      throw new Error("Could not load XML document, error: " + body.errorMessage);
    }

    this.extractXMLDocumentDefinition(body.xmlDocument);
  };

  _proto.extractXMLDocumentDefinition = function extractXMLDocumentDefinition(xmlDocument) {
    var _xmlDocument$xmlNames, _xmlDocument$xmlNames2;

    if (!this.doc.description) {
      this.doc.description = this.doc.id;
    }

    if (!this.doc.name) {
      this.doc.name = this.doc.id;
    }

    if (xmlDocument !== null && xmlDocument !== void 0 && (_xmlDocument$xmlNames = xmlDocument.xmlNamespaces) !== null && _xmlDocument$xmlNames !== void 0 && (_xmlDocument$xmlNames2 = _xmlDocument$xmlNames.xmlNamespace) !== null && _xmlDocument$xmlNames2 !== void 0 && _xmlDocument$xmlNames2.length) {
      for (var _iterator = _createForOfIteratorHelperLoose(xmlDocument.xmlNamespaces.xmlNamespace), _step; !(_step = _iterator()).done;) {
        var serviceNS = _step.value;
        var ns = new NamespaceModel();
        ns.alias = serviceNS.alias;
        ns.uri = serviceNS.uri;
        ns.locationUri = serviceNS.locationUri;
        ns.isTarget = serviceNS.targetNamespace;
        this.doc.namespaces.push(ns);
      }
    }

    for (var _iterator2 = _createForOfIteratorHelperLoose(xmlDocument.fields.field), _step2; !(_step2 = _iterator2()).done;) {
      var field = _step2.value;

      if (!this.doc.selectedRoot || this.isSelectedRootElement(field)) {
        this.parseXMLFieldFromDocument(field, null);
        break;
      }
    }
  };

  _proto.isSelectedRootElement = function isSelectedRootElement(field) {
    if (!this.doc.selectedRoot && !(field !== null && field !== void 0 && field.name)) {
      return false;
    }

    return this.doc.selectedRoot === (field.name.indexOf(':') !== -1 ? field.name.split(':')[1] : field.name);
  };

  _proto.parseXMLFieldFromDocument = function parseXMLFieldFromDocument(field, parentField) {
    var _complex$xmlEnumField, _complex$xmlFields;

    var parsedField = this.parseFieldFromDocument(field, parentField);

    if (parsedField == null) {
      return;
    }

    if (field.name.indexOf(':') !== -1) {
      parsedField.namespaceAlias = field.name.split(':')[0];
      parsedField.name = field.name.split(':')[1];
    }

    parsedField.isAttribute = parsedField.path.indexOf('@') !== -1;

    if (field.fieldType !== FieldType.COMPLEX) {
      return;
    }

    var complex = field;
    parsedField.enumeration = complex.enumeration;

    if (parsedField.enumeration && (_complex$xmlEnumField = complex.xmlEnumFields) !== null && _complex$xmlEnumField !== void 0 && _complex$xmlEnumField.xmlEnumField) {
      for (var _iterator3 = _createForOfIteratorHelperLoose(complex.xmlEnumFields.xmlEnumField), _step3; !(_step3 = _iterator3()).done;) {
        var enumValue = _step3.value;
        var parsedEnumValue = new EnumValue();
        parsedEnumValue.name = enumValue.name;
        parsedEnumValue.ordinal = enumValue.ordinal;
        parsedField.enumValues.push(parsedEnumValue);
      }
    }

    if ((_complex$xmlFields = complex.xmlFields) !== null && _complex$xmlFields !== void 0 && _complex$xmlFields.xmlField.length) {
      for (var _iterator4 = _createForOfIteratorHelperLoose(complex.xmlFields.xmlField), _step4; !(_step4 = _iterator4()).done;) {
        var childField = _step4.value;
        this.parseXMLFieldFromDocument(childField, parsedField);
      }
    }
  };

  return XmlInspectionModel;
}(DocumentInspectionModel);
var XmlInspectionRequestModel = /*#__PURE__*/function (_DocumentInspectionRe) {
  _inheritsLoose(XmlInspectionRequestModel, _DocumentInspectionRe);

  function XmlInspectionRequestModel() {
    var _this2;

    _this2 = _DocumentInspectionRe.apply(this, arguments) || this;
    _this2.url = _this2.cfg.initCfg.baseXMLInspectionServiceUrl + 'inspect';
    _this2.options = new XmlInspectionRequestOptions(_this2.cfg, _this2.doc);
    return _this2;
  }

  return XmlInspectionRequestModel;
}(DocumentInspectionRequestModel);
var XmlInspectionRequestOptions = /*#__PURE__*/function (_DocumentInspectionRe2) {
  _inheritsLoose(XmlInspectionRequestOptions, _DocumentInspectionRe2);

  function XmlInspectionRequestOptions() {
    var _this3;

    _this3 = _DocumentInspectionRe2.apply(this, arguments) || this;
    _this3.json = {
      XmlInspectionRequest: {
        jsonType: XML_INSPECTION_REQUEST_JSON_TYPE,
        type: _this3.doc.inspectionType,
        xmlData: _this3.doc.inspectionSource
      }
    };
    return _this3;
  }

  return XmlInspectionRequestOptions;
}(DocumentInspectionRequestOptions);

var LookupTableEntry = function LookupTableEntry() {
  this.sourceType = FieldType.STRING;
  this.targetType = FieldType.STRING;
};
var LookupTable = /*#__PURE__*/function () {
  function LookupTable() {
    this.lookupEntry = [];
    this.name = new Date().getTime() + '-' + Math.floor(Math.random() * 1000000).toString();
  }

  var _proto = LookupTable.prototype;

  _proto.getInputOutputKey = function getInputOutputKey() {
    return this.sourceIdentifier + ':' + this.targetIdentifier;
  };

  _proto.getEntryForSource = function getEntryForSource(sourceValue, autocreate) {
    for (var _iterator = _createForOfIteratorHelperLoose(this.lookupEntry), _step; !(_step = _iterator()).done;) {
      var _entry = _step.value;

      if (_entry.sourceValue === sourceValue) {
        return _entry;
      }
    }

    if (autocreate) {
      var entry = new LookupTableEntry();
      entry.sourceValue = sourceValue;
      this.lookupEntry.push(entry);
      return entry;
    }

    return null;
  };

  _proto.toString = function toString() {
    var result = 'Lookup Table, name: ' + this.name + ', entries: ' + this.lookupEntry.length;
    result += '\nsourceIdentifier: ' + this.sourceIdentifier;
    result += '\n\targetIdentifier: ' + this.targetIdentifier;
    var counter = 0;

    for (var _iterator2 = _createForOfIteratorHelperLoose(this.lookupEntry), _step2; !(_step2 = _iterator2()).done;) {
      var entry = _step2.value;
      result += '\n\tEntry #' + counter + ': ' + entry.sourceValue + ' => ' + entry.targetValue;
      counter += 1;
    }

    return result;
  };

  return LookupTable;
}();

var TransitionMode;

(function (TransitionMode) {
  TransitionMode["ONE_TO_ONE"] = "ONE_TO_ONE";
  TransitionMode["ONE_TO_MANY"] = "ONE_TO_MANY";
  TransitionMode["ENUM"] = "ENUM";
  TransitionMode["MANY_TO_ONE"] = "MANY_TO_ONE";
  TransitionMode["FOR_EACH"] = "FOR_EACH";
  TransitionMode["EXPRESSION"] = "EXPRESSION";
})(TransitionMode || (TransitionMode = {}));

var TransitionDelimiter;

(function (TransitionDelimiter) {
  TransitionDelimiter[TransitionDelimiter["NONE"] = 0] = "NONE";
  TransitionDelimiter[TransitionDelimiter["AMPERSAND"] = 1] = "AMPERSAND";
  TransitionDelimiter[TransitionDelimiter["AT_SIGN"] = 2] = "AT_SIGN";
  TransitionDelimiter[TransitionDelimiter["BACKSLASH"] = 3] = "BACKSLASH";
  TransitionDelimiter[TransitionDelimiter["COLON"] = 4] = "COLON";
  TransitionDelimiter[TransitionDelimiter["COMMA"] = 5] = "COMMA";
  TransitionDelimiter[TransitionDelimiter["DASH"] = 6] = "DASH";
  TransitionDelimiter[TransitionDelimiter["EQUAL"] = 7] = "EQUAL";
  TransitionDelimiter[TransitionDelimiter["HASH"] = 8] = "HASH";
  TransitionDelimiter[TransitionDelimiter["PERIOD"] = 9] = "PERIOD";
  TransitionDelimiter[TransitionDelimiter["PIPE"] = 10] = "PIPE";
  TransitionDelimiter[TransitionDelimiter["SEMICOLON"] = 11] = "SEMICOLON";
  TransitionDelimiter[TransitionDelimiter["SLASH"] = 12] = "SLASH";
  TransitionDelimiter[TransitionDelimiter["SPACE"] = 13] = "SPACE";
  TransitionDelimiter[TransitionDelimiter["UNDERSCORE"] = 14] = "UNDERSCORE";
  TransitionDelimiter[TransitionDelimiter["USER_DEFINED"] = 15] = "USER_DEFINED";
})(TransitionDelimiter || (TransitionDelimiter = {}));

var TransitionDelimiterModel = function TransitionDelimiterModel(delimiter, serializedValue, prettyName, actualDelimiter) {
  this.delimiter = TransitionDelimiter.SPACE;
  this.serializedValue = null;
  this.prettyName = null;
  this.actualDelimiter = '';
  this.delimiter = delimiter;
  this.serializedValue = serializedValue;
  this.prettyName = prettyName;
  this.actualDelimiter = actualDelimiter;
};
var TransitionModel = /*#__PURE__*/function () {
  function TransitionModel() {
    this.mode = TransitionMode.ONE_TO_ONE;
    this.delimiter = TransitionDelimiter.SPACE;
    this.userDelimiter = '';
    this.lookupTableName = null;
    this.enableExpression = false;
    this.transitionFieldAction = null;
    TransitionModel.initialize();
  }

  TransitionModel.initialize = function initialize() {
    if (TransitionModel.delimiterModels.length === 0) {
      var models = [];
      models.push(new TransitionDelimiterModel(TransitionDelimiter.NONE, null, '[None]', ''));
      models.push(new TransitionDelimiterModel(TransitionDelimiter.AMPERSAND, 'Ampersand', 'Ampersand [&]', '&'));
      models.push(new TransitionDelimiterModel(TransitionDelimiter.AT_SIGN, 'AtSign', 'At Sign [@]', '@'));
      models.push(new TransitionDelimiterModel(TransitionDelimiter.BACKSLASH, 'Backslash', 'Backslash [\\]', '\\'));
      models.push(new TransitionDelimiterModel(TransitionDelimiter.COLON, 'Colon', 'Colon [:]', ':'));
      models.push(new TransitionDelimiterModel(TransitionDelimiter.COMMA, 'Comma', 'Comma [,]', ','));
      models.push(new TransitionDelimiterModel(TransitionDelimiter.DASH, 'Dash', 'Dash [-]', '-'));
      models.push(new TransitionDelimiterModel(TransitionDelimiter.EQUAL, 'Equal', 'Equal [=]', '='));
      models.push(new TransitionDelimiterModel(TransitionDelimiter.HASH, 'Hash', 'Hash [#]', '#'));
      models.push(new TransitionDelimiterModel(TransitionDelimiter.PERIOD, 'Period', 'Period [.]', '.'));
      models.push(new TransitionDelimiterModel(TransitionDelimiter.PIPE, 'Pipe', 'Pipe [|]', '|'));
      models.push(new TransitionDelimiterModel(TransitionDelimiter.SEMICOLON, 'Semicolon', 'Semicolon [;]', ';'));
      models.push(new TransitionDelimiterModel(TransitionDelimiter.SLASH, 'Slash', 'Slash [/]', '/'));
      models.push(new TransitionDelimiterModel(TransitionDelimiter.SPACE, 'Space', 'Space [ ]', ' '));
      models.push(new TransitionDelimiterModel(TransitionDelimiter.UNDERSCORE, 'Underscore', 'Underscore [_]', '_'));
      models.push(new TransitionDelimiterModel(TransitionDelimiter.USER_DEFINED, 'User defined', 'User defined', '\0'));
      TransitionModel.delimiterModels = models;
    }
  };

  TransitionModel.delimiterToModel = function delimiterToModel(delimiter) {
    return TransitionModel.delimiterModels.filter(function (model) {
      return model.actualDelimiter === delimiter;
    })[0];
  }
  /**
   * Translate a mapping mode number into a string.
   * @param mode
   */
  ;

  TransitionModel.getMappingModeName = function getMappingModeName(mode) {
    var actionName;

    switch (mode) {
      case TransitionMode.ONE_TO_ONE:
        {
          actionName = 'One to One';
          break;
        }

      case TransitionMode.MANY_TO_ONE:
        {
          actionName = 'Many to One';
          break;
        }

      case TransitionMode.ONE_TO_MANY:
        {
          actionName = 'One to Many';
          break;
        }

      case TransitionMode.ENUM:
        {
          actionName = 'ENUM';
          break;
        }

      case TransitionMode.FOR_EACH:
        {
          actionName = 'For Each';
          break;
        }

      case TransitionMode.EXPRESSION:
        {
          actionName = 'Expression';
          break;
        }

      default:
        {
          actionName = '';
          break;
        }
    }

    return actionName;
  };

  var _proto = TransitionModel.prototype;

  _proto.getPrettyName = function getPrettyName() {
    var transitionFieldActionName = '';

    if (this.transitionFieldAction) {
      transitionFieldActionName = ' (' + this.transitionFieldAction.name + ')';
    }

    if (this.mode === TransitionMode.ONE_TO_MANY || this.mode === TransitionMode.MANY_TO_ONE) {
      return TransitionModel.getMappingModeName(this.mode) + transitionFieldActionName;
    } else if (this.mode === TransitionMode.ENUM) {
      return 'Enum (table: ' + this.lookupTableName + ')';
    } else if (this.mode === TransitionMode.EXPRESSION) {
      var _this$expression;

      return 'Expression (' + ((_this$expression = this.expression) === null || _this$expression === void 0 ? void 0 : _this$expression.toText()) + ')';
    }

    return TransitionModel.getMappingModeName(this.mode);
  };

  _proto.isOneToManyMode = function isOneToManyMode() {
    return this.mode === TransitionMode.ONE_TO_MANY;
  };

  _proto.isOneToOneMode = function isOneToOneMode() {
    return this.mode === TransitionMode.ONE_TO_ONE;
  };

  _proto.isManyToOneMode = function isManyToOneMode() {
    return this.mode === TransitionMode.MANY_TO_ONE;
  };

  _proto.isForEachMode = function isForEachMode() {
    return this.mode === TransitionMode.FOR_EACH;
  };

  _proto.isEnumerationMode = function isEnumerationMode() {
    return this.mode === TransitionMode.ENUM;
  };

  _proto.isExpressionMode = function isExpressionMode() {
    return this.mode === TransitionMode.EXPRESSION;
  };

  return TransitionModel;
}();
TransitionModel.delimiterModels = [];

var MappingDefinition = /*#__PURE__*/function () {
  function MappingDefinition() {
    this.name = null;
    this.mappings = [];
    this.activeMapping = null;
    this.parsedDocs = [];
    this.templateText = null;
    this.tables = [];
    this.tablesBySourceTargetKey = {};
    this.tablesByName = {}; // Mapping definition ID must be 0 until https://github.com/atlasmap/atlasmap/issues/1577
    // this.name = 'UI.' + Math.floor((Math.random() * 1000000) + 1).toString();

    this.name = 'UI.0';
  }

  var _proto = MappingDefinition.prototype;

  _proto.templateExists = function templateExists() {
    return this.templateText != null && this.templateText !== '';
  };

  _proto.addTable = function addTable(table) {
    this.tablesBySourceTargetKey[table.getInputOutputKey()] = table;
    this.tablesByName[table.name] = table;
    this.tables.push(table);
  };

  _proto.getTableByName = function getTableByName(name) {
    return this.tablesByName[name];
  };

  _proto.getTableBySourceTarget = function getTableBySourceTarget(sourceIdentifier, targetIdentifier) {
    var key = sourceIdentifier + ':' + targetIdentifier;
    return this.tablesBySourceTargetKey[key];
  };

  _proto.getTables = function getTables() {
    var tables = [];

    for (var key in this.tablesByName) {
      if (!this.tablesByName.hasOwnProperty(key)) {
        continue;
      }

      var table = this.tablesByName[key];
      tables.push(table);
    }

    return tables;
  };

  _proto.removeTableByName = function removeTableByName(name) {
    if (name) {
      var table = this.tablesByName[name];
      var iokey = table.getInputOutputKey();

      if (this.tablesByName[name]) {
        delete this.tables[this.tables.indexOf(table)];
        delete this.tablesByName[name];
        delete this.tablesBySourceTargetKey[iokey];
      }
    }
  };

  _proto.getAllMappings = function getAllMappings(includeActiveMapping) {
    var mappings = [].concat(this.mappings);

    if (includeActiveMapping) {
      if (this.activeMapping == null) {
        return mappings;
      }

      for (var _iterator = _createForOfIteratorHelperLoose(mappings), _step; !(_step = _iterator()).done;) {
        var mapping = _step.value;

        if (mapping === this.activeMapping) {
          return mappings;
        }
      }

      mappings.push(this.activeMapping);
    }

    return mappings;
  };

  _proto.findMappingsForField = function findMappingsForField(field) {
    var mappingsForField = [];

    for (var _iterator2 = _createForOfIteratorHelperLoose(this.mappings), _step2; !(_step2 = _iterator2()).done;) {
      var m = _step2.value;

      if (m.isFieldMapped(field)) {
        mappingsForField.push(m);
      }
    }

    return mappingsForField;
  };

  _proto.removeMapping = function removeMapping(m) {
    if (m.transition.mode === TransitionMode.ENUM) {
      this.removeTableByName(m.transition.lookupTableName);
    }

    return CommonUtil.removeItemFromArray(m, this.mappings);
  };

  return MappingDefinition;
}();

var MappedField = /*#__PURE__*/function () {
  function MappedField() {
    /** The field actions read from mapping and enriched through {@link FieldActionService} */
    this.actions = [];
  }

  MappedField.sortMappedFieldsByPath = function sortMappedFieldsByPath(mappedFields) {
    if (mappedFields == null || mappedFields.length === 0) {
      return [];
    }

    var fieldsByPath = {};
    var fieldPaths = [];

    for (var _iterator = _createForOfIteratorHelperLoose(mappedFields), _step; !(_step = _iterator()).done;) {
      var mappedField = _step.value;

      if (mappedField == null || mappedField.field == null) {
        continue;
      }

      var path = mappedField.field.path;
      fieldsByPath[path] = mappedField;
      fieldPaths.push(path);
    }

    fieldPaths.sort();
    var result = [];

    for (var _i = 0, _fieldPaths = fieldPaths; _i < _fieldPaths.length; _i++) {
      var name = _fieldPaths[_i];
      result.push(fieldsByPath[name]);
    }

    return result;
  };

  var _proto = MappedField.prototype;

  _proto.isPadField = function isPadField() {
    return this.field instanceof PaddingField;
  };

  _proto.isSource = function isSource() {
    return this.field ? this.field.isSource() : false;
  };

  _proto.removeAction = function removeAction(action) {
    CommonUtil.removeItemFromArray(action, this.actions);
  };

  return MappedField;
}();
var MappingModel = /*#__PURE__*/function () {
  function MappingModel() {
    this.sourceFields = [];
    this.targetFields = [];
    this.referenceFields = [];
    this.transition = new TransitionModel();
    this.uuid = 'mapping.' + Math.floor(Math.random() * 1000000 + 1).toString();
    this.cfg = ConfigModel.getConfig();
  }

  var _proto2 = MappingModel.prototype;

  _proto2.getFirstCollectionField = function getFirstCollectionField(isSource) {
    for (var _iterator2 = _createForOfIteratorHelperLoose(isSource ? this.sourceFields : this.targetFields), _step2; !(_step2 = _iterator2()).done;) {
      var f = _step2.value;

      if (f.field && f.field.isInCollection()) {
        return f.field;
      }
    }

    return null;
  };

  _proto2.isLookupMode = function isLookupMode() {
    for (var _iterator3 = _createForOfIteratorHelperLoose(this.sourceFields.concat(this.targetFields)), _step3; !(_step3 = _iterator3()).done;) {
      var f = _step3.value;

      if (f.field && f.field.enumeration) {
        return true;
      }
    }

    return false;
  }
  /**
   * Add the specified field to this field mapping.
   *
   * @param field - field to add to the mapping
   * @param first - if true add the field to the beginning of the array, last otherwise.
   */
  ;

  _proto2.addField = function addField(field, first) {
    var mappedFields = this.getMappedFields(field.isSource());

    if (mappedFields.length === 1) {
      var _mappedField = mappedFields[0];

      if (!_mappedField.field) {
        _mappedField.field = field;
        return _mappedField;
      }
    }

    var mappedField = new MappedField();
    mappedField.field = field;

    if (first) {
      mappedFields.unshift(mappedField);
    } else {
      mappedFields.push(mappedField);
    }

    return mappedField;
  }
  /**
   * Remove the specified field from this field mapping.
   *
   * @param field
   */
  ;

  _proto2.removeField = function removeField(field) {
    var mappedFields = this.getMappedFields(field.isSource());
    CommonUtil.removeItemFromArray(mappedFields.find(function (mf) {
      return mf.field === field;
    }), mappedFields);
  }
  /**
   * Return the number of user-defined (non-padding) fields in this mapping.
   *
   * @param field
   */
  ;

  _proto2.getUserFieldCount = function getUserFieldCount(field) {
    var mappedFields = this.getMappedFields(field.isSource());
    var userFieldCount = 0;

    for (var _iterator4 = _createForOfIteratorHelperLoose(mappedFields), _step4; !(_step4 = _iterator4()).done;) {
      var mappedField = _step4.value;

      if (!mappedField.isPadField()) {
        userFieldCount++;
      }
    }

    return userFieldCount;
  };

  _proto2.hasMappedField = function hasMappedField(isSource) {
    return isSource ? this.sourceFields.length > 0 : this.targetFields.length > 0;
  };

  _proto2.isEmpty = function isEmpty() {
    return this.sourceFields.length === 0 && this.targetFields.length === 0;
  };

  _proto2.isFullyMapped = function isFullyMapped() {
    return this.sourceFields.length > 0 && this.targetFields.length > 0;
  };

  _proto2.addMappedField = function addMappedField(mappedField, isSource) {
    this.getMappedFields(isSource).push(mappedField);
  };

  _proto2.removeMappedField = function removeMappedField(mappedField) {
    if (!mappedField || !mappedField.field) {
      return;
    }

    if (mappedField.field.isCollection) {
      this.removeReferenceField(mappedField);
    }

    CommonUtil.removeItemFromArray(mappedField, this.getMappedFields(mappedField.field.isSource()));
    this.cfg.mappingService.notifyMappingUpdated();
  };

  _proto2.getMappedFieldForField = function getMappedFieldForField(field) {
    if (!field || !field.isSource) {
      return null;
    }

    for (var _iterator5 = _createForOfIteratorHelperLoose(this.getMappedFields(field.isSource())), _step5; !(_step5 = _iterator5()).done;) {
      var mappedField = _step5.value;

      if (mappedField.field === field) {
        return mappedField;
      }
    }

    return null;
  }
  /**
   * Return the MappedField associated with the specified field path and panel. The
   * document ID is optional identifier parameters used to distinguish the fields
   * with the same path in a different document. The first match will be returned
   * if not specified.
   *
   * @param fieldPath
   * @param isSource
   * @param identifier
   */
  ;

  _proto2.getMappedFieldByPath = function getMappedFieldByPath(fieldPath, isSource, docId) {
    if (!fieldPath) {
      return null;
    }

    var mappedFields = this.getMappedFields(isSource);

    for (var i = 0; i < mappedFields.length; i++) {
      var _mappedFields$i$field;

      if (((_mappedFields$i$field = mappedFields[i].field) === null || _mappedFields$i$field === void 0 ? void 0 : _mappedFields$i$field.path) === fieldPath) {
        var _mappedFields$i$field2;

        if (!docId) {
          return mappedFields[i];
        }

        if (docId && ((_mappedFields$i$field2 = mappedFields[i].field) === null || _mappedFields$i$field2 === void 0 ? void 0 : _mappedFields$i$field2.docDef.id) === docId) {
          return mappedFields[i];
        }
      }
    }

    return null;
  };

  _proto2.getMappedFieldForIndex = function getMappedFieldForIndex(index, isSource) {
    if (!index || index.length === 0) {
      return null;
    }

    var mappedFields = this.getMappedFields(isSource);

    if (+index - 1 > mappedFields.length - 1) {
      return null;
    }

    return mappedFields[+index - 1];
  };

  _proto2.getIndexForMappedField = function getIndexForMappedField(mappedField) {
    if (!mappedField || !mappedField.field) {
      return null;
    }

    return this.getMappedFields(mappedField.field.isSource()).indexOf(mappedField) + 1;
  };

  _proto2.getField = function getField(docId, fieldPath) {
    var docDef = this.cfg.getDocForIdentifier(docId, true);

    if (!docDef) {
      docDef = this.cfg.getDocForIdentifier(docId, false);
    }

    var field = null;

    if (docDef) {
      field = Field.getField(fieldPath, docDef.getAllFields());
    }

    return field;
  }
  /**
   * Create a reference field in the reference fields array for this mapping.
   *
   * @param field
   */
  ;

  _proto2.createReferenceField = function createReferenceField(field) {
    var _field$documentField, _field$documentField2, _field$documentField3;

    var mappedField = null;

    if (!field) {
      return null;
    }

    if (!((_field$documentField = field.documentField) !== null && _field$documentField !== void 0 && _field$documentField.status) || ((_field$documentField2 = field.documentField) === null || _field$documentField2 === void 0 ? void 0 : _field$documentField2.status) === 'SUPPORTED' || ((_field$documentField3 = field.documentField) === null || _field$documentField3 === void 0 ? void 0 : _field$documentField3.status) === 'CACHED') {
      mappedField = new MappedField();
      mappedField.field = field;
      this.referenceFields.push(mappedField);
    }

    return mappedField;
  }
  /**
   * Remove the specified reference field from the reference fields array.
   *
   * @param field
   */
  ;

  _proto2.removeReferenceField = function removeReferenceField(mappedField) {
    if (!mappedField) {
      return;
    }

    CommonUtil.removeItemFromArray(mappedField, this.referenceFields);
  }
  /**
   * Return true if a reference field exists in this mapping with the specified
   * document ID and field path, false otherwise.
   *
   * @param docId
   * @param fieldPath
   */
  ;

  _proto2.referenceFieldExists = function referenceFieldExists(docId, fieldPath) {
    if (!docId || !fieldPath) {
      return false;
    }

    var referenceFields = this.getReferenceMappedFields();

    for (var _iterator6 = _createForOfIteratorHelperLoose(referenceFields), _step6; !(_step6 = _iterator6()).done;) {
      var referenceField = _step6.value;

      if (referenceField.field && referenceField.field.docDef.id === docId && referenceField.field.path === fieldPath) {
        return true;
      }
    }

    return false;
  }
  /**
   * A reference field is a complex field which is referenced in a conditional
   * expression but does not exist as an explicit part of the mapping.  It is
   * typically used as a parameter to conditional functions/ constructs. If the
   * field already exists return it otherwise create it.
   *
   * @param docId
   * @param fieldPath
   */
  ;

  _proto2.getReferenceField = function getReferenceField(docId, fieldPath) {
    if (!docId || !fieldPath) {
      return null;
    }

    var referenceFields = this.getReferenceMappedFields();

    for (var _iterator7 = _createForOfIteratorHelperLoose(referenceFields), _step7; !(_step7 = _iterator7()).done;) {
      var referenceField = _step7.value;

      if (referenceField.field && referenceField.field.docDef.id === docId && referenceField.field.path === fieldPath) {
        return referenceField;
      }
    }

    var field = this.getField(docId, fieldPath);

    if ((field === null || field === void 0 ? void 0 : field.type) === FieldType.COMPLEX) {
      this.transition.expression.hasComplexField = true;
      return this.createReferenceField(field);
    }

    return null;
  }
  /**
   * Return an array of user mapped fields for the specified panel in this
   * field pair instance.  No data-mapper generated padding fields will be
   * included.
   *
   * @param isSource - true source panel, false target panel
   */
  ;

  _proto2.getUserMappedFields = function getUserMappedFields(isSource) {
    var workingFields = isSource ? this.sourceFields : this.targetFields;
    var resultFields = [new MappedField()];

    for (var _iterator8 = _createForOfIteratorHelperLoose(workingFields), _step8; !(_step8 = _iterator8()).done;) {
      var mappedField = _step8.value;

      if (!mappedField.isPadField()) {
        resultFields.push(mappedField);
      }
    }

    resultFields.shift();
    return resultFields;
  };

  _proto2.getReferenceMappedFields = function getReferenceMappedFields() {
    return this.referenceFields;
  };

  _proto2.getMappedFields = function getMappedFields(isSource) {
    return isSource ? this.sourceFields : this.targetFields;
  };

  _proto2.getLastMappedField = function getLastMappedField(isSource) {
    var fields = this.getMappedFields(isSource);

    if (fields != null && fields.length > 0) {
      return fields[fields.length - 1];
    }

    return null;
  };

  _proto2.getFields = function getFields(isSource) {
    var fields = [];

    for (var _iterator9 = _createForOfIteratorHelperLoose(this.getMappedFields(isSource)), _step9; !(_step9 = _iterator9()).done;) {
      var mappedField = _step9.value;

      if (mappedField.field != null) {
        fields.push(mappedField.field);
      }
    }

    return fields;
  };

  _proto2.getFieldNames = function getFieldNames(isSource) {
    var fields = this.getFields(isSource);
    Field.alphabetizeFields(fields);
    var names = [];

    for (var _iterator10 = _createForOfIteratorHelperLoose(fields), _step10; !(_step10 = _iterator10()).done;) {
      var field = _step10.value;
      names.push(field.name);
    }

    return names;
  };

  _proto2.getFieldPaths = function getFieldPaths(isSource) {
    var fields = this.getFields(isSource);
    Field.alphabetizeFields(fields);
    var paths = [];

    for (var _iterator11 = _createForOfIteratorHelperLoose(fields), _step11; !(_step11 = _iterator11()).done;) {
      var field = _step11.value;
      paths.push(field.path);
    }

    return paths;
  };

  _proto2.hasFieldActions = function hasFieldActions() {
    for (var _iterator12 = _createForOfIteratorHelperLoose(this.getAllMappedFields()), _step12; !(_step12 = _iterator12()).done;) {
      var mappedField = _step12.value;

      if (mappedField.actions.length > 0) {
        return true;
      }
    }

    return false;
  };

  _proto2.getAllFields = function getAllFields() {
    return this.getFields(true).concat(this.getFields(false));
  };

  _proto2.getAllMappedFields = function getAllMappedFields() {
    return this.getMappedFields(true).concat(this.getMappedFields(false));
  };

  _proto2.isFieldMapped = function isFieldMapped(field) {
    return this.getMappedFieldForField(field) != null;
  };

  _proto2.hasTransformation = function hasTransformation() {
    var mappedFields = this.getAllMappedFields();

    for (var _iterator13 = _createForOfIteratorHelperLoose(mappedFields), _step13; !(_step13 = _iterator13()).done;) {
      var mappedField = _step13.value;

      if (mappedField.actions.length > 0) {
        return true;
      }
    }

    return false;
  }
  /**
   * Walk all target field mappings and return one of corresponding source field name
   * if the specified field is already the target of a previous mapping, null otherwise.
   *
   * @param field
   */
  ;

  _proto2.getMappedTarget = function getMappedTarget(field) {
    // TODO: check this non null operator
    var mappings = this.cfg.mappings.mappings;

    if (field.isSource()) {
      return null;
    }

    for (var _iterator14 = _createForOfIteratorHelperLoose(mappings), _step14; !(_step14 = _iterator14()).done;) {
      var m = _step14.value;

      if (m.targetFields.length === 0) {
        continue;
      }

      for (var _iterator15 = _createForOfIteratorHelperLoose(m.targetFields), _step15; !(_step15 = _iterator15()).done;) {
        var _mappedOutputField$fi;

        var mappedOutputField = _step15.value;

        // TODO: check this non null operator
        if (((_mappedOutputField$fi = mappedOutputField.field) === null || _mappedOutputField$fi === void 0 ? void 0 : _mappedOutputField$fi.docDef) === field.docDef && mappedOutputField.field.path === field.path) {
          if (m.isFieldMapped(field)) {
            var _m$sourceFields$;

            return (_m$sourceFields$ = m.sourceFields[0]) === null || _m$sourceFields$ === void 0 ? void 0 : _m$sourceFields$.field.name;
          }
        }
      }
    }

    return null;
  };

  return MappingModel;
}();

// A type of promise-like that resolves synchronously and supports only one observer
var _Pact = /*#__PURE__*/function () {
  function _Pact() {}

  _Pact.prototype.then = function (onFulfilled, onRejected) {
    var result = new _Pact();
    var state = this.s;

    if (state) {
      var callback = state & 1 ? onFulfilled : onRejected;

      if (callback) {
        try {
          _settle(result, 1, callback(this.v));
        } catch (e) {
          _settle(result, 2, e);
        }

        return result;
      } else {
        return this;
      }
    }

    this.o = function (_this) {
      try {
        var value = _this.v;

        if (_this.s & 1) {
          _settle(result, 1, onFulfilled ? onFulfilled(value) : value);
        } else if (onRejected) {
          _settle(result, 1, onRejected(value));
        } else {
          _settle(result, 2, value);
        }
      } catch (e) {
        _settle(result, 2, e);
      }
    };

    return result;
  };

  return _Pact;
}(); // Settles a pact synchronously

function _settle(pact, state, value) {
  if (!pact.s) {
    if (value instanceof _Pact) {
      if (value.s) {
        if (state & 1) {
          state = value.s;
        }

        value = value.v;
      } else {
        value.o = _settle.bind(null, pact, state);
        return;
      }
    }

    if (value && value.then) {
      value.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));
      return;
    }

    pact.s = state;
    pact.v = value;
    var observer = pact.o;

    if (observer) {
      observer(pact);
    }
  }
}
function _isSettledPact(thenable) {
  return thenable instanceof _Pact && thenable.s & 1;
} // Converts argument to a function that always returns a Promise

function _forTo(array, body, check) {
  var i = -1,
      pact,
      reject;

  function _cycle(result) {
    try {
      while (++i < array.length && (!check || !check())) {
        result = body(i);

        if (result && result.then) {
          if (_isSettledPact(result)) {
            result = result.v;
          } else {
            result.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));
            return;
          }
        }
      }

      if (pact) {
        _settle(pact, 1, result);
      } else {
        pact = result;
      }
    } catch (e) {
      _settle(pact || (pact = new _Pact()), 2, e);
    }
  }

  _cycle();

  return pact;
} // Asynchronously iterate through an object's properties (including properties inherited from the prototype)
var _iteratorSymbol = /*#__PURE__*/typeof Symbol !== "undefined" ? Symbol.iterator || (Symbol.iterator = /*#__PURE__*/Symbol("Symbol.iterator")) : "@@iterator"; // Asynchronously iterate through an object's values
// Uses for...of if the runtime supports it, otherwise iterates until length on a copy

function _forOf(target, body, check) {
  if (typeof target[_iteratorSymbol] === "function") {
    var _cycle = function _cycle(result) {
      try {
        while (!(step = iterator.next()).done && (!check || !check())) {
          result = body(step.value);

          if (result && result.then) {
            if (_isSettledPact(result)) {
              result = result.v;
            } else {
              result.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));
              return;
            }
          }
        }

        if (pact) {
          _settle(pact, 1, result);
        } else {
          pact = result;
        }
      } catch (e) {
        _settle(pact || (pact = new _Pact()), 2, e);
      }
    };

    var iterator = target[_iteratorSymbol](),
        step,
        pact,
        reject;

    _cycle();

    if (iterator["return"]) {
      var _fixup = function _fixup(value) {
        try {
          if (!step.done) {
            iterator["return"]();
          }
        } catch (e) {}

        return value;
      };

      if (pact && pact.then) {
        return pact.then(_fixup, function (e) {
          throw _fixup(e);
        });
      }

      _fixup();
    }

    return pact;
  } // No support for Symbol.iterator


  if (!("length" in target)) {
    throw new TypeError("Object is not iterable");
  } // Handle live collections properly


  var values = [];

  for (var i = 0; i < target.length; i++) {
    values.push(target[i]);
  }

  return _forTo(values, function (i) {
    return body(values[i]);
  }, check);
}
var _asyncIteratorSymbol = /*#__PURE__*/typeof Symbol !== "undefined" ? Symbol.asyncIterator || (Symbol.asyncIterator = /*#__PURE__*/Symbol("Symbol.asyncIterator")) : "@@asyncIterator"; // Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing

function _catch(body, recover) {
  try {
    var result = body();
  } catch (e) {
    return recover(e);
  }

  if (result && result.then) {
    return result.then(void 0, recover);
  }

  return result;
} // Asynchronously await a promise and pass the result to a finally continuation

/*
    Copyright (C) 2017 Red Hat, Inc.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

            http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
*/
var DocumentInspectionUtil = /*#__PURE__*/function () {
  function DocumentInspectionUtil() {}

  /**
   * Create one of the subclass of {@link DocumentInspectionModel} which
   * corresponds to the existing {@link DocumentDefinition} passed in as an argument.
   * @see fromNonJavaProperties()
   * @see fromJavaProperties()
   *
   * @param cfg
   * @param doc
   * @returns
   */
  DocumentInspectionUtil.fromDocumentDefinition = function fromDocumentDefinition(cfg, doc) {
    switch (doc.type) {
      case DocumentType.JAVA:
        return new JavaInspectionModel(cfg, doc);

      case DocumentType.JSON:
        return new JsonInspectionModel(cfg, doc);

      case DocumentType.XSD:
      case DocumentType.XML:
        return new XmlInspectionModel(cfg, doc);

      case DocumentType.CSV:
        return new CsvInspectionModel(cfg, doc);

      default:
        throw new Error("Document type '" + doc.type + "' is not supported for inspection");
    }
  }
  /**
   * Create {@link JavaInspectionModel} from arguments and add corresponding
   * {@link DocumentDefinition} into {@link ConfigModel}.
   * @see fromDocumentDefinition()
   * @see fromNonJavaProperties()
   * @todo https://github.com/atlasmap/atlasmap/issues/2919
   * Assign GUID to Java Document ID as well, and use simple class name for default Document name
   *
   * @param cfg
   * @param className
   * @param isSource
   * @param collectionType
   * @param collectionClassName
   * @returns
   */
  ;

  DocumentInspectionUtil.fromJavaProperties = function fromJavaProperties(cfg, className, isSource, collectionType, collectionClassName) {
    if (collectionType === void 0) {
      collectionType = CollectionType.NONE;
    }

    var model = new DocumentInitializationModel();
    model.id = className;
    var simpleName = className.split('.').pop();
    model.name = simpleName ? simpleName : '';
    model.type = DocumentType.JAVA;
    model.inspectionType = InspectionType.JAVA_CLASS;
    model.inspectionSource = className;
    model.inspectionParameters = {
      '': ''
    };
    model.isSource = isSource;
    model.collectionType = collectionType;
    model.collectionClassName = collectionClassName;
    model.description = 'Java document class ' + className;

    if (collectionType && collectionType !== CollectionType.NONE) {
      model.description += ' collection type: ' + collectionType;

      if (collectionClassName) {
        model.description += ' collection class name: ' + collectionClassName;
      }
    }

    DocumentInspectionUtil.removeDocumentIfAlreadyExists(cfg, model.id, isSource);
    var doc = cfg.addDocument(model);
    return new JavaInspectionModel(cfg, doc);
  }
  /**
   * Create one of the subclass of {@link DocumentInspectionModel}
   * other than Java from arguments and add corresponding
   * {@link DocumentDefinition} into {@link ConfigModel}..
   * @see fromDocumentDefinition()
   * @see fromJavaProperties()
   *
   * @param cfg
   * @param id
   * @param name
   * @param documentType
   * @param inspectionType
   * @param inspectionSource
   * @param isSource
   * @param inspectionParameters
   * @returns
   */
  ;

  DocumentInspectionUtil.fromNonJavaProperties = function fromNonJavaProperties(cfg, id, name, documentType, inspectionType, inspectionSource, isSource, inspectionParameters) {
    var model = new DocumentInitializationModel();
    model.name = name;
    model.id = id;
    model.type = documentType;
    model.inspectionType = inspectionType;
    model.inspectionSource = inspectionSource;

    if (inspectionParameters) {
      model.inspectionParameters = inspectionParameters;
    } else {
      model.inspectionParameters = {
        '': ''
      };
    }

    model.isSource = isSource;
    model.description = isSource ? 'Source document ' : 'Target document ';
    model.description += name + ' type: ' + documentType;
    DocumentInspectionUtil.removeDocumentIfAlreadyExists(cfg, model.id, isSource);
    var doc = cfg.addDocument(model);
    return this.fromDocumentDefinition(cfg, doc);
  };

  DocumentInspectionUtil.removeDocumentIfAlreadyExists = function removeDocumentIfAlreadyExists(cfg, id, isSource) {
    // Clear out the existing document if importing the same name.
    var existing = cfg.getDocForIdentifier(id, isSource);

    if (existing) {
      if (isSource) {
        CommonUtil.removeItemFromArray(existing, cfg.sourceDocs);
      } else {
        CommonUtil.removeItemFromArray(existing, cfg.targetDocs);
      }
    }
  };

  return DocumentInspectionUtil;
}();

/*
    Copyright (C) 2017 Red Hat, Inc.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

            http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
*/

/*
    Generate a global unique identifier.
    Ref: https://stackoverflow.com/questions/26501688/a-typescript-guid-class
*/
var Guid = /*#__PURE__*/function () {
  function Guid() {}

  Guid.newGuid = function newGuid() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
      var r = Math.random() * 16 | 0,
          v = c === 'x' ? r : r & 0x3 | 0x8;
      return v.toString(16);
    });
  };

  return Guid;
}();

var EnumerationUnspecified = '[ None ]';
/**
 * Lookup table structure.
 */

var LookupTableData = function LookupTableData() {};
/**
 * Static lookup table utility methods.
 */

var LookupTableUtil = /*#__PURE__*/function () {
  function LookupTableUtil() {}

  LookupTableUtil.populateMappingLookupTable = function populateMappingLookupTable(mappingDefinition, m) {
    if (!(m.transition.mode === TransitionMode.ENUM && !m.transition.lookupTableName && m.getFields(true).length === 1 && m.getFields(false).length === 1)) {
      return;
    }

    var inputIdentifier;
    var outputIdentifier;
    var inputField = m.getFields(true)[0];

    if (inputField) {
      inputIdentifier = inputField.name + '-' + inputField.docDef.id;
    }

    var outputField = m.getFields(true)[0];

    if (outputField) {
      outputIdentifier = outputField.name + '-' + outputField.docDef.id;
    }

    if (inputIdentifier && outputIdentifier) {
      var table = mappingDefinition.getTableBySourceTarget(inputIdentifier, outputIdentifier);

      if (!table) {
        table = new LookupTable();
        table.sourceIdentifier = inputIdentifier;
        table.targetIdentifier = outputIdentifier;
        mappingDefinition.addTable(table);
        m.transition.lookupTableName = table.name;
      } else {
        m.transition.lookupTableName = table.name;
      }
    }
  };

  LookupTableUtil.updateLookupTables = function updateLookupTables(mappingDefinition) {
    for (var _iterator = _createForOfIteratorHelperLoose(mappingDefinition.getTables()), _step; !(_step = _iterator()).done;) {
      var t = _step.value;

      if (t.sourceIdentifier && t.targetIdentifier) {
        continue;
      }

      var m = LookupTableUtil.getFirstMappingForLookupTable(mappingDefinition, t.name);

      if (m && m.transition.lookupTableName) {
        if (!t.sourceIdentifier) {
          var inputField = m.getFields(true)[0];

          if (inputField) {
            t.sourceIdentifier = inputField.classIdentifier;
          }
        }

        if (!t.targetIdentifier) {
          var outputField = m.getFields(false)[0];

          if (outputField) {
            t.targetIdentifier = outputField.classIdentifier;
          }
        }
      }
    }

    for (var _iterator2 = _createForOfIteratorHelperLoose(mappingDefinition.mappings), _step2; !(_step2 = _iterator2()).done;) {
      var _m = _step2.value;
      LookupTableUtil.populateMappingLookupTable(mappingDefinition, _m);
    }
  };

  LookupTableUtil.getFirstMappingForLookupTable = function getFirstMappingForLookupTable(mappingDefinition, lookupTableName) {
    // TODO: check this non null operator
    return mappingDefinition.mappings.find(function (m) {
      return m.transition.lookupTableName === lookupTableName;
    });
  };

  LookupTableUtil.errorNoTable = function errorNoTable(cfg, mapping) {
    var _mapping$transition;

    cfg.errorService.addError(new ErrorInfo({
      message: 'Could not find enumeration lookup table ' + ((_mapping$transition = mapping.transition) === null || _mapping$transition === void 0 ? void 0 : _mapping$transition.lookupTableName) + ' for mapping.',
      scope: ErrorScope.MAPPING,
      type: ErrorType.INTERNAL,
      mapping: mapping
    }));
  };

  LookupTableUtil.getEnumerationValues = function getEnumerationValues(cfg, mapping) {
    var _mapping$transition2;

    if (!cfg || !cfg.mappings || !mapping) {
      return [];
    }

    var targetField = mapping.getFields(false)[0];
    var targetValues = [];
    targetValues.push('[ None ]');

    for (var _iterator3 = _createForOfIteratorHelperLoose(targetField.enumValues), _step3; !(_step3 = _iterator3()).done;) {
      var e = _step3.value;
      targetValues.push(e.name);
    }

    var table = cfg.mappings.getTableByName((_mapping$transition2 = mapping.transition) === null || _mapping$transition2 === void 0 ? void 0 : _mapping$transition2.lookupTableName);

    if (!table) {
      LookupTableUtil.errorNoTable(cfg, mapping);
      return [];
    }

    var enumVals = [];
    var sourceField = mapping.getFields(true)[0];

    for (var _iterator4 = _createForOfIteratorHelperLoose(sourceField.enumValues), _step4; !(_step4 = _iterator4()).done;) {
      var sourceEnum = _step4.value;
      var tableData = new LookupTableData();
      tableData.sourceEnumValue = sourceEnum.name;
      tableData.targetEnumValues = targetValues;
      var selected = table.getEntryForSource(tableData.sourceEnumValue, false);
      tableData.selectedTargetEnumValue = selected == null ? EnumerationUnspecified : selected.targetValue;
      enumVals.push(tableData);
    }

    return enumVals;
  };

  LookupTableUtil.updateEnumerationValues = function updateEnumerationValues(cfg, mapping, enumerationValues) {
    var _mapping$transition3;

    if (!cfg || !cfg.mappings || !mapping) {
      return;
    }

    var table = cfg.mappings.getTableByName((_mapping$transition3 = mapping.transition) === null || _mapping$transition3 === void 0 ? void 0 : _mapping$transition3.lookupTableName);

    if (!table) {
      LookupTableUtil.errorNoTable(cfg, mapping);
      return;
    }

    table.lookupEntry = [];

    for (var _iterator5 = _createForOfIteratorHelperLoose(enumerationValues), _step5; !(_step5 = _iterator5()).done;) {
      var enumValue = _step5.value;

      if (enumValue.selectedTargetEnumValue === EnumerationUnspecified) {
        continue;
      }

      var lte = new LookupTableEntry();
      lte.sourceValue = enumValue.sourceEnumValue;
      lte.targetValue = enumValue.selectedTargetEnumValue;
      table.lookupEntry.push(lte);
    }
  };

  return LookupTableUtil;
}();

var MappingDigestUtil = /*#__PURE__*/function () {
  function MappingDigestUtil() {}

  MappingDigestUtil.generateMappingDigest = function generateMappingDigest(cfg, mappingJson) {
    var mappingDigest = {
      exportMappings: {
        value: ''
      },
      exportMeta: [],
      exportBlockData: []
    }; // Retrieve the JSON mappings buffer from the server.

    var jsonBuffer = JSON.stringify(mappingJson);

    if (jsonBuffer) {
      mappingDigest.exportMappings.value = CommonUtil.sanitizeJSON(jsonBuffer);
    }

    for (var _iterator = _createForOfIteratorHelperLoose(cfg.getAllDocs()), _step; !(_step = _iterator()).done;) {
      var doc = _step.value;

      if (!doc.isPropertyOrConstant) {
        mappingDigest.exportMeta.push({
          name: doc.name,
          dataSourceType: doc.type,
          id: doc.id,
          inspectionType: doc.inspectionType,
          inspectionParameters: doc.inspectionParameters,
          isSource: doc.isSource
        });
        mappingDigest.exportBlockData.push({
          value: doc.inspectionSource
        });
      }
    }

    return mappingDigest;
  };

  return MappingDigestUtil;
}();

/**
 * Static routines for handling mappings.
 */

var MappingUtil = /*#__PURE__*/function () {
  function MappingUtil() {}

  MappingUtil.updateMappingsFromDocuments = function updateMappingsFromDocuments(cfg) {
    // TODO: check this non null operator
    for (var _iterator = _createForOfIteratorHelperLoose(cfg.mappings.mappings), _step; !(_step = _iterator()).done;) {
      var mapping = _step.value;
      MappingUtil.updateMappedFieldsFromDocuments(mapping, cfg, true);
      MappingUtil.updateMappedFieldsFromDocuments(mapping, cfg, false);
    }

    for (var _iterator2 = _createForOfIteratorHelperLoose(cfg.getAllDocs()), _step2; !(_step2 = _iterator2()).done;) {
      var doc = _step2.value;

      if (doc.id == null) {
        doc.id = 'DOC.' + doc.name + '.' + Math.floor(Math.random() * 1000000 + 1).toString();
      }
    }
  };

  MappingUtil.updateMappedFieldsFromDocuments = function updateMappedFieldsFromDocuments(mapping, cfg, isSource) {
    var mappedFields = mapping.getMappedFields(isSource);
    var mappedFieldIndex = -1;

    for (var _iterator3 = _createForOfIteratorHelperLoose(mappedFields), _step3; !(_step3 = _iterator3()).done;) {
      var mappedField = _step3.value;
      var doc = null;
      mappedFieldIndex += 1;

      if (mappedField.field instanceof PaddingField || mappedField.mappingField === undefined) {
        continue;
      }

      if (MappingUtil.isPropertyField(mappedField.mappingField)) {
        doc = isSource ? cfg.sourcePropertyDoc : cfg.targetPropertyDoc; // Preserve property Document ID from parsed data

        if (mappedField.mappingField.docId) {
          doc.id = mappedField.mappingField.docId;
        }
      } else if (MappingUtil.isConstantField(mappedField.mappingField)) {
        doc = cfg.constantDoc; // Preserve constant Document ID from parsed data

        if (mappedField.mappingField.docId) {
          doc.id = mappedField.mappingField.docId;
        }
      } else {
        if (mappedField.mappingField.docId == null) {
          cfg.errorService.addError(new ErrorInfo({
            message: "Could not find doc ID for mapped field " + mappedField.mappingField.name,
            level: ErrorLevel.ERROR,
            scope: ErrorScope.APPLICATION,
            type: ErrorType.INTERNAL
          }));
          continue;
        }

        doc = cfg.getDocForIdentifier(mappedField.mappingField.docId, isSource);

        if (doc == null) {
          if (mappedField.mappingField.name != null) {
            cfg.errorService.addError(new ErrorInfo({
              message: "Could not find document for mapped field '" + mappedField.mappingField.name + "' with ID " + mappedField.mappingField.docId,
              level: ErrorLevel.ERROR,
              scope: ErrorScope.APPLICATION,
              type: ErrorType.INTERNAL
            }));
          }

          continue;
        }

        doc.id = mappedField.mappingField.docId;
      }

      if (!mappedField.mappingField.path) {
        continue;
      }

      mappedField.field = doc.getField(mappedField.mappingField.path);

      if (mappedField.field == null) {
        // Check for collection instance.
        if (mappedField.mappingField.path.indexOf('<0>') >= 0) {
          mappedField.field = doc.getField(mappedField.mappingField.path.replace('<0>', '<>'));
        } else if (MappingUtil.isConstantField(mappedField.mappingField) && mappedField.mappingField.value && mappedField.mappingField.fieldType) {
          var constantField = cfg.constantDoc.getField(mappedField.mappingField.value);

          if (!constantField) {
            constantField = new Field();
          }

          constantField.value = mappedField.mappingField.value;
          constantField.type = mappedField.mappingField.fieldType;
          constantField.displayName = constantField.value;
          constantField.name = constantField.value;
          constantField.path = constantField.value;
          constantField.userCreated = true;
          mappedField.field = constantField;
          doc.addField(constantField);
        } else if (MappingUtil.isPropertyField(mappedField.mappingField) && mappedField.mappingField.fieldType && mappedField.mappingField.name && mappedField.mappingField.path) {
          var propMappingField = mappedField.mappingField;
          var propertyField = doc.getField(propMappingField.path);

          if (!propertyField) {
            propertyField = new Field();
          }

          var fieldName = propMappingField.name;
          propertyField.type = propMappingField.fieldType;

          if (propMappingField.scope) {
            propertyField.scope = propMappingField.scope;
          }

          propertyField.displayName = fieldName;
          propertyField.name = fieldName;
          propertyField.path = propMappingField.path;
          propertyField.userCreated = true;
          mappedField.field = propertyField;
          doc.addField(propertyField);
        } else {
          cfg.errorService.addError(new ErrorInfo({
            message: "Could not find field from document '" + doc.name + "' for mapped field '" + mappedField.mappingField.name + "'",
            level: ErrorLevel.ERROR,
            scope: ErrorScope.APPLICATION,
            type: ErrorType.INTERNAL,
            object: {
              mappedField: mappedField,
              doc: doc
            }
          }));
          return;
        }
      }

      var zeroBasedIndex = +mappedField.mappingField.index; // TODO: check this non null operator

      mappedFields = mapping.getMappedFields(isSource);

      if (zeroBasedIndex <= mappedFieldIndex) {
        mappedFields[mappedFieldIndex] = mappedField;
      } else {
        cfg.mappingService.addPlaceholders(zeroBasedIndex - mappedFieldIndex, mapping, mappedFieldIndex, isSource);
      }
    }
  }
  /**
   * Check all mappings in the current context and remove if it refers to un-existing fields.
   *
   * @param cfg ConfigModel
   */
  ;

  MappingUtil.removeStaleMappings = function removeStaleMappings(cfg) {
    var index = 0;
    var sourceFieldPaths = [];

    for (var _iterator4 = _createForOfIteratorHelperLoose(cfg.getDocs(true)), _step4; !(_step4 = _iterator4()).done;) {
      var doc = _step4.value;
      sourceFieldPaths = sourceFieldPaths.concat(Field.getFieldPaths(doc.getAllFields()));
    }

    var targetSourcePaths = [];

    for (var _iterator5 = _createForOfIteratorHelperLoose(cfg.getDocs(false)), _step5; !(_step5 = _iterator5()).done;) {
      var _doc = _step5.value;
      targetSourcePaths = targetSourcePaths.concat(Field.getFieldPaths(_doc.getAllFields()));
    } // TODO: check these non null operator


    while (index < cfg.mappings.mappings.length) {
      var mapping = cfg.mappings.mappings[index];
      var mappingIsStale = this.isMappingStale(mapping, sourceFieldPaths, targetSourcePaths);

      if (mappingIsStale) {
        cfg.mappings.mappings.splice(index, 1);
      } else {
        index++;
      }
    }
  };

  MappingUtil.isMappingStale = function isMappingStale(mapping, sourceFieldPaths, targetSourcePaths) {
    for (var _iterator6 = _createForOfIteratorHelperLoose(mapping.getFields(true)), _step6; !(_step6 = _iterator6()).done;) {
      var field = _step6.value;

      if (!(field instanceof PaddingField) && sourceFieldPaths.indexOf(field.path) === -1) {
        return true;
      }
    }

    for (var _iterator7 = _createForOfIteratorHelperLoose(mapping.getFields(false)), _step7; !(_step7 = _iterator7()).done;) {
      var _field = _step7.value;

      if (!(_field instanceof PaddingField) && targetSourcePaths.indexOf(_field.path) === -1) {
        return true;
      }
    }

    return false;
  };

  MappingUtil.updateDocumentNamespacesFromMappings = function updateDocumentNamespacesFromMappings(cfg) {
    var docs = cfg.getDocs(false); // TODO: check this non null operator

    for (var _iterator8 = _createForOfIteratorHelperLoose(cfg.mappings.parsedDocs), _step8; !(_step8 = _iterator8()).done;) {
      var parsedDoc = _step8.value;

      if (!parsedDoc) {
        continue;
      }

      if (parsedDoc.isSource) {
        continue;
      }

      if (parsedDoc.namespaces.length === 0) {
        continue;
      }

      var doc = this.getDocById(parsedDoc.id, docs);

      if (doc == null) {
        cfg.errorService.addError(new ErrorInfo({
          message: "Could not find document with identifier '" + parsedDoc.id + "' for namespace override.",
          level: ErrorLevel.ERROR,
          scope: ErrorScope.APPLICATION,
          type: ErrorType.INTERNAL,
          object: {
            identifier: parsedDoc.id,
            parsedDoc: parsedDoc,
            docs: docs
          }
        }));
        continue;
      }

      doc.namespaces = [].concat(parsedDoc.namespaces);
    }
  };

  MappingUtil.getDocById = function getDocById(documentId, docs) {
    if (documentId == null || docs == null || !docs.length) {
      return null;
    }

    for (var _iterator9 = _createForOfIteratorHelperLoose(docs), _step9; !(_step9 = _iterator9()).done;) {
      var doc = _step9.value;

      if (doc.id === documentId) {
        return doc;
      }
    }

    return null;
  };

  MappingUtil.activeMapping = function activeMapping(cfg) {
    var _cfg$mappings;

    return !!(cfg !== null && cfg !== void 0 && (_cfg$mappings = cfg.mappings) !== null && _cfg$mappings !== void 0 && _cfg$mappings.activeMapping);
  }
  /**
   * Return true if the specified mapped field array has any established field actions,
   * false otherwise.
   *
   * @param fields
   */
  ;

  MappingUtil.hasFieldAction = function hasFieldAction(fields) {
    for (var _iterator10 = _createForOfIteratorHelperLoose(fields), _step10; !(_step10 = _iterator10()).done;) {
      var field = _step10.value;

      if (field.actions.length > 0) {
        return true;
      }
    }

    return false;
  };

  MappingUtil.hasMappedCollection = function hasMappedCollection(mapping, isSource) {
    var mappedFields = mapping.getMappedFields(isSource);
    return mapping.isFullyMapped() && mappedFields[0].field && mappedFields[0].field.isInCollection();
  };

  MappingUtil.isPropertyField = function isPropertyField(field) {
    return (field === null || field === void 0 ? void 0 : field.jsonType) === PROPERTY_FIELD_JSON_TYPE;
  };

  MappingUtil.isConstantField = function isConstantField(field) {
    return (field === null || field === void 0 ? void 0 : field.jsonType) === CONSTANT_FIELD_JSON_TYPE;
  };

  return MappingUtil;
}();

var MappingSerializer = /*#__PURE__*/function () {
  function MappingSerializer() {}

  MappingSerializer.serializeMappings = function serializeMappings(cfg, ignoreValue) {
    if (ignoreValue === void 0) {
      ignoreValue = true;
    }

    // TODO: check this non null operator
    var mappingDefinition = cfg.mappings;
    var jsonMappings = [];

    for (var _iterator = _createForOfIteratorHelperLoose(mappingDefinition.mappings.filter(function (m) {
      return m.isFullyMapped();
    })), _step; !(_step = _iterator()).done;) {
      var mapping = _step.value;

      try {
        var serializedFieldMapping = MappingSerializer.serializeFieldMapping(cfg, mapping, mapping.uuid, ignoreValue);

        if (serializedFieldMapping) {
          jsonMappings = jsonMappings.concat(serializedFieldMapping);
        }
      } catch (e) {
        var input = {
          mapping: mapping,
          'mapping def': mappingDefinition
        };
        cfg.errorService.addError(new ErrorInfo({
          message: 'Caught exception while attempting to serialize mapping, skipping. ',
          level: ErrorLevel.ERROR,
          scope: ErrorScope.APPLICATION,
          type: ErrorType.INTERNAL,
          object: {
            input: input,
            error: e
          }
        }));
      }
    }

    var serializedLookupTables = MappingSerializer.serializeLookupTables(cfg.mappings);
    var constantDescriptions = MappingSerializer.serializeConstants(cfg.constantDoc);
    var sourcePropertyDescriptions = MappingSerializer.serializeProperties(cfg.sourcePropertyDoc);
    var targetPropertyDescriptions = MappingSerializer.serializeProperties(cfg.targetPropertyDoc);
    var serializedDataSources = MappingSerializer.serializeDocuments(cfg.sourceDocs.concat(cfg.targetDocs), mappingDefinition);
    var payload = {
      AtlasMapping: {
        jsonType: ATLAS_MAPPING_JSON_TYPE,
        dataSource: serializedDataSources,
        mappings: {
          mapping: jsonMappings
        },
        name: cfg.mappings.name ? cfg.mappings.name : undefined,
        lookupTables: {
          lookupTable: serializedLookupTables
        },
        constants: {
          constant: constantDescriptions
        },
        properties: {
          property: sourcePropertyDescriptions.concat(targetPropertyDescriptions)
        }
      }
    };
    return payload;
  };

  MappingSerializer.serializeFieldMapping = function serializeFieldMapping(cfg, mapping, id, ignoreValue) {
    if (ignoreValue === void 0) {
      ignoreValue = true;
    }

    var serializedInputFields = MappingSerializer.serializeFields(mapping, true, cfg, ignoreValue);
    var serializedOutputFields = MappingSerializer.serializeFields(mapping, false, cfg, ignoreValue);
    var jsonMapping;
    var mappingExpression = cfg.expressionService.getMappingExpressionStr(false, mapping);

    if (mapping.transition.isManyToOneMode() || mapping.transition.isForEachMode() || mapping.transition.isExpressionMode()) {
      var actions = [];

      if (mapping.transition.transitionFieldAction) {
        actions[0] = this.serializeAction(mapping.transition.transitionFieldAction, cfg);
      }

      var field = serializedInputFields;
      var inputFieldGroup = {
        jsonType: FIELD_GROUP_JSON_TYPE,
        actions: actions,
        field: field
      };

      if (mappingExpression.length > 0) {
        jsonMapping = {
          jsonType: MAPPING_JSON_TYPE,
          id: id,
          expression: mappingExpression,
          inputFieldGroup: inputFieldGroup,
          outputField: serializedOutputFields
        };
      } else {
        jsonMapping = {
          jsonType: MAPPING_JSON_TYPE,
          id: id,
          inputFieldGroup: inputFieldGroup,
          outputField: serializedOutputFields
        };
      }
    } else {
      if (mapping.transition.isOneToManyMode() && mapping.transition.transitionFieldAction) {
        var mappingAction = this.serializeAction(mapping.transition.transitionFieldAction, cfg);

        if (!serializedInputFields[0].actions) {
          serializedInputFields[0].actions = [];
        }

        if (mappingAction) {
          serializedInputFields[0].actions.unshift(mappingAction);
        }
      }

      if (mappingExpression.length > 0) {
        var _serializedInputField;

        if ((_serializedInputField = serializedInputFields[0].jsonType) !== null && _serializedInputField !== void 0 && _serializedInputField.includes('FieldGroup')) {
          var serializedInputFieldGroup = serializedInputFields[0];

          for (var i = 1; i < serializedInputFields.length; i++) {
            var _serializedInputField2;

            if ((_serializedInputField2 = serializedInputFields[i].jsonType) !== null && _serializedInputField2 !== void 0 && _serializedInputField2.includes('FieldGroup')) {
              var serializedFieldGroup0 = serializedInputFields[0];
              var serializedFieldGroupi = serializedInputFields[i];

              if (serializedFieldGroupi.field && serializedFieldGroup0.field && serializedFieldGroupi.field[0].path === serializedFieldGroup0.field[0].path) {
                var _serializedInputField3;

                (_serializedInputField3 = serializedInputFieldGroup.field) === null || _serializedInputField3 === void 0 ? void 0 : _serializedInputField3.push(serializedFieldGroupi.field[0]);
              }
            } // TODO - Support input fields from different complex parent fields
            // in the same complex conditional expression.

          }

          jsonMapping = {
            jsonType: MAPPING_JSON_TYPE,
            id: id,
            expression: mappingExpression,
            inputFieldGroup: serializedInputFieldGroup,
            outputField: serializedOutputFields
          };
        } else {
          jsonMapping = {
            jsonType: MAPPING_JSON_TYPE,
            id: id,
            expression: mappingExpression,
            inputField: serializedInputFields,
            outputField: serializedOutputFields
          };
        }
      } else {
        jsonMapping = {
          jsonType: MAPPING_JSON_TYPE,
          id: id,
          inputField: serializedInputFields,
          outputField: serializedOutputFields
        };
      }
    }

    if (mapping.transition.isEnumerationMode()) {
      jsonMapping.mappingType = MappingType.LOOKUP;
      /* @deprecated */

      if (mapping.transition.lookupTableName) {
        jsonMapping.lookupTableName = mapping.transition.lookupTableName;
      }
    }

    return jsonMapping;
  };

  MappingSerializer.deserializeMappingServiceJSON = function deserializeMappingServiceJSON(json, cfg) {
    // Process constants and properties before mappings.
    for (var _iterator2 = _createForOfIteratorHelperLoose(MappingSerializer.deserializeConstants(json)), _step2; !(_step2 = _iterator2()).done;) {
      var field = _step2.value;
      cfg.constantDoc.addField(field);
    }

    for (var _iterator3 = _createForOfIteratorHelperLoose(MappingSerializer.deserializeProperties(cfg, json, true)), _step3; !(_step3 = _iterator3()).done;) {
      var _field = _step3.value;
      cfg.sourcePropertyDoc.addField(_field);
    }

    for (var _iterator4 = _createForOfIteratorHelperLoose(MappingSerializer.deserializeProperties(cfg, json, false)), _step4; !(_step4 = _iterator4()).done;) {
      var _field2 = _step4.value;
      cfg.targetPropertyDoc.addField(_field2);
    }

    if (!cfg.mappings) {
      cfg.mappings = new MappingDefinition();
    }

    cfg.mappings.name = this.deserializeAtlasMappingName(json);
    cfg.mappings.parsedDocs = cfg.mappings.parsedDocs.concat(MappingSerializer.deserializeDocs(json, cfg.mappings)); // TODO: check this non null operator

    cfg.mappings.mappings = cfg.mappings.mappings.concat(MappingSerializer.deserializeMappings(json, cfg));

    for (var _iterator5 = _createForOfIteratorHelperLoose(MappingSerializer.deserializeLookupTables(json)), _step5; !(_step5 = _iterator5()).done;) {
      var lookupTable = _step5.value;
      cfg.mappings.addTable(lookupTable);
    }
  }
  /**
   * Return the AtlasMap mappings file name from the specified JSON buffer or an empty string.
   *
   * @param json
   */
  ;

  MappingSerializer.deserializeAtlasMappingName = function deserializeAtlasMappingName(json) {
    var _json$AtlasMapping;

    if (json !== null && json !== void 0 && (_json$AtlasMapping = json.AtlasMapping) !== null && _json$AtlasMapping !== void 0 && _json$AtlasMapping.name) {
      return json.AtlasMapping.name;
    } else {
      return '';
    }
  };

  MappingSerializer.addInputFieldGroupFields = function addInputFieldGroupFields(inputField, mapping, cfg) {
    for (var _iterator6 = _createForOfIteratorHelperLoose(inputField), _step6; !(_step6 = _iterator6()).done;) {
      var field = _step6.value;

      if (field.fieldType === 'COMPLEX') {
        MappingSerializer.addInputFieldGroupFields(field.field, mapping, cfg);
      } else {
        MappingSerializer.deserializeMappedField(mapping, field, true, cfg);
      }
    }
  };

  MappingSerializer.deserializeFieldMapping = function deserializeFieldMapping(mappingJson, cfg) {
    var mapping = new MappingModel();
    mapping.uuid = mappingJson.id;
    mapping.sourceFields = [];
    mapping.targetFields = [];
    mapping.referenceFields = [];
    mapping.transition.mode = TransitionMode.ONE_TO_ONE;
    var isLookupMapping = mappingJson.mappingType === 'LOOKUP' || mappingJson.lookupTableName != null;

    if (mappingJson.mappingType && mappingJson.mappingType !== MappingType.NONE) {
      this.deserializeFieldMappingFromType(mapping, mappingJson, cfg);
      return mapping;
    }

    if (mappingJson.inputFieldGroup) {
      MappingSerializer.deserializeInputFieldGroup(mappingJson, mapping, cfg);
    } else {
      var _mappingJson$outputFi;

      var inputField = mappingJson.inputField;

      if (inputField) {
        for (var _iterator7 = _createForOfIteratorHelperLoose(inputField), _step7; !(_step7 = _iterator7()).done;) {
          var field = _step7.value;
          MappingSerializer.deserializeMappedField(mapping, field, true, cfg);
        }
      }

      if ((_mappingJson$outputFi = mappingJson.outputField) !== null && _mappingJson$outputFi !== void 0 && _mappingJson$outputFi.length && mappingJson.outputField.length > 1) {
        mapping.transition.mode = TransitionMode.ONE_TO_MANY;
      }

      if (cfg.mappings) {
        MappingUtil.updateMappedFieldsFromDocuments(mapping, cfg, true);
      }
    }

    if (mappingJson.expression && mappingJson.expression.length > 0) {
      mapping.transition.enableExpression = true;
      mapping.transition.mode = TransitionMode.EXPRESSION;
      mapping.transition.expression = new ExpressionModel(mapping, cfg);
      mapping.transition.expression.insertText(mappingJson.expression);
    }

    for (var _iterator8 = _createForOfIteratorHelperLoose(mappingJson.outputField), _step8; !(_step8 = _iterator8()).done;) {
      var _field3 = _step8.value;
      MappingSerializer.deserializeMappedField(mapping, _field3, false, cfg);
    }

    MappingUtil.updateMappedFieldsFromDocuments(mapping, cfg, false);

    if (isLookupMapping) {
      mapping.transition.lookupTableName = mappingJson.lookupTableName;
      mapping.transition.mode = TransitionMode.ENUM;
    }

    return mapping;
  };

  MappingSerializer.deserializeInputFieldGroup = function deserializeInputFieldGroup(mappingJson, mapping, cfg) {
    var _mappingJson$inputFie;

    if (!mappingJson.inputFieldGroup) {
      return;
    }

    if (mappingJson.expression && mappingJson.inputFieldGroup.fieldType === FieldType.COMPLEX) {
      mapping.transition.expression.hasComplexField = true;
    }

    mapping.transition.mode = TransitionMode.MANY_TO_ONE;
    MappingSerializer.addInputFieldGroupFields(mappingJson.inputFieldGroup.field, mapping, cfg);
    MappingUtil.updateMappedFieldsFromDocuments(mapping, cfg, true);

    if (mappingJson.inputFieldGroup.actions && (_mappingJson$inputFie = mappingJson.inputFieldGroup.actions[0]) !== null && _mappingJson$inputFie !== void 0 && _mappingJson$inputFie.delimiter) {
      var _TransitionModel$deli, _mappingJson$inputFie2;

      mapping.transition.delimiter = (_TransitionModel$deli = TransitionModel.delimiterToModel((_mappingJson$inputFie2 = mappingJson.inputFieldGroup.actions[0]) === null || _mappingJson$inputFie2 === void 0 ? void 0 : _mappingJson$inputFie2.delimiter)) === null || _TransitionModel$deli === void 0 ? void 0 : _TransitionModel$deli.delimiter; // Check for an InputFieldGroup containing a many-to-one action

      var firstAction = mappingJson.inputFieldGroup.actions[0];

      if (firstAction) {
        // @deprecated Support legacy ADM files that have transformation-action-based expressions.
        if (firstAction.Expression || firstAction['@type'] === 'Expression') {
          mapping.transition.enableExpression = true;
          mapping.transition.mode = TransitionMode.EXPRESSION;
          mapping.transition.expression = new ExpressionModel(mapping, cfg);
          var expr = firstAction.Expression ? firstAction.Expression.expression : firstAction['expression'];
          mapping.transition.expression.insertText(expr);
        } else {
          mapping.transition.mode = TransitionMode.MANY_TO_ONE;
          var parsedAction = this.parseAction(firstAction); // TODO: check this non null operator

          parsedAction.definition = cfg.fieldActionService.getActionDefinitionForName(parsedAction.name, Multiplicity.MANY_TO_ONE);
          mapping.transition.transitionFieldAction = parsedAction;
        }
      }
    }
  };

  MappingSerializer.deserializeAudits = function deserializeAudits(audits, errorType) {
    var errors = [];

    if (!(audits !== null && audits !== void 0 && audits.audit)) {
      return errors;
    }

    for (var _iterator9 = _createForOfIteratorHelperLoose(audits.audit), _step9; !(_step9 = _iterator9()).done;) {
      var audit = _step9.value;
      var msg = audit.status + '[' + audit.path + ']: ' + audit.message;
      errors.push(new ErrorInfo({
        message: msg,
        level: ErrorLevel[audit.status],
        scope: ErrorScope.MAPPING,
        type: errorType,
        object: audit.value
      }));
    }

    return errors;
  };

  MappingSerializer.createInputFieldGroup = function createInputFieldGroup(field, isComplex, docId, path) {
    var inputFieldGroup = {
      jsonType: FIELD_GROUP_JSON_TYPE,
      actions: [],
      docId: docId,
      path: path,
      field: field
    };

    if (isComplex) {
      inputFieldGroup.fieldType = FieldType.COMPLEX;
    }

    return inputFieldGroup;
  };

  MappingSerializer.serializeDocuments = function serializeDocuments(docs, mappingDefinition) {
    var serializedDocs = [];

    for (var _iterator10 = _createForOfIteratorHelperLoose(docs), _step10; !(_step10 = _iterator10()).done;) {
      var doc = _step10.value;
      var serializedDoc = {
        jsonType: DATA_SOURCE_JSON_TYPE,
        id: doc.id,
        name: doc.name,
        description: doc.description,
        uri: doc.uri,
        dataSourceType: doc.isSource ? DataSourceType.SOURCE : DataSourceType.TARGET
      };

      if (doc.characterEncoding != null) {
        serializedDoc.characterEncoding = doc.characterEncoding;
      }

      if (doc.locale != null) {
        serializedDoc.locale = doc.locale;
      }

      if (doc.type === DocumentType.XML || doc.type === DocumentType.XSD) {
        var xmlDoc = serializedDoc;
        xmlDoc.jsonType = XML_DATA_SOURCE_JSON_TYPE;
        var namespaces = [];

        for (var _iterator11 = _createForOfIteratorHelperLoose(doc.namespaces), _step11; !(_step11 = _iterator11()).done;) {
          var ns = _step11.value;
          namespaces.push({
            alias: ns.alias,
            uri: ns.uri,
            locationUri: ns.locationUri,
            targetNamespace: ns.isTarget
          });
        }

        if (!doc.isSource && mappingDefinition.templateText) {
          xmlDoc.template = mappingDefinition.templateText;
        }

        xmlDoc.xmlNamespaces = {
          xmlNamespace: namespaces
        };
      } else if (doc.type === DocumentType.JSON) {
        var jsonDoc = serializedDoc;

        if (!doc.isSource && mappingDefinition.templateText) {
          jsonDoc.template = mappingDefinition.templateText;
        }

        jsonDoc.jsonType = JSON_DATA_SOURCE_JSON_TYPE;
      }

      serializedDocs.push(serializedDoc);
    }

    return serializedDocs;
  };

  MappingSerializer.serializeConstants = function serializeConstants(docDef) {
    var constantDescriptions = [];

    for (var _iterator12 = _createForOfIteratorHelperLoose(docDef.fields), _step12; !(_step12 = _iterator12()).done;) {
      var field = _step12.value;
      // Use the constant value for the name.
      constantDescriptions.push({
        name: field.name,
        value: field.value,
        fieldType: field.type
      });
    }

    return constantDescriptions;
  };

  MappingSerializer.serializeProperties = function serializeProperties(docDef) {
    var propertyDescriptions = [];

    for (var _iterator13 = _createForOfIteratorHelperLoose(docDef.fields), _step13; !(_step13 = _iterator13()).done;) {
      var field = _step13.value;
      propertyDescriptions.push({
        name: field.name,
        fieldType: field.type,
        scope: field.scope,
        dataSourceType: docDef.isSource ? DataSourceType.SOURCE : DataSourceType.TARGET
      });
    }

    return propertyDescriptions;
  };

  MappingSerializer.serializeLookupTables = function serializeLookupTables(mappingDefinition) {
    var serializedTables = [];
    var tables = mappingDefinition.getTables();

    if (!tables || !tables.length) {
      return serializedTables;
    }

    for (var _iterator14 = _createForOfIteratorHelperLoose(tables), _step14; !(_step14 = _iterator14()).done;) {
      var table = _step14.value;
      var lookupEntries = [];

      for (var _iterator15 = _createForOfIteratorHelperLoose(table.lookupEntry), _step15; !(_step15 = _iterator15()).done;) {
        var entry = _step15.value;
        var serializedEntry = {
          sourceValue: entry.sourceValue,
          sourceType: entry.sourceType,
          targetValue: entry.targetValue,
          targetType: entry.targetType
        };
        lookupEntries.push(serializedEntry);
      }

      var serializedTable = {
        lookupEntry: lookupEntries,
        name: table.name
      };
      serializedTables.push(serializedTable);
    }

    return serializedTables;
  }
  /**
   * Generate serialized meta-data representing a direct-reference instance collection preview.
   *
   * @param cfg
   * @param mapping
   * @param field
   * @param serializedField
   * @param fieldsJson
   */
  ;

  MappingSerializer.processCollectionPreview = function processCollectionPreview(field, serializedField, fieldsJson) {
    serializedField.path = field.path.replace('<>', '<0>');
    var collectionInstanceInputFieldGroup = MappingSerializer.createInputFieldGroup([serializedField], true, field.docDef.id, field.path);
    fieldsJson.push(collectionInstanceInputFieldGroup);
  }
  /**
   * Serialize field action arguments.
   *
   * @param action
   * @param cfg
   */
  ;

  MappingSerializer.processActionArguments = function processActionArguments(action, cfg) {
    var actionArguments = {};

    if (action === null) {
      return actionArguments;
    }

    for (var _iterator16 = _createForOfIteratorHelperLoose(action.argumentValues), _step16; !(_step16 = _iterator16()).done;) {
      var _action$definition;

      var argValue = _step16.value;

      if ((_action$definition = action.definition) !== null && _action$definition !== void 0 && _action$definition.isCustom && ['methodName', 'className', 'name'].includes(argValue.name)) {
        continue;
      }

      actionArguments[argValue.name] = argValue.value;
      var argumentConfig = action.definition.getArgumentForName(argValue.name);

      if (argumentConfig == null) {
        cfg.errorService.addError(new ErrorInfo({
          message: "Cannot find action argument " + argValue.name + ": " + argValue.value,
          level: ErrorLevel.ERROR,
          scope: ErrorScope.APPLICATION,
          type: ErrorType.INTERNAL,
          object: action
        }));
        continue;
      }

      if (argumentConfig.type === 'INTEGER') {
        actionArguments[argValue.name] = parseInt(argValue.value, 10);
      }
    }

    return actionArguments;
  };

  MappingSerializer.serializeFields = function serializeFields(mapping, isSource, cfg, ignoreValue) {
    if (ignoreValue === void 0) {
      ignoreValue = false;
    }

    var collectionInputFieldGroup = null;
    var collectionInstanceInputFieldGroup = null;
    var fields = mapping.getMappedFields(isSource);
    var fieldsJson = [];

    for (var _iterator17 = _createForOfIteratorHelperLoose(fields), _step17; !(_step17 = _iterator17()).done;) {
      var _field$documentField$;

      var mappedField = _step17.value;

      if (!mappedField.field || mappedField.isPadField()) {
        continue;
      }

      var field = mappedField.field;
      var serializedField = {
        jsonType: field.documentField.jsonType,
        name: field.name,
        path: field.path,
        fieldType: field.type,
        docId: field.docDef.id
      }; // The 'attribute' field only applies to XML.

      if ((_field$documentField$ = field.documentField.jsonType) !== null && _field$documentField$ !== void 0 && _field$documentField$.includes(XML_MODEL_PACKAGE_PREFIX)) {
        serializedField.attribute = field.isAttribute;
      } // Only capture a value for preview mode and constants.


      if (!ignoreValue || field.isConstant()) {
        if (field.value) {
          serializedField.value = field.value;
        } else {
          serializedField.value = '';
        }
      }

      if (field.docDef.type === DocumentType.XML || field.docDef.type === DocumentType.XSD) {
        serializedField.userCreated = field.userCreated;
      } else if (field.docDef.type === DocumentType.JAVA && !field.isPrimitive) {
        serializedField.className = field.classIdentifier;
      }

      if (field.isProperty()) {
        serializedField.jsonType = PROPERTY_FIELD_JSON_TYPE;
        serializedField.name = field.name;
        serializedField.scope = field.scope;
        serializedField.path = cfg.documentService.getPropertyPath(field.scope, field.name);
      } else if (field.isConstant()) {
        serializedField.jsonType = CONSTANT_FIELD_JSON_TYPE;
        serializedField.name = field.name;
      } else if (field.enumeration) {
        if (field.docDef.type === DocumentType.JSON) {
          serializedField.jsonType = JSON_ENUM_FIELD_JSON_TYPE;
        } else if (field.docDef.type === DocumentType.XML || field.docDef.type === DocumentType.XSD) {
          serializedField.jsonType = XML_ENUM_FIELD_JSON_TYPE;
        } else {
          serializedField.jsonType = JAVA_ENUM_FIELD_JSON_TYPE;
        }
      }

      var includeIndexes = mapping.getMappedFields(isSource).length > 1;
      includeIndexes = includeIndexes || mapping.transition.isExpressionMode() && isSource;

      if (includeIndexes) {
        // TODO: check this non null operator
        serializedField.index = mapping.getIndexForMappedField(mappedField) - 1;
      }

      if (field.docDef.type === DocumentType.CSV) {
        serializedField.column = field.column;
      }

      this.serializeActions(cfg, mappedField, serializedField); // Check for collection field references.

      if (isSource && field.isInCollection()) {
        var collectionParentField = field.getCollectionParentField();

        if (!mapping.referenceFieldExists(collectionParentField.docDef.id, collectionParentField.path)) {
          if (!ignoreValue) {
            MappingSerializer.processCollectionPreview(field, serializedField, fieldsJson);
          } else {
            fieldsJson.push(serializedField);
            collectionInputFieldGroup = null;
          }
        } else {
          // Establish/add to the inner reference field group.
          if (collectionInstanceInputFieldGroup === null) {
            collectionInstanceInputFieldGroup = MappingSerializer.createInputFieldGroup([serializedField], true, collectionParentField.docDef.id, collectionParentField.path);
          } else {
            collectionInstanceInputFieldGroup.field.push(serializedField);
            continue;
          }

          collectionInstanceInputFieldGroup.fieldType = collectionParentField.documentField.fieldType; // Preview-mode uses element/ item instance <0>.

          if (!ignoreValue) {
            collectionInstanceInputFieldGroup.path = collectionParentField.path.replace('<>', '<0>'); // Establish one outer input field group for the preview collection.

            if (collectionInputFieldGroup === null) {
              collectionInputFieldGroup = MappingSerializer.createInputFieldGroup([collectionInstanceInputFieldGroup], true, collectionParentField.docDef.id, collectionParentField.path);
              collectionInstanceInputFieldGroup.fieldType = collectionParentField.documentField.fieldType;
              fieldsJson.push(collectionInputFieldGroup);
            }
          } else {
            fieldsJson.push(collectionInstanceInputFieldGroup);
          }
        } // Non-aggregate field reference.

      } else {
        fieldsJson.push(serializedField);
        collectionInputFieldGroup = null;
      }
    }

    return fieldsJson;
  }
  /**
   * Walk the list of actions associated with the specified mapped field and serialize them into JSON.
   *
   * @param cfg
   * @param mappedField
   * @param serializedField
   */
  ;

  MappingSerializer.serializeActions = function serializeActions(cfg, mappedField, serializedField) {
    if (mappedField.actions.length) {
      var actions = [];

      for (var _iterator18 = _createForOfIteratorHelperLoose(mappedField.actions), _step18; !(_step18 = _iterator18()).done;) {
        var action = _step18.value;
        var actionJson = this.serializeAction(action, cfg);

        if (actionJson) {
          actions.push(actionJson);
        }
      }

      if (actions.length > 0) {
        serializedField.actions = actions;
      }
    }
  };

  MappingSerializer.serializeAction = function serializeAction(action, cfg) {
    var actionJson = MappingSerializer.processActionArguments(action, cfg);
    actionJson['@type'] = action.definition.name;
    return actionJson;
  };

  MappingSerializer.deserializeDocs = function deserializeDocs(json, mappingDefinition) {
    var docs = [];

    if (!json || !json.AtlasMapping || !json.AtlasMapping.dataSource) {
      return null;
    }

    for (var _iterator19 = _createForOfIteratorHelperLoose(json.AtlasMapping.dataSource), _step19; !(_step19 = _iterator19()).done;) {
      var docRef = _step19.value;
      var doc = new DocumentDefinition();
      doc.isSource = docRef.dataSourceType === 'SOURCE';
      doc.uri = docRef.uri;
      doc.id = docRef.id;
      doc.name = docRef.name ? docRef.name : '';
      doc.description = docRef.description;
      var xmlDocRef = docRef;

      if (xmlDocRef.xmlNamespaces && xmlDocRef.xmlNamespaces.xmlNamespace) {
        for (var _iterator20 = _createForOfIteratorHelperLoose(xmlDocRef.xmlNamespaces.xmlNamespace), _step20; !(_step20 = _iterator20()).done;) {
          var svcNS = _step20.value;
          var ns = new NamespaceModel();
          ns.alias = svcNS.alias;
          ns.uri = svcNS.uri;
          ns.locationUri = svcNS.locationUri;
          ns.isTarget = svcNS.targetNamespace ? svcNS.targetNamespace : false;
          ns.createdByUser = true;
          doc.namespaces.push(ns);
        }
      }

      if (xmlDocRef.template) {
        mappingDefinition.templateText = xmlDocRef.template;
      }

      docs.push(doc);
    }

    return docs;
  };

  MappingSerializer.deserializeMappings = function deserializeMappings(json, cfg) {
    var _json$AtlasMapping$ma;

    var mappings = [];

    if (!((_json$AtlasMapping$ma = json.AtlasMapping.mappings) !== null && _json$AtlasMapping$ma !== void 0 && _json$AtlasMapping$ma.mapping)) {
      return mappings;
    }

    for (var _iterator21 = _createForOfIteratorHelperLoose(json.AtlasMapping.mappings.mapping), _step21; !(_step21 = _iterator21()).done;) {
      var fieldMapping = _step21.value;
      // for backward compatibility
      var isCollectionMapping = fieldMapping.jsonType === COLLECTION_JSON_TYPE;

      if (isCollectionMapping) {
        var collection = fieldMapping;

        for (var _iterator22 = _createForOfIteratorHelperLoose(collection.mappings.mapping), _step22; !(_step22 = _iterator22()).done;) {
          var innerFieldMapping = _step22.value;
          mappings.push(MappingSerializer.deserializeFieldMapping(innerFieldMapping, cfg));
        }
      } else {
        mappings.push(MappingSerializer.deserializeFieldMapping(fieldMapping, cfg));
      }
    }

    return mappings;
  }
  /**
   * @deprecated Deserialize a field mapping based on its mapping type.  This is deprecated in favor of
   * concatenate/ split actions.
   *
   * @param mapping
   * @param fieldMapping
   * @param docRefs
   * @param cfg
   * @param ignoreValue
   */
  ;

  MappingSerializer.deserializeFieldMappingFromType = function deserializeFieldMappingFromType(mapping, fieldMapping, cfg) {
    if (fieldMapping.mappingType === 'SEPARATE') {
      mapping.transition.mode = TransitionMode.ONE_TO_MANY;
      mapping.transition.transitionFieldAction = FieldAction.create(cfg.fieldActionService.getActionDefinitionForName('Split', Multiplicity.ONE_TO_MANY)); // TODO: check this non null operator

      mapping.transition.transitionFieldAction.setArgumentValue('delimiter', fieldMapping.delimiter);
    } else if (fieldMapping.mappingType === 'LOOKUP') {
      mapping.transition.mode = TransitionMode.ENUM;
      mapping.transition.lookupTableName = fieldMapping.lookupTableName;
    } else if (fieldMapping.mappingType === 'COMBINE') {
      mapping.transition.mode = TransitionMode.MANY_TO_ONE;
      mapping.transition.transitionFieldAction = FieldAction.create(cfg.fieldActionService.getActionDefinitionForName('Concatenate', Multiplicity.MANY_TO_ONE)); // TODO: check this non null operator

      mapping.transition.transitionFieldAction.setArgumentValue('delimiter', fieldMapping.delimiter);
    } else {
      mapping.transition.mode = TransitionMode.ONE_TO_ONE;
    }

    for (var _iterator23 = _createForOfIteratorHelperLoose(fieldMapping.inputField), _step23; !(_step23 = _iterator23()).done;) {
      var field = _step23.value;
      MappingSerializer.deserializeMappedField(mapping, field, true, cfg);
    }

    for (var _iterator24 = _createForOfIteratorHelperLoose(fieldMapping.outputField), _step24; !(_step24 = _iterator24()).done;) {
      var _field4 = _step24.value;
      MappingSerializer.deserializeMappedField(mapping, _field4, false, cfg);
    }

    MappingUtil.updateMappedFieldsFromDocuments(mapping, cfg, true);
  };

  MappingSerializer.deserializeConstants = function deserializeConstants(jsonMapping) {
    var _jsonMapping$AtlasMap, _jsonMapping$AtlasMap2;

    var fields = [];

    if (!(jsonMapping !== null && jsonMapping !== void 0 && (_jsonMapping$AtlasMap = jsonMapping.AtlasMapping) !== null && _jsonMapping$AtlasMap !== void 0 && (_jsonMapping$AtlasMap2 = _jsonMapping$AtlasMap.constants) !== null && _jsonMapping$AtlasMap2 !== void 0 && _jsonMapping$AtlasMap2.constant)) {
      return fields;
    }

    for (var _iterator25 = _createForOfIteratorHelperLoose(jsonMapping.AtlasMapping.constants.constant), _step25; !(_step25 = _iterator25()).done;) {
      var constant = _step25.value;
      var field = new Field();
      field.name = constant.name;
      field.path = FIELD_PATH_SEPARATOR + field.name;
      field.value = constant.value;
      field.type = constant.fieldType;
      field.userCreated = true;
      field.isAttribute = false;
      fields.push(field);
    }

    return fields;
  };

  MappingSerializer.deserializeProperties = function deserializeProperties(cfg, jsonMapping, isSource) {
    var _jsonMapping$AtlasMap3, _jsonMapping$AtlasMap4;

    var fields = [];

    if (!(jsonMapping !== null && jsonMapping !== void 0 && (_jsonMapping$AtlasMap3 = jsonMapping.AtlasMapping) !== null && _jsonMapping$AtlasMap3 !== void 0 && (_jsonMapping$AtlasMap4 = _jsonMapping$AtlasMap3.properties) !== null && _jsonMapping$AtlasMap4 !== void 0 && _jsonMapping$AtlasMap4.property)) {
      return fields;
    } // Source and target properties are mixed in the 'property' JSON array.


    for (var _iterator26 = _createForOfIteratorHelperLoose(jsonMapping.AtlasMapping.properties.property), _step26; !(_step26 = _iterator26()).done;) {
      var property = _step26.value;

      if (isSource && property.dataSourceType === DataSourceType.TARGET || !isSource && property.dataSourceType !== DataSourceType.TARGET) {
        continue;
      }

      var field = new Field();
      field.name = property.name;
      field.type = property.fieldType;
      field.scope = property.scope;
      field.path = cfg.documentService.getPropertyPath(field.scope, field.name);
      field.userCreated = true;
      field.isAttribute = false;
      fields.push(field);
    }

    return fields;
  };

  MappingSerializer.deserializeLookupTables = function deserializeLookupTables(jsonMapping) {
    var tables = [];

    if (!jsonMapping || !jsonMapping.AtlasMapping || !jsonMapping.AtlasMapping.lookupTables || !jsonMapping.AtlasMapping.lookupTables.lookupTable) {
      return tables;
    }

    for (var _iterator27 = _createForOfIteratorHelperLoose(jsonMapping.AtlasMapping.lookupTables.lookupTable), _step27; !(_step27 = _iterator27()).done;) {
      var table = _step27.value;
      var parsedTable = new LookupTable();
      parsedTable.name = table.name;

      for (var _iterator28 = _createForOfIteratorHelperLoose(table.lookupEntry), _step28; !(_step28 = _iterator28()).done;) {
        var entry = _step28.value;
        var parsedEntry = new LookupTableEntry();
        parsedEntry.sourceValue = entry.sourceValue;
        parsedEntry.sourceType = entry.sourceType;
        parsedEntry.targetValue = entry.targetValue;
        parsedEntry.targetType = entry.targetType;
        parsedTable.lookupEntry.push(parsedEntry);
      }

      tables.push(parsedTable);
    }

    return tables;
  }
  /**
   * Walk the list of field actions found in the parsed data and restore them to the live mapping.
   *
   * @param field
   * @param mappedField
   * @param mapping
   * @param cfg
   * @param isSource
   */
  ;

  MappingSerializer.deserializeFieldActions = function deserializeFieldActions(field, mappedField, mapping, cfg, isSource) {
    if (!field.actions) {
      return;
    }

    for (var _iterator29 = _createForOfIteratorHelperLoose(field.actions), _step29; !(_step29 = _iterator29()).done;) {
      var action = _step29.value;
      var parsedAction = this.parseAction(action);

      if (action.name === 'CustomAction') {
        parsedAction.definition = cfg.fieldActionService.getActionDefinitionForName(action.argumentValues[0].value, Multiplicity.ONE_TO_ONE);
      } else {
        parsedAction.definition = cfg.fieldActionService.getActionDefinitionForName(parsedAction.name);
      }

      if (parsedAction.definition == null) {
        cfg.errorService.addError(new ErrorInfo({
          message: "Could not find field action definition for action '" + action.name + "'",
          level: ErrorLevel.ERROR,
          scope: ErrorScope.APPLICATION,
          type: ErrorType.INTERNAL
        }));
        continue;
      }

      parsedAction.definition.populateFieldAction(parsedAction);
      /** @deprecated Support old-style transformation-action-based expressions. */

      if (isSource && (action.Expression || action['@type'] === 'Expression')) {
        mapping.transition.enableExpression = true;
        mapping.transition.expression = new ExpressionModel(mapping, cfg);
        var expr = action.Expression ? action.Expression.expression : action['expression'];
        mapping.transition.expression.insertText(expr);
      } else if (isSource && parsedAction.definition && [Multiplicity.ONE_TO_MANY, Multiplicity.MANY_TO_ONE].includes(parsedAction.definition.multiplicity)) {
        if (mapping.transition.transitionFieldAction) {
          cfg.logger.warn("Duplicated multiplicity transformations were detected:               " + mapping.transition.transitionFieldAction.name + " is being overwritten by " + parsedAction.name + " ...");
        }

        mapping.transition.transitionFieldAction = parsedAction;
      } else {
        mappedField.actions.push(parsedAction);
      }
    }
  };

  MappingSerializer.deserializeMappedField = function deserializeMappedField(mapping, field, isSource, cfg) {
    if (MappingUtil.isConstantField(field)) {
      if (field.docId) {
        cfg.constantDoc.id = field.docId;
      } else {
        field.docId = cfg.constantDoc.id;
      }
    } else if (MappingUtil.isPropertyField(field)) {
      var doc = isSource ? cfg.sourcePropertyDoc : cfg.targetPropertyDoc;

      if (field.docId) {
        doc.id = field.docId;
      } else {
        field.docId = doc.id;
      }

      field.path = cfg.documentService.getPropertyPath(field.scope, field.name);
    } else if (!field.docId) {
      cfg.errorService.addError(new ErrorInfo({
        message: 'Parsed mapping field does not have document id, dropping.',
        level: ErrorLevel.ERROR,
        scope: ErrorScope.APPLICATION,
        type: ErrorType.INTERNAL,
        object: field
      }));
      return null;
    }

    var mappedField = new MappedField();
    mappedField.mappingField = field;
    mapping.addMappedField(mappedField, isSource);

    if (field.actions) {
      this.deserializeFieldActions(field, mappedField, mapping, cfg, isSource);
    }

    return mappedField;
  };

  MappingSerializer.parseAction = function parseAction(action) {
    if (action['@type']) {
      return MappingSerializer.parseNewAction(action);
    } else {
      // TODO: check this non null operator
      return MappingSerializer.parseOldAction(action);
    }
  }
  /**
   * @deprecated actionName: {param:...} style has been deprecated. Use {`@type`: actionName} style action description.
   */
  ;

  MappingSerializer.parseOldAction = function parseOldAction(action) {
    for (var _i = 0, _Object$keys = Object.keys(action); _i < _Object$keys.length; _i++) {
      var actionName = _Object$keys[_i];

      if (!action.hasOwnProperty(actionName)) {
        return null;
      }

      var parsedAction = new FieldAction();
      parsedAction.name = actionName;
      var actionParams = action[actionName];

      if (actionParams) {
        for (var _i2 = 0, _Object$keys2 = Object.keys(actionParams); _i2 < _Object$keys2.length; _i2++) {
          var paramName = _Object$keys2[_i2];

          if (!actionParams.hasOwnProperty(paramName)) {
            return null;
          }

          var parsedArgumentValue = new FieldActionArgumentValue();
          parsedArgumentValue.name = paramName;
          var value = actionParams[paramName];
          value = value == null ? null : value.toString();
          parsedArgumentValue.value = value;
          parsedAction.argumentValues.push(parsedArgumentValue);
        }
      }

      return parsedAction;
    }

    return null;
  };

  MappingSerializer.parseNewAction = function parseNewAction(action) {
    var parsedAction = new FieldAction();
    parsedAction.name = action['@type'];

    for (var _i3 = 0, _Object$entries = Object.entries(action); _i3 < _Object$entries.length; _i3++) {
      var _Object$entries$_i = _Object$entries[_i3],
          key = _Object$entries$_i[0],
          value = _Object$entries$_i[1];

      if ('@type' === key) {
        continue;
      }

      var parsedArgumentValue = new FieldActionArgumentValue();
      parsedArgumentValue.name = key;
      var valueString = value == null ? null : value.toString();
      parsedArgumentValue.value = valueString;
      parsedAction.argumentValues.push(parsedArgumentValue);
    }

    return parsedAction;
  };

  return MappingSerializer;
}();

/**
 * Manages Document object lifecycle. Import a Document source
 * such as JSON/XML schema/instance, request an inspection to the backend,
 * then enable it for mapping by consuming inspection result in UI.
 */

var DocumentManagementService = /*#__PURE__*/function () {
  function DocumentManagementService(api) {
    this.api = api;
    this.MAX_SEARCH_MATCH = 10000;
  }

  var _proto = DocumentManagementService.prototype;

  _proto.initialize = function initialize() {
    var _this = this;

    this.mappingUpdatedSubscription = this.cfg.mappingService.mappingUpdated$.subscribe(function () {
      for (var _iterator = _createForOfIteratorHelperLoose(_this.cfg.getAllDocs()), _step; !(_step = _iterator()).done;) {
        var d = _step.value;

        if (d.initialized) {
          d.updateFromMappings(_this.cfg.mappings); // TODO: check this non null operator
        }
      }
    });
  };

  _proto.uninitialize = function uninitialize() {
    this.mappingUpdatedSubscription.unsubscribe();
  }
  /**
   * Request Document inspection for each {@link DocumentDefinition} object
   * stored in {@link ConfigModel} and populate it back with the inspection result.
   *
   * @returns
   */
  ;

  _proto.inspectDocuments = function inspectDocuments() {
    var _this2 = this;

    return new Observable(function (observer) {
      var _loop = function _loop() {
        var docDef = _step2.value;

        if (docDef === _this2.cfg.sourcePropertyDoc || docDef === _this2.cfg.targetPropertyDoc || docDef === _this2.cfg.constantDoc) {
          docDef.initialized = true;
          return "continue";
        }

        var inspectionModel = DocumentInspectionUtil.fromDocumentDefinition(_this2.cfg, docDef); // TODO: check this non null operator

        _this2.inspectDocument(inspectionModel).then(function () {
          observer.next(docDef);
        })["catch"](function (error) {
          observer.error(error);
        });
      };

      for (var _iterator2 = _createForOfIteratorHelperLoose(_this2.cfg.getAllDocs()), _step2; !(_step2 = _iterator2()).done;) {
        var _ret = _loop();

        if (_ret === "continue") continue;
      }
    });
  };

  _proto.inspectDocument = function inspectDocument(inspectionModel) {
    var _this3 = this;

    return new Promise(function (resolve, reject) {
      var docDef = inspectionModel.doc;

      if (docDef.inspectionResult) {
        var responseJson = JSON.parse(docDef.inspectionResult);
        inspectionModel.parseResponse(responseJson);
        docDef.initializeFromFields();
        docDef.initialized = true;
        resolve(docDef);
        return;
      }

      if (!inspectionModel.isOnlineInspectionCapable()) {
        docDef.initialized = true;
        docDef.errorOccurred = true;
        reject(docDef);
        return;
      }

      var request = inspectionModel.request;

      _this3.cfg.logger.debug("Document Inspection Request: " + JSON.stringify(request.options.json));

      _this3.api.post(request.url, request.options).json().then(function (responseJson) {
        _this3.cfg.logger.debug("Document Inspection Response: " + JSON.stringify(responseJson));

        inspectionModel.parseResponse(responseJson);
        docDef.initializeFromFields();
        docDef.initialized = true;
        resolve(docDef);
      })["catch"](function (error) {
        _this3.cfg.errorService.addBackendError("Failed to inspect Document: " + docDef.name + "(" + docDef.id + ")", error);

        reject(error);
      });
    });
  };

  _proto.getLibraryClassNames = function getLibraryClassNames() {
    var _this4 = this;

    return new Promise(function (resolve, reject) {
      if (typeof _this4.cfg.initCfg.baseMappingServiceUrl === 'undefined') {
        resolve([]);
        return;
      }

      var url = _this4.cfg.initCfg.baseMappingServiceUrl + 'library/list';

      _this4.cfg.logger.debug('Library Class List Service Request: ' + url);

      _this4.api.get(url).json().then(function (body) {
        _this4.cfg.logger.debug("Library Class List Service Response: " + JSON.stringify(body));

        var classNames = body.ArrayList;
        resolve(classNames);
      })["catch"](function (error) {
        if (error.status !== HTTP_STATUS_NO_CONTENT) {
          _this4.cfg.errorService.addBackendError('Error occurred while accessing the user uploaded JARs from the runtime service.', error);

          reject(error);
        } else {
          resolve([]);
        }
      });
    });
  }
  /**
   * Import user uploaded Document source such as JSON/XML schema/instance, assign
   * a unique Document ID with using GUID and delegate to {@link addNonJavaDocument}
   * to make it available  as a Document for mappings.
   * @see addNonJavaDocument
   *
   * @param selectedFile - user selected file
   * @param isSource - true is source panel, false is target
   * @param isSchema- user specified instance/ schema (true === schema)
   * @param inspectionParameters - CSV parameters
   *
   */
  ;

  _proto.importNonJavaDocument = function importNonJavaDocument(selectedFile, isSource, isSchema, inspectionParameters) {
    var _this5 = this;

    return new Promise(function (resolve) {
      try {
        var _exit2 = false;

        var _temp3 = function _temp3(_result) {
          if (_exit2) return _result;
          var docType = undefined;

          try {
            docType = userFileSuffix;

            if (!docType) {
              throw new Error(docType);
            }
          } catch (error) {
            _this5.handleError('Unrecognized document suffix (' + userFileSuffix + ')');

            resolve(false);
            return;
          }

          _this5.addNonJavaDocument(fileText, userFile + '-' + Guid.newGuid(), userFile, docType, isSchema ? InspectionType.SCHEMA : InspectionType.INSTANCE, isSource, inspectionParameters).then(function (value) {
            if (!value) {
              resolve(false);
              return;
            }

            _this5.cfg.errorService.addError(new ErrorInfo({
              message: selectedFile.name + " " + userFileSuffix + " import complete.",
              level: ErrorLevel.INFO,
              scope: ErrorScope.APPLICATION,
              type: ErrorType.USER
            }));

            resolve(true);
          });
        };

        var fileText = '';
        var reader = new FileReader();

        _this5.cfg.errorService.clearValidationErrors();

        var userFileComps = selectedFile.name.split('.');
        var userFile = userFileComps.slice(0, -1).join('.');
        var userFileSuffix = userFileComps[userFileComps.length - 1].toUpperCase(); // Wait for the async read of the selected ascii document to be completed.

        var _temp4 = _catch(function () {
          return Promise.resolve(CommonUtil.readFile(selectedFile, reader)).then(function (_CommonUtil$readFile) {
            fileText = _CommonUtil$readFile;
          });
        }, function (error) {
          _this5.cfg.errorService.addError(new ErrorInfo({
            message: 'Unable to import the specified schema document.',
            level: ErrorLevel.ERROR,
            scope: ErrorScope.APPLICATION,
            type: ErrorType.USER,
            object: error
          }));

          resolve(false);
          _exit2 = true;
        });

        return Promise.resolve(_temp4 && _temp4.then ? _temp4.then(_temp3) : _temp3(_temp4));
      } catch (e) {
        return Promise.reject(e);
      }
    });
  }
  /**
   * Import a Java class as a Document source and delegate to {@link addJavaDocument}
   * to make it available  as a Document for mappings.
   * JAR file(s) have to be imported and be available in the backend classpath
   * before doing this.
   * @see addJavaDocument
   * @todo https://github.com/atlasmap/atlasmap/issues/2919
   * A unique Document ID should be assigned with using GUID.
   *
   * @param className
   * @param isSource
   * @param collectionType
   * @param collectionClassName
   */
  ;

  _proto.importJavaDocument = function importJavaDocument(className, isSource, collectionType, collectionClassName) {
    if (collectionType === void 0) {
      collectionType = CollectionType.NONE;
    }

    this.cfg.errorService.clearValidationErrors();
    return this.addJavaDocument(className, isSource, collectionType, collectionClassName);
  }
  /**
   * Add non-Java Document object into the {@link ConfigModel} store and
   * delegate to {@link doAddDocument}.
   * @see doAddDocument
   *
   * @param docBody
   * @param docId
   * @param docName
   * @param docType
   * @param inspectionType
   * @param isSource
   * @param parameters
   */
  ;

  _proto.addNonJavaDocument = function addNonJavaDocument(docBody, docId, docName, docType, inspectionType, isSource, parameters) {
    var inspectionModel = DocumentInspectionUtil.fromNonJavaProperties(this.cfg, docId, docName, docType, inspectionType, docBody, isSource, parameters);
    return this.doAddDocument(inspectionModel);
  }
  /**
   * Add Java Document object into the {@link ConfigModel} store and
   * delegate to {@link doAddDocument}.
   * @see doAddDocument
   *
   * @param className
   * @param isSource
   * @param collectionType {@link CollectionType}
   * @param collectionClassName
   */
  ;

  _proto.addJavaDocument = function addJavaDocument(className, isSource, collectionType, collectionClassName) {
    if (collectionType === void 0) {
      collectionType = CollectionType.NONE;
    }

    var inspectionModel = DocumentInspectionUtil.fromJavaProperties(this.cfg, className, isSource, collectionType, collectionClassName);
    return this.doAddDocument(inspectionModel);
  }
  /**
   * An utility method to look at the {@link DocumentType} passed in as an argument
   * and see if it's a Java or non-Java Document, then delegate to
   * {@link addJavaDocument} or {@link addNonJavaDocument}.
   *
   * @todo https://github.com/atlasmap/atlasmap/issues/2918
   * {@link CollectionType} and collectionClassName has to be persisted into digest
   * so it could be restored here
   */
  ;

  _proto.addDocument = function addDocument(docBody, docId, docName, docType, inspectionType, isSource, parameters) {
    if (docType === DocumentType.JAVA) {
      return this.addJavaDocument(docId, isSource);
    }

    return this.addNonJavaDocument(docBody, docId, docName, docType, inspectionType, isSource, parameters);
  }
  /**
   * Add or replace the {@link DocumentDefinition} object stored in {@link ConfigModel}
   * and delegate to {@link inspectDocument} to perform an inspection.
   * Then it gets available for mapping in the canvas.
   *
   * @param inspectionModel {@link DocumentInspectionModel}
   * @returns
   */
  ;

  _proto.doAddDocument = function doAddDocument(inspectionModel) {
    var _this6 = this;

    return new Promise(function (resolve) {
      try {
        var docdef = inspectionModel.doc;
        var isSource = docdef.isSource;

        _this6.inspectDocument(inspectionModel).then(function (doc) {
          try {
            if (doc.fields.length === 0) {
              if (isSource) {
                CommonUtil.removeItemFromArray(docdef, _this6.cfg.sourceDocs);
              } else {
                CommonUtil.removeItemFromArray(docdef, _this6.cfg.targetDocs);
              }
            }

            docdef.updateFromMappings(_this6.cfg.mappings);
            resolve(true);
            return Promise.resolve();
          } catch (e) {
            return Promise.reject(e);
          }
        })["catch"](function () {
          resolve(false);
        });

        return Promise.resolve();
      } catch (e) {
        return Promise.reject(e);
      }
    });
  };

  _proto.handleError = function handleError(message, error) {
    this.cfg.errorService.addError(new ErrorInfo({
      message: message,
      level: ErrorLevel.ERROR,
      scope: ErrorScope.APPLICATION,
      type: ErrorType.INTERNAL,
      object: error
    }));
  }
  /**
   * Filter Document fields that is shwon in a Source/Target Document tree.
   * @todo Consolidate with expression field search and Document Details field
   * search - https://github.com/atlasmap/atlasmap/issues/603
   * @param searchFilter
   * @param isSource
   */
  ;

  _proto.filterDocumentFields = function filterDocumentFields(searchFilter, isSource) {
    var cfg = ConfigModel.getConfig();
    var searchIsEmpty = undefined === searchFilter || '' === searchFilter;
    var defaultVisibility = searchIsEmpty;

    for (var _iterator3 = _createForOfIteratorHelperLoose(cfg.getDocs(isSource)), _step3; !(_step3 = _iterator3()).done;) {
      var docDef = _step3.value;
      docDef.visibleInCurrentDocumentSearch = defaultVisibility;

      for (var _iterator4 = _createForOfIteratorHelperLoose(docDef.getAllFields()), _step4; !(_step4 = _iterator4()).done;) {
        var _field = _step4.value;
        _field.visibleInCurrentDocumentSearch = defaultVisibility;
      }

      if (!searchIsEmpty) {
        var searchFieldCount = 0;

        for (var _iterator5 = _createForOfIteratorHelperLoose(docDef.getAllFields()), _step5; !(_step5 = _iterator5()).done;) {
          var field = _step5.value;

          // Skip this field if it's already determined to be visible.
          if (field.visibleInCurrentDocumentSearch && !field.collapsed) {
            continue;
          }

          field.visibleInCurrentDocumentSearch = field.name.toLowerCase().includes(searchFilter.toLowerCase());

          if (field.visibleInCurrentDocumentSearch) {
            docDef.visibleInCurrentDocumentSearch = true;
            var parentField = field.parentField; // Direct lineage is then visible.

            while (parentField != null && !parentField.visibleInCurrentDocumentSearch) {
              parentField.visibleInCurrentDocumentSearch = true;
              parentField.collapsed = false;
              parentField = parentField.parentField;
              searchFieldCount++;
            } // All fields below the matching field are also visible.


            try {
              this.markChildrenVisible(field);
            } catch (error) {
              cfg.errorService.addError(new ErrorInfo({
                message: error.message,
                level: ErrorLevel.INFO,
                scope: ErrorScope.APPLICATION,
                type: ErrorType.USER
              }));
              break;
            } // The total number of matches is limited to allow the UI to perform.


            if (searchFieldCount++ >= this.MAX_SEARCH_MATCH) {
              cfg.errorService.addError(new ErrorInfo({
                message: 'The maximum number of fields matching the specified search filter has beeen exceeded  ' + 'Try using a longer field filter.',
                level: ErrorLevel.INFO,
                scope: ErrorScope.APPLICATION,
                type: ErrorType.USER
              }));
              break;
            }
          }
        }
      }
    }

    cfg.mappingService.notifyLineRefresh();
  };

  _proto.markChildrenVisible = function markChildrenVisible(field) {
    field.visibleInCurrentDocumentSearch = true;
    field.collapsed = false; // if (this.searchFieldCount++ >= this.maxSearchMatch) {
    //   throw new Error('The maximum number of fields matching the specified search filter has beeen exceeded  ' +
    //     'Try using a longer field filter.');
    // }

    for (var _iterator6 = _createForOfIteratorHelperLoose(field.children), _step6; !(_step6 = _iterator6()).done;) {
      var childField = _step6.value;
      this.markChildrenVisible(childField);
    }
  }
  /**
   * Create a constant field.
   * @param constName
   * @param constValue
   * @param constType
   * @param addToActiveMapping
   */
  ;

  _proto.createConstant = function createConstant(constName, constValue, constType, addToActiveMapping) {
    var field = this.cfg.constantDoc.getField(FIELD_PATH_SEPARATOR + constName);

    if (!field) {
      field = new Field();
    }

    field.name = constName;
    field.path = FIELD_PATH_SEPARATOR + constName;
    field.value = constValue;
    field.type = FieldType[constType];
    field.docDef = this.cfg.constantDoc;
    field.userCreated = true;
    this.cfg.constantDoc.addField(field);

    if (addToActiveMapping) {
      this.cfg.mappingService.addFieldToActiveMapping(field);
    }

    this.cfg.mappingService.notifyMappingUpdated();
  }
  /**
   * Delete a constant field.
   * @param constName
   */
  ;

  _proto.deleteConstant = function deleteConstant(constName) {
    var _this$cfg$mappings, _activeMapping$transi;

    var field = this.cfg.constantDoc.getField(FIELD_PATH_SEPARATOR + constName);

    if (!field) {
      return;
    }

    this.cfg.mappingService.removeFieldFromAllMappings(field);
    this.cfg.constantDoc.removeField(field);
    var activeMapping = (_this$cfg$mappings = this.cfg.mappings) === null || _this$cfg$mappings === void 0 ? void 0 : _this$cfg$mappings.activeMapping;
    var expression = activeMapping === null || activeMapping === void 0 ? void 0 : (_activeMapping$transi = activeMapping.transition) === null || _activeMapping$transi === void 0 ? void 0 : _activeMapping$transi.expression;

    if (activeMapping && expression) {
      expression.updateFieldReference(activeMapping);
    }

    this.cfg.mappingService.notifyMappingUpdated();
  }
  /**
   * Edit a constant field. Look for an existing constant field with the specified name
   * and update the properties. If {@link origName} is specified and different from
   * {@link constName}, the name of the constant field will be changed.
   * @param constName
   * @param constValue
   * @param constType
   * @param origName
   */
  ;

  _proto.editConstant = function editConstant(constName, constValue, constType, origName) {
    var constFieldName = origName ? origName : constName;
    var field = this.cfg.constantDoc.getField(FIELD_PATH_SEPARATOR + constFieldName);

    if (!field) {
      return;
    }

    if (constType.length > 0) {
      field.type = FieldType[constType];
    }

    if (constValue.length > 0) {
      field.value = constValue;
    }

    if (origName && origName !== constName) {
      field.name = constName;
      field.path = FIELD_PATH_SEPARATOR + constName;
      this.cfg.constantDoc.updateField(field, FIELD_PATH_SEPARATOR + constName);
    }

    this.cfg.mappingService.notifyMappingUpdated();
  }
  /**
   * Get a {@link FieldType} of the constant field.
   * @param constName
   */
  ;

  _proto.getConstantType = function getConstantType(constName) {
    var cfg = ConfigModel.getConfig();
    var field = cfg.constantDoc.getField(FIELD_PATH_SEPARATOR + constName);

    if (!field) {
      return FieldType.NONE;
    }

    return field.type;
  }
  /**
   * Get an index of the constant field type.
   * @param constName
   */
  ;

  _proto.getConstantTypeIndex = function getConstantTypeIndex(constName) {
    var cfg = ConfigModel.getConfig();
    var field = cfg.constantDoc.getField(FIELD_PATH_SEPARATOR + constName);

    if (!field) {
      return 0;
    }

    for (var i = 0; i < constantTypes.length; i++) {
      if (constantTypes[i].includes(field.type)) {
        return i;
      }
    }

    return 0;
  }
  /**
   * Create a property field.
   * @param propName
   * @param propType
   * @param propScope
   * @param isSource
   * @param addToActiveMapping
   */
  ;

  _proto.createProperty = function createProperty(propName, propType, propScope, isSource, addToActiveMapping) {
    var cfg = ConfigModel.getConfig();
    var path = this.getPropertyPath(propScope, propName);
    var field = isSource ? cfg.sourcePropertyDoc.getField(path) : cfg.targetPropertyDoc.getField(path);

    if (!field) {
      field = new Field();
    }

    field.name = propName;
    field.type = FieldType[propType];
    field.scope = propScope;
    field.path = path;
    field.userCreated = true;

    if (isSource) {
      field.docDef = cfg.sourcePropertyDoc;
      cfg.sourcePropertyDoc.addField(field);
    } else {
      field.docDef = cfg.targetPropertyDoc;
      cfg.targetPropertyDoc.addField(field);
    }

    if (addToActiveMapping) {
      this.cfg.mappingService.addFieldToActiveMapping(field);
    }

    cfg.mappingService.notifyMappingUpdated();
  }
  /**
   * Delete a property field.
   * @param propName
   * @param propScope
   * @param isSource
   */
  ;

  _proto.deleteProperty = function deleteProperty(propName, propScope, isSource) {
    var _this$cfg$mappings2, _activeMapping$transi2;

    var path = this.getPropertyPath(propScope, propName);
    var field = isSource ? this.cfg.sourcePropertyDoc.getField(path) : this.cfg.targetPropertyDoc.getField(path);

    if (!field) {
      return;
    }

    this.cfg.mappingService.removeFieldFromAllMappings(field);

    if (isSource) {
      this.cfg.sourcePropertyDoc.removeField(field);
    } else {
      this.cfg.targetPropertyDoc.removeField(field);
    }

    var activeMapping = (_this$cfg$mappings2 = this.cfg.mappings) === null || _this$cfg$mappings2 === void 0 ? void 0 : _this$cfg$mappings2.activeMapping;
    var expression = activeMapping === null || activeMapping === void 0 ? void 0 : (_activeMapping$transi2 = activeMapping.transition) === null || _activeMapping$transi2 === void 0 ? void 0 : _activeMapping$transi2.expression;

    if (activeMapping && expression) {
      expression.updateFieldReference(activeMapping);
    }

    this.cfg.mappingService.notifyMappingUpdated();
  }
  /**
   * Edit a property field. When editing a property, the propName/propScope
   * is needed to fetch the existing field.  The newName and newScope may or
   * may not be specified.
   *
   * @param propName
   * @param propType
   * @param propScope
   * @param isSource
   * @param newName
   * @param newScope
   */
  ;

  _proto.editProperty = function editProperty(propName, propType, propScope, isSource, newName, newScope) {
    var oldPath = this.getPropertyPath(propScope, propName);
    var field = isSource ? this.cfg.sourcePropertyDoc.getField(oldPath) : this.cfg.targetPropertyDoc.getField(oldPath);

    if (!field) {
      return;
    }

    if (newName) {
      field.name = newName;
    }

    if (newScope) {
      field.scope = newScope;
    }

    field.type = FieldType[propType];
    field.path = this.getPropertyPath(field.scope, field.name);

    if (isSource) {
      this.cfg.sourcePropertyDoc.updateField(field, oldPath);
    } else {
      this.cfg.targetPropertyDoc.updateField(field, oldPath);
    }

    this.cfg.mappingService.notifyMappingUpdated();
  }
  /**
   * Get a {@link FieldType} of the property field.
   * @param propName
   * @param propScope
   * @param isSource
   */
  ;

  _proto.getPropertyType = function getPropertyType(propName, propScope, isSource) {
    var field = isSource ? this.cfg.sourcePropertyDoc.getField(this.getPropertyPath(propScope, propName)) : this.cfg.targetPropertyDoc.getField(this.getPropertyPath(propScope, propName));

    if (!field) {
      return FieldType.NONE;
    }

    return field.type;
  }
  /**
   * Get an index of the property field type.
   * @param propName
   * @param propScope
   * @param isSource
   */
  ;

  _proto.getPropertyTypeIndex = function getPropertyTypeIndex(propName, propScope, isSource) {
    var field = isSource ? this.cfg.sourcePropertyDoc.getField(this.getPropertyPath(propScope, propName)) : this.cfg.targetPropertyDoc.getField(this.getPropertyPath(propScope, propName));

    if (!field) {
      return 0;
    }

    for (var i = 0; i < propertyTypes.length; i++) {
      if (propertyTypes[i].includes(field.type)) {
        return i;
      }
    }

    return 0;
  };

  _proto.getPropertyPath = function getPropertyPath(scope, name) {
    var answer = FIELD_PATH_SEPARATOR;

    if (scope && scope.length > 0) {
      answer += scope + FIELD_PATH_SEPARATOR;
    }

    answer += name;
    return answer;
  };

  return DocumentManagementService;
}();

/*
    Copyright (C) 2017 Red Hat, Inc.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

            http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
*/
/**
 * ErrorHandlerService handles global errors, mapping validation errors, preview errors,
 * mapped field level errors as well as instant form validation errors in a modal windows.
 * Global errors, mapping validation errors, preview errors and mapped field level errors
 * are stored in a same array at this moment. We might want to split them when we show
 * them grouped by {@link ErrorType}.
 * Errors with {@link ErrorScope.MAPPING} and {@link ErrorScope.FIELD} are cleared
 * everytime active mapping is switched. {@link ErrorScope.FIELD} errors are mostly
 * instant and cleared more frequently.
 * Form validation errors are supposed to be instant. Channel should be created by
 * {@link createFormErrorChannel()} when modal window is initialized, and should be
 * completed when modal window is closed.
 */

var ErrorHandlerService = /*#__PURE__*/function () {
  function ErrorHandlerService() {
    this.errors = [];
    this.formErrors = [];
    this.errorUpdatedSource = new Subject();
  }
  /**
   * FIlter an array of {@link ErrorInfo} with specified condition.
   * @param errors An array of {@link ErrorInfo} to filter
   * @param mapping {@link MappingModel} to filter {@link ErrorScope.MAPPING} errors
   * @param level {@link ErrorLevel} to filter with
   */


  ErrorHandlerService.filterWith = function filterWith(errors, mapping, level) {
    if (!errors || errors.length === 0) {
      return [];
    }

    return errors.filter(function (e) {
      return (!e.mapping || mapping && e.mapping === mapping) && (!level || !e.level || e.level === level);
    });
  }
  /**
   * Add one or more {@link ErrorInfo} object(s) into error store.
   * @param errors one or more {@link ErrorInfo} object(s)
   */
  ;

  var _proto = ErrorHandlerService.prototype;

  _proto.addError = function addError() {
    var _this = this;

    for (var _len = arguments.length, errors = new Array(_len), _key = 0; _key < _len; _key++) {
      errors[_key] = arguments[_key];
    }

    errors.forEach(function (error) {
      if (error.object && error.object.message) {
        // TODO show error.object in more polished way... maybe with better error console
        error.message += '\n' + error.object.message;
      }

      var store = ErrorScope.FORM === error.scope ? _this.formErrors : _this.errors;

      if (store.find(function (e) {
        return e.message === error.message;
      })) {
        return;
      }

      store.unshift(error);
    });
    this.emitUpdatedEvent();
  }
  /**
   * An utility method to add backend error. It's a network error if {@link error.status} is 0.
   *
   * @param message error message to put if it's not a network error
   * @param error raw error object
   */
  ;

  _proto.addBackendError = function addBackendError(message, error) {
    if ((error === null || error === void 0 ? void 0 : error.status) === 0) {
      this.addError(new ErrorInfo({
        message: 'Fatal network error: Unable to connect to the AtlasMap design runtime service.',
        level: ErrorLevel.ERROR,
        scope: ErrorScope.APPLICATION,
        type: ErrorType.INTERNAL,
        object: error
      }));
    } else {
      this.addError(new ErrorInfo({
        message: message,
        level: ErrorLevel.ERROR,
        scope: ErrorScope.APPLICATION,
        type: ErrorType.INTERNAL,
        object: error
      }));
    }
  }
  /**
   * Return all errors in the store.
   * @return An array of {@link ErrorInfo}
   */
  ;

  _proto.getErrors = function getErrors() {
    return Object.assign([], this.errors);
  }
  /**
   * Remove one {@link ErrorInfo} by specifying ID.
   * @param identifier Error ID
   */
  ;

  _proto.removeError = function removeError(identifier, scope) {
    if (scope === ErrorScope.FORM && this.formErrorUpdatedSource && !this.formErrorUpdatedSource.closed) {
      this.formErrors = this.excludeByIdentifier(this.formErrors, identifier);
    } else {
      this.errors = this.excludeByIdentifier(this.errors, identifier);
    }

    this.emitUpdatedEvent();
  }
  /**
   * Clear all global/mapping errors as well as form validation erros and its Subject
   * if it exists.
   */
  ;

  _proto.resetAll = function resetAll() {
    this.clearAllErrors();
    this.formErrors = [];

    if (this.formErrorUpdatedSource && !this.formErrorUpdatedSource.closed) {
      this.formErrorUpdatedSource.complete();
    }
  }
  /**
   * Remova all errors except form validation errors.
   */
  ;

  _proto.clearAllErrors = function clearAllErrors() {
    this.errors = [];
    this.emitUpdatedEvent();
  }
  /**
   * Remove all preview errors.
   */
  ;

  _proto.clearPreviewErrors = function clearPreviewErrors() {
    this.errors = this.errors.filter(function (e) {
      return e.type !== ErrorType.PREVIEW;
    });
    this.emitUpdatedEvent();
  }
  /**
   * Remove all mapping validation errors.
   */
  ;

  _proto.clearValidationErrors = function clearValidationErrors(mapping) {
    this.errors = this.errors.filter(function (e) {
      return e.type !== ErrorType.VALIDATION && (!mapping || !e.mapping || e.mapping !== mapping);
    });
    this.emitUpdatedEvent();
  }
  /**
   * Remove all field scoped errors.
   */
  ;

  _proto.clearFieldErrors = function clearFieldErrors() {
    this.errors = this.errors.filter(function (e) {
      return e.scope !== ErrorScope.FIELD;
    });
    this.emitUpdatedEvent();
  }
  /**
   * Remove all form validation errors.
   */
  ;

  _proto.clearFormErrors = function clearFormErrors() {
    this.formErrors = [];
    this.emitUpdatedEvent(ErrorScope.FORM);
  }
  /**
   * Subscribe an error updated event. Observer will be notified
   * when an error is added or removed.
   * @param observer Observer
   */
  ;

  _proto.subscribe = function subscribe(observer) {
    return this.errorUpdatedSource.subscribe(observer);
  }
  /**
   * Create a Subject for form validation error. This ErrorHandlerService assumes only
   * one form validation happens at once, as it's used in modal window. Revisit this if there
   * needs to be more than one channel and manage a list of {@link Subject}.
   */
  ;

  _proto.createFormErrorChannel = function createFormErrorChannel() {
    var _this2 = this;

    if (this.formErrorUpdatedSource && !this.formErrorUpdatedSource.closed) {
      this.formErrorUpdatedSource.complete();
    }

    this.formErrors = [];
    this.formErrorUpdatedSource = new Subject();
    this.formErrorUpdatedSource.subscribe({
      complete: function complete() {
        return _this2.formErrors = [];
      }
    });
    return this.formErrorUpdatedSource;
  }
  /**
   * Validate the specified field value in a form, generating a form validation error if not defined.
   * @param value - A form field to validate
   * @param fieldDescription - used in error diagnostic
   */
  ;

  _proto.isRequiredFieldValid = function isRequiredFieldValid(value, fieldDescription) {
    if (value == null || '' === value) {
      var errorMessage = fieldDescription + ' is required.';
      this.addError(new ErrorInfo({
        message: errorMessage,
        level: ErrorLevel.ERROR,
        scope: ErrorScope.FORM
      }));
      this.emitUpdatedEvent(ErrorScope.FORM);
      return false;
    }

    return true;
  };

  _proto.emitUpdatedEvent = function emitUpdatedEvent(scope) {
    if (ErrorScope.FORM === scope) {
      if (this.formErrorUpdatedSource && !this.formErrorUpdatedSource.closed) {
        this.formErrorUpdatedSource.next(this.formErrors);
      }
    } else {
      this.errorUpdatedSource.next(this.errors);
    }
  };

  _proto.excludeByIdentifier = function excludeByIdentifier(errors, identifier) {
    return errors.filter(function (e) {
      return e.identifier !== identifier;
    });
  };

  return ErrorHandlerService;
}();

var FieldActionService = /*#__PURE__*/function () {
  function FieldActionService(api) {
    var _this$actions;

    this.api = api;
    this.cfg = ConfigModel.getConfig();
    this.actions = (_this$actions = {}, _this$actions[Multiplicity.ONE_TO_ONE] = [], _this$actions[Multiplicity.ONE_TO_MANY] = [], _this$actions[Multiplicity.MANY_TO_ONE] = [], _this$actions[Multiplicity.ZERO_TO_ONE] = [], _this$actions[Multiplicity.MANY_TO_MANY] = [], _this$actions);
    this.isInitialized = false;
    this.headers = {
      'Content-Type': 'application/json; application/octet-stream',
      Accept: 'application/json; application/octet-stream'
    };
  }

  var _proto = FieldActionService.prototype;

  _proto.fetchFieldActions = function fetchFieldActions() {
    try {
      var _this2 = this;

      return Promise.resolve(new Promise(function (resolve) {
        if (_this2.cfg.preloadedFieldActionMetadata) {
          _this2.clearActionDefinitions();

          if (_this2.cfg.preloadedFieldActionMetadata.ActionDetails) {
            for (var _iterator = _createForOfIteratorHelperLoose(_this2.cfg.preloadedFieldActionMetadata.ActionDetails.actionDetail), _step; !(_step = _iterator()).done;) {
              var actionDetail = _step.value;

              var fieldActionDefinition = _this2.extractFieldActionDefinition(actionDetail);

              if (!fieldActionDefinition.multiplicity) {
                _this2.cfg.logger.info("Field action (" + fieldActionDefinition.name + ") is missing multiplicity, ingoring");

                continue;
              }

              if (fieldActionDefinition.name === 'Expression') {
                // Expression is handled in special manner
                continue;
              }

              _this2.actions[fieldActionDefinition.multiplicity].push(fieldActionDefinition);
            }
          }

          _this2.sortFieldActionDefinitions();

          _this2.isInitialized = true;
          resolve(true);
          return;
        }

        if (_this2.cfg.mappingService == null || _this2.cfg.initCfg.baseMappingServiceUrl == null) {
          _this2.cfg.errorService.addError(new ErrorInfo({
            message: 'Mapping service URL is not provided. Field Actions will not be used.',
            level: ErrorLevel.WARN,
            scope: ErrorScope.APPLICATION,
            type: ErrorType.INTERNAL
          }));

          _this2.isInitialized = true;
          resolve(false);
          return;
        } // Fetch the field actions from the runtime service.


        _this2.doFetchFieldActions().then(function (fetchedActionConfigs) {
          if (fetchedActionConfigs.length === 1) {
            _this2.cfg.logger.info('No field action was returned from backend');

            resolve(false);
          }

          _this2.clearActionDefinitions();

          fetchedActionConfigs.forEach(function (action) {
            if (!action.multiplicity) {
              _this2.cfg.logger.info("Field action  (" + action.name + ") is missing multiplicity, ignoring");

              return;
            }

            if (action.name === 'Expression') {
              // Expression is handled in special manner
              return;
            }

            _this2.actions[action.multiplicity].push(action);
          });

          _this2.sortFieldActionDefinitions();

          _this2.isInitialized = true;
          resolve(true);
        })["catch"](function (error) {
          _this2.cfg.errorService.addBackendError("Could not load field action configs: (" + error.message + ")", error);

          resolve(false);
        });
      }));
    } catch (e) {
      return Promise.reject(e);
    }
  };

  _proto.getActionDefinitionForName = function getActionDefinitionForName(actionName, multiplicity) {
    if (!this.actions || !actionName) {
      return null;
    }

    var actions = [];

    if (multiplicity) {
      actions = this.actions[multiplicity];
    } else {
      Object.values(this.actions).forEach(function (arr) {
        return actions = actions.concat(arr);
      });
    }

    for (var _iterator2 = _createForOfIteratorHelperLoose(actions), _step2; !(_step2 = _iterator2()).done;) {
      var actionDef = _step2.value;

      if (actionName === actionDef.name) {
        return actionDef;
      }
    }

    return null;
  }
  /**
   * Return the field action Definitions applicable to the specified field mapping pair.
   * @param mapping
   * @param isSource
   * @param multiplicity
   */
  ;

  _proto.getActionsAppliesToField = function getActionsAppliesToField(mapping, isSource, multiplicity) {
    var _this3 = this;

    if (isSource === void 0) {
      isSource = true;
    }

    if (multiplicity === void 0) {
      multiplicity = Multiplicity.ONE_TO_ONE;
    }

    if (!mapping || !this.actions) {
      return [];
    }

    return this.actions[multiplicity].filter(function (d) {
      return _this3.appliesToField(d, mapping, isSource);
    });
  };

  _proto.doFetchFieldActions = function doFetchFieldActions() {
    var _this4 = this;

    return new Promise(function (resolve, reject) {
      var actionConfigs = [];
      var url = _this4.cfg.initCfg.baseMappingServiceUrl + 'fieldActions';

      _this4.cfg.logger.debug('Field Action Config Request');

      _this4.api.get(url, {
        headers: _this4.headers
      }).json().then(function (body) {
        var _body$ActionDetails, _body$ActionDetails$a;

        _this4.cfg.logger.debug("Field Action Config Response: " + JSON.stringify(body));

        if (body !== null && body !== void 0 && (_body$ActionDetails = body.ActionDetails) !== null && _body$ActionDetails !== void 0 && (_body$ActionDetails$a = _body$ActionDetails.actionDetail) !== null && _body$ActionDetails$a !== void 0 && _body$ActionDetails$a.length) {
          for (var _iterator3 = _createForOfIteratorHelperLoose(body.ActionDetails.actionDetail), _step3; !(_step3 = _iterator3()).done;) {
            var actionDetail = _step3.value;

            var fieldActionConfig = _this4.extractFieldActionDefinition(actionDetail);

            actionConfigs.push(fieldActionConfig);
          }
        }

        resolve(actionConfigs);
      })["catch"](function (error) {
        reject(error);
      });
    });
  };

  _proto.extractFieldActionDefinition = function extractFieldActionDefinition(actionDetail) {
    this.cfg.logger.trace("Deserializing field action definition: " + JSON.stringify(actionDetail));
    var fieldActionDefinition = new FieldActionDefinition();
    fieldActionDefinition.name = actionDetail.name;
    fieldActionDefinition.isCustom = actionDetail.custom;
    fieldActionDefinition.sourceType = actionDetail.sourceType;
    fieldActionDefinition.targetType = actionDetail.targetType;
    fieldActionDefinition.method = actionDetail.method;
    fieldActionDefinition.multiplicity = actionDetail.multiplicity;
    fieldActionDefinition.serviceObject = actionDetail;

    if (actionDetail.actionSchema) {
      for (var _i = 0, _Object$keys = Object.keys(actionDetail.actionSchema.properties); _i < _Object$keys.length; _i++) {
        var key = _Object$keys[_i];
        var propertyObject = actionDetail.actionSchema.properties[key];

        if (key === '@type') {
          fieldActionDefinition.name = propertyObject["const"];
          continue;
        }

        var argTypeString = propertyObject.type.toUpperCase();
        var argType = argTypeString ? FieldType[argTypeString] : FieldType.STRING;
        var argumentDefinition = new FieldActionArgument();
        argumentDefinition.name = key;
        argumentDefinition.type = argType;

        if (propertyObject["enum"]) {
          argumentDefinition.values = propertyObject["enum"];
        }

        argumentDefinition.serviceObject = propertyObject;
        fieldActionDefinition.arguments.push(argumentDefinition);
      }
    }

    return fieldActionDefinition;
  };

  _proto.sortFieldActionDefinitions = function sortFieldActionDefinitions() {
    var _this5 = this;

    Object.keys(this.actions).forEach(function (multiplicity) {
      var definitions = _this5.actions[multiplicity];
      var sortedActionDefinitions = [];

      if (definitions == null || definitions.length === 0) {
        return;
      }

      var defsByName = {};
      var defNames = [];

      for (var _iterator4 = _createForOfIteratorHelperLoose(definitions), _step4; !(_step4 = _iterator4()).done;) {
        var fieldActionConfig = _step4.value;
        var _name = fieldActionConfig.name;
        var _sameNamedDefs = defsByName[_name];

        if (!_sameNamedDefs) {
          _sameNamedDefs = [];
          defNames.push(_name);
        }

        _sameNamedDefs.push(fieldActionConfig);

        defsByName[_name] = _sameNamedDefs;
      }

      defNames.sort();

      for (var _i2 = 0, _defNames = defNames; _i2 < _defNames.length; _i2++) {
        var name = _defNames[_i2];
        var sameNamedDefs = defsByName[name];

        for (var _iterator5 = _createForOfIteratorHelperLoose(sameNamedDefs), _step5; !(_step5 = _iterator5()).done;) {
          var fieldActionDefinition = _step5.value;
          sortedActionDefinitions.push(fieldActionDefinition);
        }
      }

      _this5.actions[multiplicity] = sortedActionDefinitions;
    });
  }
  /**
   * Return true if the action's source/target types and collection types match the respective source/target
   * field properties for source transformations, or matches the respective target field properties only for
   * a target transformation.
   *
   * @param action
   * @param mapping
   * @param isSource
   */
  ;

  _proto.appliesToField = function appliesToField(action, mapping, isSource) {
    if (mapping == null) {
      return false;
    }

    var selectedSourceField = this.getActualField(mapping, true);
    var selectedTargetField = this.getActualField(mapping, false);

    if (isSource && selectedSourceField == null || !isSource && selectedTargetField == null) {
      return false;
    }

    return isSource ? this.appliesToSourceField(action, mapping, selectedSourceField) : this.appliesToTargetField(action, mapping, selectedTargetField);
  }
  /**
   * Return the first non-padding field in either the source or target mappings.
   *
   * @param mapping
   * @param isSource
   */
  ;

  _proto.getActualField = function getActualField(mapping, isSource) {
    var targetField = mapping.getFields(isSource).find(function (f) {
      return f.name !== '<padding field>';
    }); // TODO: maybe throw an exception instead of assuming the field will be found?

    return targetField;
  }
  /**
   * Check if it could be applied to source field.
   * @param action
   * @param _
   * @param selectedSourceField selected source field
   */
  ;

  _proto.appliesToSourceField = function appliesToSourceField(action, _, selectedSourceField) {
    // Check for matching types - date.
    if (this.matchesDate(action.sourceType, selectedSourceField.type)) {
      return true;
    } // Check for matching types - numeric.


    if (this.matchesNumeric(action.sourceType, selectedSourceField.type)) {
      return true;
    } // First check if the source types match.


    if (action.sourceType === 'ANY' || selectedSourceField.type === action.sourceType) {
      return true;
    }

    return false;
  }
  /**
   * Check if it could be applied for target field. Target type may not change.
   * @param action
   * @param _
   * @param selectedTargetField selected target field
   */
  ;

  _proto.appliesToTargetField = function appliesToTargetField(action, _, selectedTargetField) {
    if (selectedTargetField == null) {
      return false;
    }

    if (action.multiplicity !== Multiplicity.ONE_TO_ONE) {
      return false;
    } // Check for matching types - date.


    if (this.matchesDate(action.sourceType, selectedTargetField.type) && this.matchesDate(action.targetType, selectedTargetField.type)) {
      return true;
    } // Check for matching types - numeric.


    if (this.matchesNumeric(action.sourceType, selectedTargetField.type) && this.matchesNumeric(action.targetType, selectedTargetField.type)) {
      return true;
    }

    if (action.sourceType !== 'ANY' && action.sourceType !== selectedTargetField.type) {
      return false;
    } // All other types must match the selected field types with the candidate field action types.


    return action.targetType === 'ANY' || selectedTargetField.type === action.targetType;
  }
  /**
   * Return true if the candidate type and selected type are generically a date, false otherwise.
   *
   * @param candidateType
   * @param selectedType
   */
  ;

  _proto.matchesDate = function matchesDate(candidateType, selectedType) {
    return candidateType === 'ANY' || candidateType === 'ANY_DATE' && ['DATE', 'DATE_TIME', 'DATE_TIME_TZ', 'TIME'].indexOf(selectedType) !== -1;
  }
  /**
   * Return true if the candidate type and selected type are generically numeric, false otherwise.
   *
   * @param candidateType
   * @param selectedType
   */
  ;

  _proto.matchesNumeric = function matchesNumeric(candidateType, selectedType) {
    return candidateType === 'ANY' || candidateType === 'NUMBER' && ['LONG', 'INTEGER', 'FLOAT', 'DOUBLE', 'SHORT', 'BYTE', 'DECIMAL', 'NUMBER'].indexOf(selectedType) !== -1;
  };

  _proto.clearActionDefinitions = function clearActionDefinitions() {
    var _this6 = this;

    Object.keys(Multiplicity).forEach(function (m) {
      return _this6.actions[m] = [];
    });
  };

  return FieldActionService;
}();

var FileName;

(function (FileName) {
  FileName["DIGEST"] = "Mapping digest file";
  FileName["ADM"] = "ADM archive file";
  FileName["JAR"] = "Jar file";
})(FileName || (FileName = {}));

var FileType;

(function (FileType) {
  FileType["DIGEST"] = "GZ";
  FileType["ADM"] = "ZIP";
  FileType["JAR"] = "JAR";
})(FileType || (FileType = {}));
/**
 * Handles file manipulation stored in the backend, including import/export via UI.
 */


var FileManagementService = /*#__PURE__*/function () {
  function FileManagementService(api) {
    this.api = api;
  }

  var _proto = FileManagementService.prototype;

  _proto.findMappingFiles = function findMappingFiles(filter) {
    var _this = this;

    return new Promise(function (resolve, reject) {
      var url = _this.cfg.initCfg.baseMappingServiceUrl + 'mappings' + (filter == null ? '' : '?filter=' + filter);

      _this.cfg.logger.debug('Mapping List Request');

      _this.api.get(url).json().then(function (body) {
        _this.cfg.logger.debug("Mapping List Response: " + JSON.stringify(body));

        var entries = body.StringMap.stringMapEntry;
        resolve(entries.map(function (item) {
          return item.name;
        }));
      })["catch"](function (error) {
        if (error.status !== HTTP_STATUS_NO_CONTENT) {
          _this.cfg.errorService.addBackendError('Error occurred while accessing the current mapping files from the runtime service.', error);

          reject(error);
        }
      });
    });
  }
  /**
   * Retrieve the current user data mappings digest file from the server as a GZIP compressed byte array buffer.
   */
  ;

  _proto.getCurrentMappingDigest = function getCurrentMappingDigest() {
    var _this2 = this;

    return new Promise(function (resolve, reject) {
      _this2.getCurrentFile(FileName.DIGEST, FileType.DIGEST).then(function (gzipped) {
        if (!gzipped) {
          resolve(null);
          return;
        }

        var gunzipped = inflate(gzipped);
        var stringified = new Uint8Array(gunzipped).reduce(function (data, _byte) {
          return data + String.fromCharCode(_byte);
        }, '');
        var admDigest = CommonUtil.objectize(stringified);
        resolve(admDigest);
      })["catch"](function (error) {
        reject(error);
      });
    });
  };

  _proto.getCurrentADMArchive = function getCurrentADMArchive() {
    return this.getCurrentFile(FileName.ADM, FileType.ADM);
  };

  _proto.getCurrentFile = function getCurrentFile(fileName, fileType) {
    var _this3 = this;

    return new Promise(function (resolve, reject) {
      var url = _this3.cfg.initCfg.baseMappingServiceUrl + "mapping/" + fileType + "/";

      _this3.cfg.logger.debug("Get Current " + fileName + " Request: " + url);

      var headers = {
        'Content-Type': 'application/octet-stream',
        Accept: 'application/octet-stream',
        'Response-Type': 'application/octet-stream'
      };

      _this3.api.get(url, {
        headers: headers
      }).arrayBuffer().then(function (body) {
        _this3.cfg.logger.debug("Get Current " + fileName + " Response: " + JSON.stringify(body));

        if (body.byteLength) {
          resolve(new Uint8Array(body));
        } else {
          resolve(null);
        }
      })["catch"](function (error) {
        if (error.status !== HTTP_STATUS_NO_CONTENT) {
          _this3.cfg.errorService.addBackendError("Error occurred while accessing the " + fileName + " from the runtime service.", error);

          reject(error);
        }
      });
    });
  }
  /**
   * Delete mapping files on the runtime.
   */
  ;

  _proto.resetMappings = function resetMappings() {
    var _this4 = this;

    return new Promise(function (resolve) {
      var url = _this4.cfg.initCfg.baseMappingServiceUrl + 'mapping/RESET';

      _this4.cfg.logger.debug('Reset Mappings Request');

      _this4.api["delete"](url).arrayBuffer().then(function (res) {
        _this4.cfg.logger.debug("Reset Mappings Response: " + JSON.stringify(res));

        resolve(true);
        return res;
      })["catch"](function (error) {
        _this4.cfg.errorService.addBackendError('Error occurred while resetting mappings.', error);

        resolve(false);
      });
    });
  }
  /**
   * Delete user-defined JAR library files on the runtime.
   */
  ;

  _proto.resetLibs = function resetLibs() {
    var _this5 = this;

    return new Promise(function (resolve) {
      var url = _this5.cfg.initCfg.baseMappingServiceUrl + 'mapping/resetLibs';

      _this5.cfg.logger.debug('Reset Libs Request');

      _this5.api["delete"](url).arrayBuffer().then(function (res) {
        _this5.cfg.logger.debug("Reset Libs Response: " + JSON.stringify(res));

        resolve(true);
        return res;
      })["catch"](function (error) {
        _this5.cfg.errorService.addBackendError('Error occurred while resetting user-defined JAR libraries.', error);

        resolve(false);
      });
    });
  }
  /**
   * Clear error service and delete jar libraries, documents and mappings.
   */
  ;

  _proto.resetAll = function resetAll() {
    var _this6 = this;

    return new Promise(function (resolve) {
      _this6.cfg.errorService.resetAll();

      _this6.cfg.fileService.resetMappings().then(function () {
        try {
          _this6.cfg.mappings = null;

          _this6.cfg.clearDocs();

          _this6.cfg.fileService.resetLibs().then(function (value) {
            resolve(value);
          })["catch"](function (error) {
            _this6.cfg.errorService.addBackendError("Failed to remove jar files: " + error.message, error);

            resolve(false);
          });

          return Promise.resolve();
        } catch (e) {
          return Promise.reject(e);
        }
      })["catch"](function (error) {
        _this6.cfg.errorService.addBackendError("Failed to remove mappings: " + error.message, error);

        resolve(false);
      });
    });
  }
  /**
   * Commit the specified AtlasMapping object to the runtime service.  The mappings
   * are kept separate so they can be updated with minimal overhead.
   *
   * @param buffer - The stringified AtlasMapping JSON
   */
  ;

  _proto.setMappingToService = function setMappingToService(atlasMappingContainer) {
    var jsonBuffer = JSON.stringify(atlasMappingContainer);
    return this.setMappingStringToService(jsonBuffer);
  }
  /**
   * Commit the specified AtlasMapping JSON user mapping string to the runtime service.  The mappings
   * are kept separate so they can be updated with minimal overhead.
   *
   * @param buffer - The stringified AtlasMapping JSON
   */
  ;

  _proto.setMappingStringToService = function setMappingStringToService(jsonBuffer) {
    var _this7 = this;

    return new Promise(function (resolve) {
      var url = _this7.cfg.initCfg.baseMappingServiceUrl + 'mapping/JSON';
      var headers = {
        'Content-Type': 'application/json',
        Accept: 'application/json',
        'Response-Type': 'application/json'
      };

      _this7.cfg.logger.debug("Set Mapping Request (set mapping): " + jsonBuffer);

      _this7.api.put(url, {
        headers: headers,
        body: jsonBuffer
      }).arrayBuffer().then(function (res) {
        _this7.cfg.logger.debug("Set Mapping Response: " + JSON.stringify(res));

        resolve(true);
      })["catch"](function (error) {
        _this7.cfg.errorService.addBackendError("Unable to update the mappings file to the AtlasMap design runtime service. " + error.status + " " + error.statusText, error);

        resolve(false);
      });
    });
  };

  _proto.setMappingDigestToService = function setMappingDigestToService(mappingDigest) {
    var _this8 = this;

    return new Promise(function (resolve) {
      // Compress the JSON buffer - write out as binary.
      var strBuffer = JSON.stringify(mappingDigest);
      var binBuffer = CommonUtil.str2bytes(strBuffer);
      var compressedBuffer;

      try {
        compressedBuffer = gzip(binBuffer);
      } catch (error1) {
        _this8.cfg.errorService.addError(new ErrorInfo({
          message: 'Unable to compress the current data mappings.',
          level: ErrorLevel.ERROR,
          scope: ErrorScope.APPLICATION,
          type: ErrorType.INTERNAL,
          object: error1
        }));

        resolve(false);
        return;
      } // Update .../target/mappings/adm-catalog-files.gz


      var url = _this8.cfg.initCfg.baseMappingServiceUrl + 'mapping/GZ/0';
      var fileContent = new Blob([compressedBuffer], {
        type: 'application/octet-stream'
      });

      _this8.setBinaryFileToService(fileContent, url, FileName.DIGEST).then(function (value) {
        resolve(value);
      });
    });
  };

  _proto.setADMArchiveFileToService = function setADMArchiveFileToService(compressedBuffer) {
    var url = this.cfg.initCfg.baseMappingServiceUrl + 'mapping/ZIP/';
    var fileContent = new Blob([compressedBuffer], {
      type: 'application/octet-stream'
    });
    return this.setBinaryFileToService(fileContent, url, FileName.ADM);
  }
  /**
   * The user has either exported their mappings or imported new mappings.
   * Either way we're saving them on the server.
   *
   * @param compressedBuffer
   */
  ;

  _proto.setBinaryFileToService = function setBinaryFileToService(compressedBuffer, url, fileName) {
    var _this9 = this;

    return new Promise(function (resolve) {
      _this9.cfg.logger.debug("Set " + fileName + " Request");

      _this9.api.put(url, {
        body: compressedBuffer
      }).arrayBuffer().then(function (res) {
        _this9.cfg.logger.debug("Set " + fileName + " Response: " + JSON.stringify(res));

        resolve(true);
      })["catch"](function (error) {
        _this9.cfg.errorService.addBackendError("Unable to update the " + fileName + " to the AtlasMap design runtime service.\n              " + error.status + " " + error.statusText, error);

        resolve(false);
      });
    });
  }
  /**
   * Push a user-defined Java archive file (JAR binary buffer) to the runtime.
   *
   * @param binaryBuffer - binary JAR file
   */
  ;

  _proto.importJarFile = function importJarFile(binaryBuffer) {
    var _this10 = this;

    return new Promise(function (resolve) {
      try {
        var url = _this10.cfg.initCfg.baseMappingServiceUrl + 'library';
        var fileContent = new Blob([binaryBuffer], {
          type: 'application/octet-stream'
        });
        return Promise.resolve(_this10.setBinaryFileToService(fileContent, url, FileName.JAR)).then(function (jarUpdated) {
          var _temp = function () {
            if (jarUpdated && _this10.cfg.mappingService) {
              _this10.cfg.mappingService.notifyMappingUpdated();

              return Promise.resolve(_this10.cfg.fieldActionService.fetchFieldActions()).then(function () {
                resolve(true);
              });
            } else {
              resolve(false);
            }
          }();

          if (_temp && _temp.then) return _temp.then(function () {});
        });
      } catch (e) {
        return Promise.reject(e);
      }
    });
  }
  /**
   * Generate mapping digest file from current state and push it to the runtime.
   *
   * @returns {@link Promise}
   */
  ;

  _proto.updateDigestFile = function updateDigestFile() {
    var _this11 = this;

    return new Promise(function (resolve) {
      try {
        var _temp5 = _catch(function () {
          function _temp3() {
            var mappingDigest = MappingDigestUtil.generateMappingDigest(_this11.cfg, mappingJson); // Save mapping digest file to the runtime.

            _this11.setMappingDigestToService(mappingDigest).then(function (value) {
              resolve(value);
            });
          }

          var mappingJson = undefined; // Retrieve the JSON mappings buffer from the server.

          var _temp2 = function () {
            if (_this11.cfg.mappings) {
              return Promise.resolve(_this11.getCurrentMappingJson()).then(function (_this11$getCurrentMap) {
                mappingJson = _this11$getCurrentMap;
              });
            }
          }();

          return _temp2 && _temp2.then ? _temp2.then(_temp3) : _temp3(_temp2);
        }, function (error) {
          _this11.cfg.errorService.addError(new ErrorInfo({
            message: 'Unable to update mapping digest file.',
            level: ErrorLevel.ERROR,
            scope: ErrorScope.APPLICATION,
            type: ErrorType.INTERNAL,
            object: error
          }));

          resolve(false);
        });

        return Promise.resolve(_temp5 && _temp5.then ? _temp5.then(function () {}) : void 0);
      } catch (e) {
        return Promise.reject(e);
      }
    });
  }
  /**
   * Update the current mapping files and export the ADM archive file with current mappings.
   *
   * Establish the mapping digest file content in JSON format (mappings + schema + instance-schema),
   * compress it (GZIP), update the runtime, then fetch the full ADM archive ZIP file from the runtime
   * and export it.
   *
   * @param event
   */
  ;

  _proto.exportADMArchive = function exportADMArchive(mappingsFileName) {
    var _this12 = this;

    return new Promise(function (resolve) {
      _this12.updateDigestFile().then(function () {
        // Fetch the full ADM archive file from the runtime (ZIP) and export it to to the local
        // downloads area.
        _this12.getCurrentADMArchive().then(function (value) {
          try {
            // If value is null then no compressed mappings digest file is available on the server.
            if (value === null) {
              resolve(false);
              return Promise.resolve();
            } // Tack on a .adm suffix if one wasn't already specified.


            if (mappingsFileName.split('.').pop() !== 'adm') {
              mappingsFileName = mappingsFileName.concat('.adm');
            }

            var fileContent = new Blob([value], {
              type: 'application/octet-stream'
            });
            CommonUtil.writeFile(fileContent, mappingsFileName).then(function (value2) {
              resolve(value2);
            })["catch"](function (error) {
              _this12.cfg.errorService.addError(new ErrorInfo({
                message: 'Unable to save the current data mappings.',
                level: ErrorLevel.ERROR,
                scope: ErrorScope.APPLICATION,
                type: ErrorType.INTERNAL,
                object: error
              }));

              resolve(false);
            });
            return Promise.resolve();
          } catch (e) {
            return Promise.reject(e);
          }
        });
      });
    });
  }
  /**
   * Clean up all existing mappings, documents, libraries and import specified ADM archive file,
   * push it to the runtime and reflect back in UI. The ADM file is in (ZIP) file format.
   * Once pushed, we can retrieve from runtime the extracted compressed (GZIP) mappings
   * digest file as well as the mappings JSON file.  These files exist separately for performance reasons.
   *
   * Once the runtime has its ADM archive file, digest file and mappings file set then restart the DM.
   *
   * @param mappingsFileName - ADM archive file
   */
  ;

  _proto.importADMArchive = function importADMArchive(admFile) {
    var _this13 = this;

    return new Promise(function (resolve) {
      _this13.resetAll().then(function () {
        var reader = new FileReader(); // Turn the imported ADM file into a binary octet stream.

        CommonUtil.readBinaryFile(admFile, reader).then(function (fileBin) {
          // Push the binary stream to the runtime.
          _this13.setADMArchiveFileToService(fileBin).then(function (value) {
            resolve(value);
          });
        })["catch"](function (error) {
          _this13.cfg.errorService.addError(new ErrorInfo({
            message: "Unable to import the specified ADM file '" + admFile.name + "'",
            level: ErrorLevel.ERROR,
            scope: ErrorScope.APPLICATION,
            type: ErrorType.INTERNAL,
            object: error
          }));

          resolve(false);
        });
      });
    });
  }
  /**
   * Retrieve the current user AtlasMap data mappings from the server as a JSON object.
   */
  ;

  _proto.getCurrentMappingJson = function getCurrentMappingJson() {
    var _this14 = this;

    return new Promise(function (resolve, reject) {
      if (_this14.cfg.mappings === null) {
        reject();
        return;
      }

      _this14.cfg.mappingFiles[0] = _this14.cfg.mappings.name;
      var baseURL = _this14.cfg.initCfg.baseMappingServiceUrl + 'mapping/JSON/';

      _this14.cfg.logger.debug('Get Current Mapping Request');

      _this14.api.get(baseURL).json().then(function (body) {
        _this14.cfg.logger.debug("Get Current Mapping Response: " + JSON.stringify(body));

        resolve(body);
      })["catch"](function (error) {
        if (error.status !== HTTP_STATUS_NO_CONTENT) {
          _this14.cfg.errorService.addBackendError('Error occurred while accessing the current mappings from the backend service.', error);

          reject(error);
        } else {
          resolve(undefined);
        }
      });
    });
  };

  _createClass(FileManagementService, [{
    key: "cfg",
    get: function get() {
      return this._cfg;
    },
    set: function set(cfg) {
      this._cfg = cfg;

      if (!this._cfg.logger) {
        this._cfg.logger = log.getLogger('file-management');
      }
    }
  }]);

  return FileManagementService;
}();

/**
 * Manages conditional mapping expression.
 */

var MappingExpressionService = /*#__PURE__*/function () {
  function MappingExpressionService() {}

  var _proto = MappingExpressionService.prototype;

  _proto.willClearOutSourceFieldsOnTogglingExpression = function willClearOutSourceFieldsOnTogglingExpression() {
    var _this$cfg$mappings, _this$cfg$mappings$ac;

    if ((_this$cfg$mappings = this.cfg.mappings) !== null && _this$cfg$mappings !== void 0 && (_this$cfg$mappings$ac = _this$cfg$mappings.activeMapping) !== null && _this$cfg$mappings$ac !== void 0 && _this$cfg$mappings$ac.transition.enableExpression) {
      return this.cfg.mappings.activeMapping.getFirstCollectionField(true) != null;
    } else {
      return false;
    }
  };

  _proto.isExpressionEnabledForActiveMapping = function isExpressionEnabledForActiveMapping() {
    var _this$cfg$mappings2, _this$cfg$mappings2$a, _this$cfg$mappings2$a2;

    return !!((_this$cfg$mappings2 = this.cfg.mappings) !== null && _this$cfg$mappings2 !== void 0 && (_this$cfg$mappings2$a = _this$cfg$mappings2.activeMapping) !== null && _this$cfg$mappings2$a !== void 0 && (_this$cfg$mappings2$a2 = _this$cfg$mappings2$a.transition) !== null && _this$cfg$mappings2$a2 !== void 0 && _this$cfg$mappings2$a2.enableExpression);
  };

  _proto.toggleExpressionMode = function toggleExpressionMode() {
    var _this = this;

    if (!this.cfg.mappings || !this.cfg.mappings.activeMapping || !this.cfg.mappings.activeMapping.transition) {
      this.cfg.errorService.addError(new ErrorInfo({
        message: 'Please select a mapping first.',
        level: ErrorLevel.INFO,
        scope: ErrorScope.MAPPING,
        type: ErrorType.USER
      }));
      return;
    }

    var activeMapping = this.cfg.mappings.activeMapping;

    if (activeMapping.transition.mode === TransitionMode.ONE_TO_MANY) {
      this.cfg.errorService.addError(new ErrorInfo({
        message: "Cannot establish a conditional mapping expression when multiple target fields are selected.\n        Please select only one target field and try again.",
        level: ErrorLevel.WARN,
        scope: ErrorScope.MAPPING,
        type: ErrorType.USER,
        mapping: activeMapping
      }));
      return;
    }

    if (this.willClearOutSourceFieldsOnTogglingExpression()) {
      // Clear out source fields, if the mapping contains a source collection
      activeMapping.sourceFields.splice(0, activeMapping.sourceFields.length);
    }

    activeMapping.transition.enableExpression = !activeMapping.transition.enableExpression;

    if (activeMapping.transition.enableExpression) {
      activeMapping.transition.mode = TransitionMode.EXPRESSION;
      activeMapping.transition.transitionFieldAction = null;
      this.mappingUpdatedSubscription = this.cfg.mappingService.mappingUpdated$.subscribe(function () {
        if (!_this.cfg || !_this.cfg.mappings || !_this.cfg.mappings.activeMapping) {
          return;
        }

        if (_this.cfg.mappings.activeMapping.isFullyMapped()) {
          _this.updateExpression(_this.cfg.mappings.activeMapping);
        }
      });

      if (activeMapping.transition.expression) {
        this.cfg.mappings.activeMapping.transition.expression.expressionUpdatedSource.next();
      }
    } else {
      var _this$mappingUpdatedS;

      (_this$mappingUpdatedS = this.mappingUpdatedSubscription) === null || _this$mappingUpdatedS === void 0 ? void 0 : _this$mappingUpdatedS.unsubscribe();
      activeMapping.transition.mode = TransitionMode.ONE_TO_ONE;
      this.cfg.mappingService.updateActiveMappingTransition();
    }
  };

  _proto.updateExpression = function updateExpression(mapping, position, offset) {
    var _mapping$transition$e;

    // Update conditional expression field references.
    (_mapping$transition$e = mapping.transition.expression) === null || _mapping$transition$e === void 0 ? void 0 : _mapping$transition$e.updateFieldReference(mapping, position, offset);
  }
  /**
   * Add the specified document ID/field path to the specified mapping/ expression.
   *
   * @param mapping
   * @param docId
   * @param fieldPath
   * @param newTextNode
   * @param atIndex
   * @param isTrailer
   */
  ;

  _proto.addFieldToExpression = function addFieldToExpression(mapping, docId, fieldPath, newTextNode, atIndex, isTrailer) {
    var _mapping$transition$e2;

    var mappedField = mapping.getMappedFieldByPath(fieldPath, true, docId);

    if (!mappedField) {
      // If the selected field was not part of the original mapping
      // and is complex then add it as a reference node.
      mappedField = mapping.getReferenceField(docId, fieldPath);

      if (!mappedField) {
        // Try adding the selected field to the active mapping.
        var docDef = this.cfg.getDocForIdentifier(docId, true);
        var field = Field.getField(fieldPath, docDef === null || docDef === void 0 ? void 0 : docDef.getAllFields());

        if (field) {
          this.updateExpression(mapping, newTextNode.getUuid(), isTrailer ? newTextNode.toText().length : atIndex);
          this.cfg.mappingService.addFieldToActiveMapping(field);
        }

        mappedField = mapping.getMappedFieldByPath(fieldPath, true, docId);

        if (!mappedField) {
          return;
        }
      }
    }

    (_mapping$transition$e2 = mapping.transition.expression) === null || _mapping$transition$e2 === void 0 ? void 0 : _mapping$transition$e2.addConditionalExpressionNode(mappedField, newTextNode.getUuid(), isTrailer ? newTextNode.str.length : atIndex);
  }
  /**
   * Return an array of strings representing display names of mapping fields based on the
   * specified filter.
   * @todo ATM this is specialized for listing up candidate fields for adding into expression.
   * We will need to consolidate with field filter on the Document tree when we implement server
   * side field search - https://github.com/atlasmap/atlasmap/issues/603
   *
   * @param filter
   */
  ;

  _proto.executeFieldSearch = function executeFieldSearch(configModel, filter, isSource) {
    var activeMapping = configModel.mappings.activeMapping;

    if (!activeMapping) {
      return [];
    }

    var formattedFields = [];
    var fields = [];

    for (var _iterator = _createForOfIteratorHelperLoose(configModel.getDocs(isSource)), _step; !(_step = _iterator()).done;) {
      var docDef = _step.value;
      fields = docDef.getTerminalFields();
      fields = fields.concat(docDef.getComplexFields());
      Field.alphabetizeFields(fields);
      var documentName = '';
      var fieldCount = -1;

      for (var _iterator2 = _createForOfIteratorHelperLoose(fields), _step2; !(_step2 = _iterator2()).done;) {
        var field = _step2.value;
        var formattedField = [''];
        var displayName = field == null ? '' : field.getFieldLabel(configModel.showTypes, true);

        if (filter == null || filter === '' || displayName.toLowerCase().indexOf(filter.toLowerCase()) !== -1) {
          if (!configModel.mappingService.isFieldSelectable(activeMapping, field) && field.type !== FieldType.COMPLEX) {
            continue;
          }

          if (documentName !== field.docDef.name) {
            if (fieldCount === 0) {
              formattedFields.pop();
              continue;
            } else {
              var documentField = [''];
              documentName = field.docDef.name;
              documentField[0] = documentName;
              documentField[1] = field.docDef.id;
              fieldCount = 0;
              formattedFields.push(documentField);
            }
          }

          displayName = CommonUtil.extractDisplayPath(field.path, 100);
          formattedField[0] = field.docDef.id;
          formattedField[1] = field.path;
          fieldCount++;
          formattedFields.push(formattedField);
        }

        if (formattedFields.length > 19) {
          break;
        }
      }
    }

    return formattedFields;
  }
  /**
   * Return a string, in either text or HTML form, representing the
   * expression mapping of either the optionally specified mapping or
   * the active mapping if it exists, empty string otherwise.
   * @todo avoid any, use typed mapping object - https://github.com/atlasmap/atlasmap/issues/2975
   * @param asHTML
   * @param mapping
   */
  ;

  _proto.getMappingExpressionStr = function getMappingExpressionStr(asHTML, mapping) {
    if (!mapping && !MappingUtil.activeMapping(this.cfg)) {
      return '';
    }

    if (!mapping) {
      var _this$cfg$mappings3;

      mapping = (_this$cfg$mappings3 = this.cfg.mappings) === null || _this$cfg$mappings3 === void 0 ? void 0 : _this$cfg$mappings3.activeMapping;
    }

    if (!mapping.transition.expression) {
      if (mapping.transition.enableExpression && MappingUtil.hasFieldAction(mapping.sourceFields)) {
        this.createMappingExpression(mapping);
      } else {
        return '';
      }
    }

    if (mapping.transition.expression && mapping.transition.enableExpression) {
      return asHTML ? mapping.transition.expression.expressionHTML : mapping.transition.expression.toText(true);
    }

    return '';
  }
  /**
   * Create a conditional mapping expression from the specified mapping model.  Start
   * with a multiplicity action if applicable, then any field-specific field actions.
   *
   * @param mapping
   */
  ;

  _proto.createMappingExpression = function createMappingExpression(mapping) {
    var _mapping$transition$t, _mapping$transition$t2, _mapping$transition$t3, _mapping$transition$t4;

    var expr = '';
    var sourceMappedFields = mapping.getMappedFields(true);
    var sourceMappedCollection = MappingUtil.hasMappedCollection(mapping, true);
    var targetMappedFields = mapping.getMappedFields(false);
    var targetMappedCollection = MappingUtil.hasMappedCollection(mapping, false);

    if (sourceMappedFields.length > 1 || sourceMappedCollection && ((_mapping$transition$t = mapping.transition.transitionFieldAction) === null || _mapping$transition$t === void 0 ? void 0 : (_mapping$transition$t2 = _mapping$transition$t.definition) === null || _mapping$transition$t2 === void 0 ? void 0 : _mapping$transition$t2.multiplicity) === Multiplicity.MANY_TO_ONE) {
      expr = 'Concatenate (';
      expr += this.fieldActionsToExpression(mapping);
      expr += ", '" + TransitionModel.delimiterModels[mapping.transition.delimiter].actualDelimiter + "')";
    } else if ((targetMappedFields.length > 1 || targetMappedCollection) && ((_mapping$transition$t3 = mapping.transition.transitionFieldAction) === null || _mapping$transition$t3 === void 0 ? void 0 : (_mapping$transition$t4 = _mapping$transition$t3.definition) === null || _mapping$transition$t4 === void 0 ? void 0 : _mapping$transition$t4.multiplicity) === Multiplicity.ONE_TO_MANY) {
      expr = 'Split (';
      expr += this.fieldActionsToExpression(mapping);
      expr += ')';
    } else {
      expr += this.fieldActionsToExpression(mapping);
    }

    mapping.transition.expression = new ExpressionModel(mapping, this.cfg);
    mapping.transition.expression.insertText(expr);
    return expr;
  };

  _proto.qualifiedExpressionRef = function qualifiedExpressionRef(mappedField) {
    var _mappedField$field;

    if (((_mappedField$field = mappedField.field) === null || _mappedField$field === void 0 ? void 0 : _mappedField$field.path) !== null) {
      var _mappedField$field2, _mappedField$field2$d, _mappedField$field3;

      return '${' + ((_mappedField$field2 = mappedField.field) === null || _mappedField$field2 === void 0 ? void 0 : (_mappedField$field2$d = _mappedField$field2.docDef) === null || _mappedField$field2$d === void 0 ? void 0 : _mappedField$field2$d.id) + ':' + ((_mappedField$field3 = mappedField.field) === null || _mappedField$field3 === void 0 ? void 0 : _mappedField$field3.path) + '}';
    } else {
      return 'null';
    }
  }
  /**
   * Create a conditional expression fragment based on the specified field action
   * argument and type.
   *
   * @param actionArgument
   * @param actionArgType
   */
  ;

  _proto.fieldActionArgumentToExpression = function fieldActionArgumentToExpression(actionArgument, actionArgType) {
    if (actionArgType === 'string') {
      return "'" + actionArgument.value + "'";
    } else {
      return actionArgument.value;
    }
  }
  /**
   * Create a conditional expression fragment based on a single field action
   * and its arguments if any.
   *
   * @param mappedField
   * @param mfActionIndex
   */
  ;

  _proto.fieldActionToExpression = function fieldActionToExpression(mappedField, mfActionIndex) {
    var action = mappedField.actions[mfActionIndex];
    var expression = action.name + ' (';

    if (mfActionIndex < mappedField.actions.length - 1) {
      mfActionIndex++;
      expression += this.fieldActionToExpression(mappedField, mfActionIndex);
    } else {
      expression += this.qualifiedExpressionRef(mappedField);
    }

    if (action.argumentValues.length > 0) {
      for (var actionArgIndex = 0; actionArgIndex < action.argumentValues.length; actionArgIndex++) {
        expression += ', ' + this.fieldActionArgumentToExpression(action.argumentValues[actionArgIndex], action.definition.arguments[actionArgIndex].type);
      }
    }

    expression += ')';
    return expression;
  }
  /**
   * Create a conditional expression fragment based on the field actions of the specified
   * mapping model and the root field reference.
   *
   * @param mapping
   */
  ;

  _proto.fieldActionsToExpression = function fieldActionsToExpression(mapping) {
    var expression = '';
    var mappedField;

    for (var mappedFieldIndex = 0; mappedFieldIndex < mapping.sourceFields.length; mappedFieldIndex++) {
      mappedField = mapping.sourceFields[mappedFieldIndex];

      if (mappedField.actions.length > 0) {
        var mfActionIndex = 0;
        expression += this.fieldActionToExpression(mappedField, mfActionIndex);
      } else {
        expression += this.qualifiedExpressionRef(mappedField);
      }

      if (mappedFieldIndex !== mapping.sourceFields.length - 1) {
        expression += ', ';
      }
    }

    return expression;
  };

  return MappingExpressionService;
}();

/**
 * Handles mapping updates. It restores mapping status from backend and reflect in UI,
 * and/or reflect mapping changes caused by the user action made in UI to the backend.
 */

var MappingManagementService = /*#__PURE__*/function () {
  function MappingManagementService(api) {
    this.api = api;
    this.lineRefreshSource = new Subject();
    this.lineRefresh$ = this.lineRefreshSource.asObservable();
    this.mappingUpdatedSource = new Subject();
    this.mappingUpdated$ = this.mappingUpdatedSource.asObservable();
    this.mappingSelectionRequiredSource = new Subject();
    this.mappingSelectionRequired$ = this.mappingSelectionRequiredSource.asObservable();
  }

  var _proto = MappingManagementService.prototype;

  /**
   * Retrieve current mapping definition JSON file from backend, deserialize it and
   * load it into AtlasMap UI.
   *
   * @param mappingDefinition {@link MappingDefinition}
   * @returns
   */
  _proto.fetchMappings = function fetchMappings(_mappingFiles, mappingDefinition) {
    var _this = this;

    return new Promise(function (resolve) {
      _this.cfg.fileService.getCurrentMappingJson().then(function (mappingJson) {
        try {
          if (!mappingJson) {
            resolve(false);
            return Promise.resolve();
          }

          _this.cfg.mappings = mappingDefinition;
          MappingSerializer.deserializeMappingServiceJSON(mappingJson, _this.cfg);

          _this.updateMappingsTransition();

          resolve(true);
          return Promise.resolve();
        } catch (e) {
          return Promise.reject(e);
        }
      })["catch"](function (error) {
        _this.cfg.errorService.addBackendError('Failed to load mapping definition from backend:', error);

        resolve(false);
      });
    });
  };

  _proto.updateMappingsTransition = function updateMappingsTransition() {
    var _this2 = this;

    this.cfg.mappings.getAllMappings(true).forEach(function (m) {
      return _this2.updateTransition(m);
    }); // TODO: check this non null operator
  };

  _proto.updateActiveMappingTransition = function updateActiveMappingTransition() {
    var _this$cfg$mappings;

    if ((_this$cfg$mappings = this.cfg.mappings) !== null && _this$cfg$mappings !== void 0 && _this$cfg$mappings.activeMapping) {
      var _this$cfg$mappings2;

      this.updateTransition((_this$cfg$mappings2 = this.cfg.mappings) === null || _this$cfg$mappings2 === void 0 ? void 0 : _this$cfg$mappings2.activeMapping);
    }
  }
  /**
   * Remove the specified mapping model from the mappings array and update the runtime.
   *
   * @param mappingModel
   */
  ;

  _proto.removeMapping = function removeMapping(mappingModel) {
    try {
      var _this4 = this;

      return Promise.resolve(new Promise(function (resolve) {
        try {
          var _temp3 = function _temp3() {
            resolve(true);
          };

          var mappingWasRemoved = _this4.cfg.mappings.removeMapping(mappingModel); // TODO: check this non null operator


          var _temp4 = function () {
            if (mappingWasRemoved) {
              _this4.deselectMapping();

              return Promise.resolve(_this4.notifyMappingUpdated()).then(function () {});
            } else {
              _this4.deselectMapping();
            }
          }();

          return Promise.resolve(_temp4 && _temp4.then ? _temp4.then(_temp3) : _temp3(_temp4));
        } catch (e) {
          return Promise.reject(e);
        }
      }));
    } catch (e) {
      return Promise.reject(e);
    }
  }
  /**
   * Remove all mappings from the current session.
   */
  ;

  _proto.removeAllMappings = function removeAllMappings() {
    try {
      var _this6 = this;

      return Promise.resolve(new Promise(function (resolve) {
        try {
          // TODO: check these non null operator on the mappings
          for (var _iterator = _createForOfIteratorHelperLoose(_this6.cfg.mappings.getAllMappings(true)), _step; !(_step = _iterator()).done;) {
            var mapping = _step.value;

            _this6.cfg.mappings.removeMapping(mapping);

            _this6.deselectMapping();
          }

          return Promise.resolve(_this6.notifyMappingUpdated()).then(function () {
            resolve(true);
          });
        } catch (e) {
          return Promise.reject(e);
        }
      }));
    } catch (e) {
      return Promise.reject(e);
    }
  };

  _proto.updateMappedField = function updateMappedField(mapping) {
    try {
      var _this8 = this;

      return Promise.resolve(new Promise(function (resolve) {
        try {
          if (mapping.isEmpty()) {
            _this8.cfg.mappings.removeMapping(mapping); // TODO: check this non null operator


            _this8.deselectMapping();
          } else {
            _this8.updateTransition(mapping);
          }

          return Promise.resolve(_this8.notifyMappingUpdated()).then(function () {
            resolve(true);
          });
        } catch (e) {
          return Promise.reject(e);
        }
      }));
    } catch (e) {
      return Promise.reject(e);
    }
  }
  /**
   * Move the specified mapped field in the specified mapping to the specified index.
   *
   * @param mapping
   * @param insertedMappedField
   * @param targetIndex
   */
  ;

  _proto.moveMappedFieldTo = function moveMappedFieldTo(mapping, insertedMappedField, targetIndex) {
    if (!mapping || !insertedMappedField) {
      return;
    }

    var mappedFields = mapping.getMappedFields(insertedMappedField.isSource());
    mappedFields.splice(mapping.getIndexForMappedField(insertedMappedField) - 1, 1);
    mappedFields.splice(targetIndex - 1, 0, insertedMappedField);
    this.clearExtraPaddingFields(mappedFields, true);
    this.notifyMappingUpdated();
  }
  /**
   * Given an index range, fill in the mappings gap with place-holder fields.
   *
   * @param count - number of padding fields to add
   * @param mapping - mapping to modify
   * @param basePadIndex - 0 based
   * @param isSource
   */
  ;

  _proto.addPlaceholders = function addPlaceholders(count, mapping, basePadIndex, isSource) {
    var padField = null;

    for (var i = 0; i < count; i++) {
      padField = new MappedField();
      padField.field = new PaddingField(isSource);

      if (isSource) {
        mapping.sourceFields.splice(basePadIndex + i, 0, padField);
      } else {
        mapping.targetFields.splice(basePadIndex + i, 0, padField);
      }
    }
  };

  _proto.addFieldToActiveMapping = function addFieldToActiveMapping(field) {
    var mapping = this.cfg.mappings.activeMapping;

    if (!mapping) {
      this.cfg.errorService.addError(new ErrorInfo({
        message: "No mapping is selected to add a field '" + field.name + "'",
        level: ErrorLevel.ERROR,
        scope: ErrorScope.MAPPING,
        type: ErrorType.USER
      }));
      return;
    }

    var exclusionReason = this.getFieldSelectionExclusionReason(mapping, field);

    if (exclusionReason != null) {
      this.cfg.errorService.addError(new ErrorInfo({
        message: "The field '" + field.name + "' cannot be selected, " + exclusionReason + ".",
        level: ErrorLevel.ERROR,
        mapping: mapping,
        scope: ErrorScope.MAPPING,
        type: ErrorType.USER
      }));
      return;
    }

    mapping.addField(field, false);
    this.updateTransition(mapping);

    if (mapping.sourceFields.length > 0 || mapping.targetFields.length > 0) {
      this.notifyMappingUpdated();
    }

    return;
  };

  _proto.getFieldSelectionExclusionReason = function getFieldSelectionExclusionReason(mapping, field) {
    if (!field.isTerminal()) {
      return 'field is a parent field';
    }

    if (mapping.getAllMappedFields().length === 0) {
      // if mapping hasn't had a field selected yet, allow it
      return null;
    } // Non-collection target fields may only be mapped once.


    var existingMappedField = mapping.getMappedTarget(field);

    if (existingMappedField != null && !field.isInCollection) {
      return 'it is already the target of another mapping (' + existingMappedField + '). ';
    }

    var lookupMode = mapping.isLookupMode();

    if (lookupMode) {
      if (!field.enumeration) {
        return 'only Enumeration fields are valid for this mapping';
      }

      return null;
    } // enums are not selectable in these modes


    if (field.enumeration) {
      return 'Enumeration fields are not valid for this mapping';
    } // Expression mapping


    if (mapping.transition.enableExpression && !field.isSource() && mapping.getMappedFields(false).length > 0) {
      return 'cannot add multiple target fields when conditional mapping is enabled.';
    }

    return null;
  };

  _proto.isFieldSelectable = function isFieldSelectable(mapping, field) {
    return this.getFieldSelectionExclusionReason(mapping, field) == null;
  }
  /**
   * Instantiate a new mapping model and associate the selected field with it.
   * @param selectedField
   * @param compoundSelection - indicates a compound-selection (ctrl/cmd-M1) if true, standard mouse click if false.
   */
  ;

  _proto.addNewMapping = function addNewMapping(selectedField, compoundSelection) {
    if (!compoundSelection) {
      this.deselectMapping();
    }

    var mapping = new MappingModel();

    if (selectedField != null) {
      mapping.addField(selectedField, false);
      this.updateTransition(mapping);
      this.selectMapping(mapping);
      this.notifyMappingUpdated();
    } else {
      this.selectMapping(mapping);
    }
  }
  /**
   * Instantiate a new mapping model.
   */
  ;

  _proto.newMapping = function newMapping() {
    this.deselectMapping();
    var mapping = new MappingModel(); // Determine type of mapping (i.e., transition mode)

    this.updateTransition(mapping); // SelectMapping marks new mapping as active mapping, which is necessary so
    // that it gets added to the existing mappings in notifyMappingUpdated().
    // TODO: this seems very unintuitive, seems like some step to explicitly
    // add the new mapping would make more sense

    this.selectMapping(mapping);
    this.notifyMappingUpdated();
  };

  _proto.selectMapping = function selectMapping(mappingModel) {
    if (mappingModel == null) {
      this.deselectMapping();
      return;
    }

    this.cfg.mappings.activeMapping = mappingModel; // TODO: check this non null operator

    this.cfg.showMappingDetailTray = true;
    this.mappingUpdatedSource.next();
  };

  _proto.deselectMapping = function deselectMapping() {
    this.cfg.showMappingDetailTray = false;
    this.cfg.mappings.activeMapping = null; // TODO: check this non null operator

    this.notifyMappingUpdated();
  }
  /**
   * Remove any mappings referencing the specified document ID.
   *
   * @param docId - Specified document ID
   * @param cfg
   */
  ;

  _proto.removeDocumentReferenceFromAllMappings = function removeDocumentReferenceFromAllMappings(docId) {
    for (var _iterator2 = _createForOfIteratorHelperLoose(this.cfg.mappings.getAllMappings(true)), _step2; !(_step2 = _iterator2()).done;) {
      var mapping = _step2.value;

      for (var _iterator3 = _createForOfIteratorHelperLoose(mapping.getAllFields()), _step3; !(_step3 = _iterator3()).done;) {
        var mappedField = _step3.value;

        if (mappedField instanceof PaddingField || mappedField.docDef.id !== docId) {
          continue;
        }

        this.removeFieldFromAllMappings(mappedField);

        if (mapping.sourceFields.length === 0 || mapping.targetFields.length === 0) {
          this.cfg.mappings.removeMapping(mapping); // TODO: check this non null operator

          if (mapping === this.cfg.mappings.activeMapping) {
            // TODO: check this non null operator
            this.cfg.mappingService.deselectMapping();
          }
        }
      }
    }
  };

  _proto.removeFieldFromAllMappings = function removeFieldFromAllMappings(field) {
    // TODO: check this non null operator
    for (var _iterator4 = _createForOfIteratorHelperLoose(this.cfg.mappings.getAllMappings(true)), _step4; !(_step4 = _iterator4()).done;) {
      var mapping = _step4.value;
      var mappedField = mapping.getMappedFieldForField(field);

      if (mappedField != null) {
        mapping.removeMappedField(mappedField);

        if (mapping.isEmpty()) {
          this.cfg.mappings.removeMapping(mapping); // TODO: check this non null operator
        }
      }
    }
  }
  /**
   * Invoke the runtime service to validate the current active mapping.
   */
  ;

  _proto.validateMappings = function validateMappings(payload) {
    try {
      var _this10 = this;

      return Promise.resolve(new Promise(function (resolve) {
        if (_this10.cfg.initCfg.baseMappingServiceUrl === null || _this10.cfg.mappings === null) {
          // validation service not configured or required
          resolve(false);
          return;
        }

        _this10.cfg.errorService.clearValidationErrors();

        var url = _this10.cfg.initCfg.baseMappingServiceUrl + 'mapping/validate/' + _this10.cfg.mappingDefinitionId;

        _this10.cfg.logger.debug("Validation Service Request: " + JSON.stringify(payload) + "\n");

        _this10.api.put(url, {
          json: payload
        }).json().then(function (body) {
          _this10.cfg.logger.debug("Validation Service Response: " + JSON.stringify(body) + "\n");

          _this10.processValidationResponse(body, resolve);
        })["catch"](function () {
          _this10.cfg.logger.warn('Unable to fetch validation data.');

          resolve(false);
        });
      }));
    } catch (e) {
      return Promise.reject(e);
    }
  };

  _proto.processValidationResponse = function processValidationResponse(body, resolve) {
    var _this11 = this,
        _this$cfg$errorServic;

    if (this.cfg.mappings === null) {
      resolve(false);
      return;
    }

    var errors = []; // This should be eventually turned into mapping entry level validation.
    // https://github.com/atlasmap/atlasmap-ui/issues/116

    if (body && body.Validations && body.Validations.validation) {
      var _loop = function _loop() {
        var validation = _step5.value;
        var level = ErrorLevel[validation.status ? validation.status : 'ERROR'];
        var scope = ErrorScope[validation.scope ? validation.scope : 'MAPPING'];
        var validatedMapping = undefined;

        if (!scope || scope !== ErrorScope.MAPPING || !validation.id) {
          scope = ErrorScope.APPLICATION;
        } else {
          scope = ErrorScope.MAPPING;

          if (_this11.cfg.mappings && _this11.cfg.mappings.mappings) {
            validatedMapping = _this11.cfg.mappings.mappings.find(function (m) {
              return m.uuid === validation.id;
            }); // TODO: check this non null operator
          }
        }

        errors.push(new ErrorInfo({
          message: validation.message,
          level: level,
          scope: scope,
          mapping: validatedMapping,
          type: ErrorType.VALIDATION
        }));
      };

      for (var _iterator5 = _createForOfIteratorHelperLoose(body.Validations.validation), _step5; !(_step5 = _iterator5()).done;) {
        _loop();
      }
    }

    (_this$cfg$errorServic = this.cfg.errorService).addError.apply(_this$cfg$errorServic, errors);

    resolve(true);
  }
  /**
   * Notify the line machine to update the lines between panels.  Most widgets require a
   * small delay to allow the panel to complete forming so add it here.
   */
  ;

  _proto.notifyLineRefresh = function notifyLineRefresh() {
    var _this12 = this;

    setTimeout(function () {
      _this12.lineRefreshSource.next();
    }, 1);
  }
  /**
   * Validate and save complete mappings.  Triggered either as an observable
   * or directly.
   */
  ;

  _proto.notifyMappingUpdated = function notifyMappingUpdated() {
    var _this13 = this;

    return new Promise(function (resolve) {
      try {
        var _temp8 = function _temp8() {
          _this13.mappingUpdatedSource.next();

          _this13.notifyLineRefresh();

          resolve(true);
        };

        var _temp9 = function () {
          if (_this13.cfg.mappings) {
            var activeMapping = _this13.cfg.mappings.activeMapping; // TODO: check this non null operator

            if (activeMapping && _this13.cfg.mappings.mappings.indexOf(activeMapping) === -1) {
              _this13.cfg.mappings.mappings.push(activeMapping);
            }

            var payload = MappingSerializer.serializeMappings(_this13.cfg);
            return Promise.resolve(_this13.validateMappings(payload)).then(function (_this13$validateMappi) {
              var _temp5 = function () {
                if (_this13$validateMappi) {
                  return Promise.resolve(_this13.cfg.fileService.setMappingToService(payload)).then(function () {});
                }
              }();

              if (_temp5 && _temp5.then) return _temp5.then(function () {});
            });
          }
        }();

        return Promise.resolve(_temp9 && _temp9.then ? _temp9.then(_temp8) : _temp8(_temp9));
      } catch (e) {
        return Promise.reject(e);
      }
    });
  }
  /**
   * Update mode transition from a single mapping to multiple-mappings and back.
   *
   * @param mapping
   * @param position
   * @param offset
   */
  ;

  _proto.updateTransition = function updateTransition(mapping) {
    if (mapping.transition.enableExpression) {
      return;
    }

    for (var _iterator6 = _createForOfIteratorHelperLoose(mapping.getAllFields()), _step6; !(_step6 = _iterator6()).done;) {
      var field = _step6.value;

      if (field.enumeration) {
        mapping.transition.mode = TransitionMode.ENUM;
        LookupTableUtil.populateMappingLookupTable(this.cfg.mappings, mapping); // TODO: check this non null operator

        return;
      }
    }

    var sourceMappedFields = mapping.getMappedFields(true);
    var sourceMappedCollection = MappingUtil.hasMappedCollection(mapping, true);
    var targetMappedFields = mapping.getMappedFields(false);
    var targetMappedCollection = MappingUtil.hasMappedCollection(mapping, false);

    if (sourceMappedCollection && targetMappedCollection) {
      mapping.transition.mode = TransitionMode.FOR_EACH;
      return;
    }

    if (sourceMappedFields.length > 1 || sourceMappedCollection) {
      mapping.transition.mode = TransitionMode.MANY_TO_ONE;

      if (!mapping.transition.transitionFieldAction || !mapping.transition.transitionFieldAction.definition || mapping.transition.transitionFieldAction.definition.multiplicity !== Multiplicity.MANY_TO_ONE) {
        mapping.transition.transitionFieldAction = FieldAction.create(this.cfg.fieldActionService.getActionDefinitionForName('Concatenate', Multiplicity.MANY_TO_ONE)); // TODO: check this non null operator

        mapping.transition.transitionFieldAction.setArgumentValue('delimiter', ' ');
        mapping.transition.transitionFieldAction.setArgumentValue('delimitingEmptyValues', 'true');
      }

      return;
    }

    if (targetMappedFields.length > 1 || targetMappedCollection) {
      var _mapping$transition$t;

      mapping.transition.mode = TransitionMode.ONE_TO_MANY;

      if (!mapping.transition.transitionFieldAction || ((_mapping$transition$t = mapping.transition.transitionFieldAction.definition) === null || _mapping$transition$t === void 0 ? void 0 : _mapping$transition$t.multiplicity) !== Multiplicity.ONE_TO_MANY) {
        mapping.transition.transitionFieldAction = FieldAction.create(this.cfg.fieldActionService.getActionDefinitionForName('Split', Multiplicity.ONE_TO_MANY)); // TODO: check this non null operator

        mapping.transition.transitionFieldAction.setArgumentValue('delimiter', ' ');
        mapping.transition.transitionFieldAction.setArgumentValue('collapseRepeatingDelimiters', 'false');
      }

      return;
    }

    mapping.transition.mode = TransitionMode.ONE_TO_ONE;
    mapping.transition.transitionFieldAction = null;
  }
  /**
   * Remove any trailing padding fields for the mapped field array.  This occurs when a user moves
   * a mapped element above the last padding field.
   *
   * @param mappedFields
   * @param trailing - Remove trailing padding fields only
   */
  ;

  _proto.clearExtraPaddingFields = function clearExtraPaddingFields(mappedFields, trailing) {
    var index = 0;
    var mField = null;

    for (index = mappedFields.length - 1; index >= 0; index--) {
      mField = mappedFields[index];

      if (mField.isPadField()) {
        CommonUtil.removeItemFromArray(mField, mappedFields);
        continue;
      }

      if (trailing) {
        break;
      }
    }
  }
  /**
   * Get the enumeration values for the specified mapping and return it in
   * the form of a lookup table.
   *
   * @param cfg
   * @param mapping
   */
  ;

  _proto.getEnumerationValues = function getEnumerationValues(cfg, mapping) {
    return LookupTableUtil.getEnumerationValues(cfg, mapping);
  }
  /**
   * Set the enumeration field value based on the specified enumeration value index.
   *
   * @param enumerationField
   * @param enumerationValue
   */
  ;

  _proto.setEnumFieldValue = function setEnumFieldValue(enumerationField, enumerationValue) {
    enumerationField.enumIndexValue = enumerationValue;
  }
  /**
   * Update the enumeration values for the specified mapping with the specified
   * enumeration values.
   *
   * @param cfg
   * @param mapping
   * @param enumerationValues
   */
  ;

  _proto.updateEnumerationValues = function updateEnumerationValues(cfg, mapping, enumerationValues) {
    LookupTableUtil.updateEnumerationValues(cfg, mapping, enumerationValues);
    this.notifyMappingUpdated();
  }
  /**
   * Return true if the specified mapping is an enumeration mapping, false otherwise.
   *
   * @param mapping
   */
  ;

  _proto.isEnumerationMapping = function isEnumerationMapping(mapping) {
    return mapping.transition.mode === TransitionMode.ENUM;
  };

  _createClass(MappingManagementService, [{
    key: "cfg",
    get: function get() {
      return this._cfg;
    },
    set: function set(cfg) {
      var _this14 = this;

      this._cfg = cfg;

      if (!this._cfg.logger) {
        this._cfg.logger = log.getLogger('mapping-management');
      }

      if (this._cfg.logger.getLevel() <= this._cfg.logger.levels.DEBUG) {
        this.mappingUpdated$.subscribe(function () {
          if (!_this14.cfg.mappings) {
            return;
          }

          if (_this14.cfg.mappings && _this14.cfg.mappings.activeMapping) {
            _this14.cfg.logger.info('mapping updated: ' + JSON.stringify(MappingSerializer.serializeMappings(_this14.cfg)));
          }
        });
      }
    }
  }]);

  return MappingManagementService;
}();

/**
 * Manages Mapping Preview.
 */

var MappingPreviewService = /*#__PURE__*/function () {
  function MappingPreviewService(api) {
    this.api = api;
    this.mappingPreviewInputSource = new Subject();
    this.mappingPreviewInput$ = this.mappingPreviewInputSource.asObservable();
    this.mappingPreviewOutputSource = new Subject();
    this.mappingPreviewOutput$ = this.mappingPreviewOutputSource.asObservable();
    this.mappingPreviewErrorSource = new Subject();
    this.mappingPreviewError$ = this.mappingPreviewErrorSource.asObservable();
  }
  /**
   * Enable Mapping Preview.
   */


  var _proto = MappingPreviewService.prototype;

  _proto.enableMappingPreview = function enableMappingPreview() {
    if (this.cfg.initCfg.baseMappingServiceUrl == null) {
      // process mapping service not configured.
      return;
    }

    this.cfg.showMappingPreview = true;
    this.mappingPreviewInputSubscription = this.createMappingPreviewSubscription();
    this.mappingUpdatedSubscription = this.createMappingUpdatedSubscription();
  };

  _proto.createMappingPreviewSubscription = function createMappingPreviewSubscription() {
    var _this = this;

    return this.mappingPreviewInput$.subscribe(function (inputFieldMapping) {
      if (!inputFieldMapping || !inputFieldMapping.isFullyMapped()) {
        return;
      }

      var hasValue = false;

      for (var _iterator = _createForOfIteratorHelperLoose(inputFieldMapping.getFields(true)), _step; !(_step = _iterator()).done;) {
        var sourceField = _step.value;

        if (sourceField.value) {
          hasValue = true;
          break;
        }
      }

      if (!hasValue) {
        for (var _iterator2 = _createForOfIteratorHelperLoose(inputFieldMapping.getFields(false)), _step2; !(_step2 = _iterator2()).done;) {
          var targetField = _step2.value;

          if (targetField.value) {
            hasValue = true;
            break;
          }
        }
      }

      if (!hasValue) {
        return;
      }

      var payload = _this.createPreviewRequestBody(inputFieldMapping);

      _this.cfg.logger.debug("Process Mapping Preview Request: " + JSON.stringify(payload));

      var url = _this.cfg.initCfg.baseMappingServiceUrl + 'mapping/process';

      _this.api.put(url, {
        json: payload
      }).json().then(function (body) {
        _this.cfg.logger.debug("Process Mapping Preview Response: " + JSON.stringify(body));

        _this.processPreviewResponse(inputFieldMapping, body);
      })["catch"](function (error) {
        if (_this.cfg.mappings && _this.cfg.mappings.activeMapping && _this.cfg.mappings.activeMapping === inputFieldMapping) {
          _this.cfg.errorService.addError(new ErrorInfo({
            message: error,
            level: ErrorLevel.ERROR,
            mapping: inputFieldMapping,
            scope: ErrorScope.MAPPING,
            type: ErrorType.PREVIEW
          }));
        }

        _this.mappingPreviewErrorSource.next([new ErrorInfo({
          message: error,
          level: ErrorLevel.ERROR
        })]);
      });
    });
  };

  _proto.createPreviewRequestBody = function createPreviewRequestBody(inputFieldMapping) {
    return {
      ProcessMappingRequest: {
        jsonType: PROCESS_MAPPING_REQUEST_JSON_TYPE,
        mapping: MappingSerializer.serializeFieldMapping(this.cfg, inputFieldMapping, 'preview', false)
      }
    };
  };

  _proto.processPreviewResponse = function processPreviewResponse(inputFieldMapping, body) {
    var answer = MappingSerializer.deserializeFieldMapping(body.ProcessMappingResponse.mapping, this.cfg);

    for (var _iterator3 = _createForOfIteratorHelperLoose(inputFieldMapping.targetFields), _step3; !(_step3 = _iterator3()).done;) {
      var toWrite = _step3.value;

      for (var _iterator4 = _createForOfIteratorHelperLoose(answer.targetFields), _step4; !(_step4 = _iterator4()).done;) {
        var _toWrite$field, _toWrite$field$docDef, _toRead$field, _toWrite$field2, _toRead$field2;

        var toRead = _step4.value;

        // TODO: check these non null operator
        if (((_toWrite$field = toWrite.field) === null || _toWrite$field === void 0 ? void 0 : (_toWrite$field$docDef = _toWrite$field.docDef) === null || _toWrite$field$docDef === void 0 ? void 0 : _toWrite$field$docDef.id) === ((_toRead$field = toRead.field) === null || _toRead$field === void 0 ? void 0 : _toRead$field.docDef.id) && ((_toWrite$field2 = toWrite.field) === null || _toWrite$field2 === void 0 ? void 0 : _toWrite$field2.path) === ((_toRead$field2 = toRead.field) === null || _toRead$field2 === void 0 ? void 0 : _toRead$field2.path)) {
          var _toRead$mappingField;

          // TODO let field component subscribe mappingPreviewOutputSource instead of doing this
          // TODO: check this non null operator
          toWrite.field.value = (_toRead$mappingField = toRead.mappingField) === null || _toRead$mappingField === void 0 ? void 0 : _toRead$mappingField.value;
          var index = answer.targetFields.indexOf(toRead);

          if (index !== -1) {
            answer.targetFields.splice(index, 1);
            break;
          }
        }
      }
    }

    this.mappingPreviewOutputSource.next(answer);
    var audits = MappingSerializer.deserializeAudits(body.ProcessMappingResponse.audits, ErrorType.PREVIEW); // TODO: check this non null operator

    if (this.cfg.mappings.activeMapping === inputFieldMapping) {
      var _this$cfg$errorServic;

      audits.forEach(function (a) {
        return a.mapping = inputFieldMapping;
      });

      (_this$cfg$errorServic = this.cfg.errorService).addError.apply(_this$cfg$errorServic, audits);
    }

    this.mappingPreviewErrorSource.next(audits);
  };

  _proto.createMappingUpdatedSubscription = function createMappingUpdatedSubscription() {
    var _this2 = this;

    return this.cfg.mappingService.mappingUpdated$.subscribe(function () {
      if (!_this2.cfg || !_this2.cfg.mappings || !_this2.cfg.mappings.activeMapping) {
        return;
      }

      if (_this2.cfg.mappings.activeMapping.isFullyMapped()) {
        _this2.mappingPreviewInputSource.next(_this2.cfg.mappings.activeMapping);
      }
    });
  }
  /**
   * On mapping preview disable, clear any preview values and unsubscribe from
   * both the mapping-updated and mapping-preview subscriptions.
   */
  ;

  _proto.disableMappingPreview = function disableMappingPreview() {
    var _this$cfg$mappings, _this$cfg$mappings$ac;

    var mappedValueCleared = false;
    this.cfg.showMappingPreview = false; // Clear any preview values on mapping preview disable.

    if ((_this$cfg$mappings = this.cfg.mappings) !== null && _this$cfg$mappings !== void 0 && (_this$cfg$mappings$ac = _this$cfg$mappings.activeMapping) !== null && _this$cfg$mappings$ac !== void 0 && _this$cfg$mappings$ac.isFullyMapped()) {
      for (var _iterator5 = _createForOfIteratorHelperLoose(this.cfg.mappings.getAllMappings(true)), _step5; !(_step5 = _iterator5()).done;) {
        var mapping = _step5.value;

        for (var _iterator6 = _createForOfIteratorHelperLoose(mapping.getAllFields()), _step6; !(_step6 = _iterator6()).done;) {
          var _mappedField$value;

          var mappedField = _step6.value;

          if (((_mappedField$value = mappedField.value) === null || _mappedField$value === void 0 ? void 0 : _mappedField$value.length) > 0 && !mappedField.isConstant()) {
            mappedField.value = '';
            mappedValueCleared = true;
          }
        }
      }
    }

    if (mappedValueCleared) {
      this.cfg.mappingService.notifyMappingUpdated();
    }

    if (this.mappingUpdatedSubscription) {
      this.mappingUpdatedSubscription.unsubscribe();
      this.mappingUpdatedSubscription = undefined;
    }

    if (this.mappingPreviewInputSubscription) {
      this.mappingPreviewInputSubscription.unsubscribe();
      this.mappingPreviewInputSubscription = undefined;
    }
  }
  /**
   * Toggle Mapping Preview.
   * @param enabled
   */
  ;

  _proto.toggleMappingPreview = function toggleMappingPreview(enabled) {
    if (enabled) {
      this.enableMappingPreview();
    } else {
      this.disableMappingPreview();
    }

    return enabled;
  };

  return MappingPreviewService;
}();

log.setDefaultLevel(log.levels.WARN);
/**
 * Initialize AtlasMap UI core library. It initializes {@link ConfigModel} and core services.
 */

var InitializationService = /*#__PURE__*/function () {
  function InitializationService(api) {
    this.api = api;
    this.cfg = ConfigModel.getConfig();
    this.systemInitializedSource = new Subject();
    this.systemInitialized$ = this.systemInitializedSource.asObservable();
    this.initializationStatusChangedSource = new Subject();
    this.initializationStatusChanged$ = this.initializationStatusChangedSource.asObservable();
    this.documentService = new DocumentManagementService(this.api);
    this.mappingService = new MappingManagementService(this.api);
    this.errorService = new ErrorHandlerService();
    this.fieldActionService = new FieldActionService(this.api);
    this.fileService = new FileManagementService(this.api);
    this.previewService = new MappingPreviewService(this.api);
    this.expressionService = new MappingExpressionService();
    this.resetConfig();
    this.documentService.initialize();
  }

  var _proto = InitializationService.prototype;

  _proto.resetConfig = function resetConfig() {
    this.cfg = new ConfigModel();
    this.cfg.documentService = this.documentService;
    this.cfg.documentService.cfg = this.cfg;
    this.cfg.mappingService = this.mappingService;
    this.cfg.mappingService.cfg = this.cfg;
    this.cfg.errorService = this.errorService;
    this.cfg.fieldActionService = this.fieldActionService;
    this.cfg.fieldActionService.cfg = this.cfg;
    this.cfg.fileService = this.fileService;
    this.cfg.fileService.cfg = this.cfg;
    this.cfg.previewService = this.previewService;
    this.cfg.previewService.cfg = this.cfg;
    this.cfg.expressionService = this.expressionService;
    this.cfg.expressionService.cfg = this.cfg;
    this.cfg.initializationService = this;
    this.cfg.logger = log.getLogger('config');
    ConfigModel.setConfig(this.cfg);
  };

  _proto.initialize = function initialize() {
    var _this = this;

    return new Promise(function (resolve) {
      try {
        var _exit2 = false;

        var _temp3 = function _temp3(_result) {
          if (_exit2) return _result;

          // load documents from initialization parameters in embedded mode
          _this.updateLoadingStatus('Loading source/target documents.');

          _this.cfg.documentService.inspectDocuments().subscribe({
            next: function next() {
              _this.updateStatus();
            }
          });

          _this.initializeWithMappingDigest()["finally"](function () {
            _this.updateStatus();
          });

          resolve(true);
        };

        _this.cfg.setConstantPropertyDocs();

        _this.cfg.errorService.resetAll();

        _this.cfg.fieldActionService.isInitialized = false;
        _this.cfg.initCfg.initialized = false;
        _this.cfg.initCfg.mappingInitialized = false;

        if (_this.cfg.mappingService == null) {
          _this.cfg.errorService.addError(new ErrorInfo({
            message: 'Mapping service is not configured, validation service will not be used.',
            level: ErrorLevel.WARN,
            scope: ErrorScope.APPLICATION,
            type: ErrorType.INTERNAL
          }));
        } else if (_this.cfg.initCfg.baseMappingServiceUrl == null) {
          _this.cfg.errorService.addError(new ErrorInfo({
            message: 'Mapping service URL is not configured, validation service will not be used.',
            level: ErrorLevel.WARN,
            scope: ErrorScope.APPLICATION,
            type: ErrorType.INTERNAL
          }));
        }

        if (!_this.cfg.fieldActionService) {
          _this.handleError('FieldActionService is not configured');

          resolve(false);
          return Promise.resolve();
        } // Verify the runtime service is out there.


        var _temp4 = _catch(function () {
          return Promise.resolve(_this.runtimeServiceActive()).then(function (_this$runtimeServiceA) {
            if (!_this$runtimeServiceA) {
              _this.handleError('The AtlasMap runtime service is not available.');

              resolve(false);
              _exit2 = true;
            }
          });
        }, function () {
          _this.handleError('The AtlasMap runtime service is not available.');

          resolve(false);
          _exit2 = true;
        });

        return Promise.resolve(_temp4 && _temp4.then ? _temp4.then(_temp3) : _temp3(_temp4));
      } catch (e) {
        return Promise.reject(e);
      }
    });
  }
  /**
   * Return true if the runtime service is available, false otherwise.
   */
  ;

  _proto.runtimeServiceActive = function runtimeServiceActive() {
    var _this2 = this;

    return new Promise(function (resolve, reject) {
      var url = _this2.cfg.initCfg.baseMappingServiceUrl + 'ping';

      _this2.cfg.logger.debug('Runtime Service Ping Request');

      _this2.api.get(url).json().then(function (body) {
        _this2.cfg.logger.debug("Runtime Service Ping Response: " + body.String);

        resolve((body === null || body === void 0 ? void 0 : body.String) === 'pong');
      })["catch"](function (error) {
        reject(error);
      });
    });
  }
  /**
   * Retrieve AtlasMap design time backend runtime version.
   * @returns
   */
  ;

  _proto.getRuntimeVersion = function getRuntimeVersion() {
    var _this3 = this;

    var url = this.cfg.initCfg.baseMappingServiceUrl + 'version';
    return new Promise(function (resolve, reject) {
      _this3.api.get(url).json().then(function (body) {
        _this3.cfg.logger.debug("Runtime Service Version Response: " + body.String);

        resolve(body.String);
      })["catch"](function (error) {
        reject(error);
      });
    });
  }
  /**
   * Initialize with the {@link ADMDigest} mapping digest from either an imported ADM archive
   * file or from the DM runtime digest file is presented to update the canvas.
   *
   * @param mappingDigest - {@link ADMDigest} mapping digest
   */
  ;

  _proto.initializeWithMappingDigest = function initializeWithMappingDigest() {
    var _this4 = this;

    return new Promise(function (resolve) {
      _this4.cfg.fileService.getCurrentMappingDigest().then(function (mappingDigest) {
        try {
          var _exit4 = false;

          var _temp9 = function _temp9(_result2) {
            return _exit4 ? _result2 : Promise.resolve(_this4.addDocumentsFromMappingDigest(mappingDigest)).then(function () {
              if (!mappingDigest || !mappingDigest.exportMappings) {
                resolve(false);
                return;
              } // Reinitialize the model mappings.


              var digestMappingsName = MappingSerializer.deserializeAtlasMappingName(CommonUtil.objectize(mappingDigest.exportMappings.value)); // If the live UI mappings name does not match the UI mappings name extracted from the
              // catalog file then use the mappings from the catalog file. Otherwise use the live
              // UI file.

              _this4.cfg.fileService.findMappingFiles('UI').then(function (files) {
                try {
                  return Promise.resolve(_this4.cfg.fileService.setMappingDigestToService(mappingDigest)).then(function () {
                    return Promise.resolve(_this4.cfg.fieldActionService.fetchFieldActions()).then(function () {
                      function _temp8() {
                        // load both default and custom field actions
                        return Promise.resolve(_this4.cfg.fieldActionService.fetchFieldActions()).then(function () {
                          // load mappings
                          _this4.fetchMappings().then(function (value) {
                            resolve(value);
                          });
                        });
                      }

                      var _temp7 = function () {
                        if (digestMappingsName !== files[0]) {
                          return Promise.resolve(_this4.cfg.fileService.setMappingStringToService(mappingDigest.exportMappings.value)).then(function () {});
                        }
                      }();

                      return _temp7 && _temp7.then ? _temp7.then(_temp8) : _temp8(_temp7);
                    });
                  });
                } catch (e) {
                  return Promise.reject(e);
                }
              })["catch"](function () {
                resolve(false);
              });
            });
          };

          var _temp10 = function () {
            if (!mappingDigest) {
              if (_this4.cfg.mappings === null) {
                _this4.cfg.mappings = new MappingDefinition();
              } // load field actions - do this even with no documents so the default field actions are loaded.


              return Promise.resolve(_this4.cfg.fieldActionService.fetchFieldActions()).then(function () {
                _this4.updateStatus();

                resolve(true);
                _exit4 = true;
              });
            }
          }();

          // If digest is null then no compressed mappings digest file is available on the server.
          return Promise.resolve(_temp10 && _temp10.then ? _temp10.then(_temp9) : _temp9(_temp10));
        } catch (e) {
          return Promise.reject(e);
        }
      })["catch"](function () {
        resolve(false);
      });
    });
  };

  _proto.addDocumentsFromMappingDigest = function addDocumentsFromMappingDigest(mappingDigest) {
    var _this5 = this;

    return new Promise(function (resolve) {
      try {
        var _temp13 = function _temp13() {
          _this5.cfg.mappingService.notifyMappingUpdated();

          resolve(true);
        };

        _this5.cfg.errorService.resetAll();

        var fragIndex = 0; // Reinitialize the model documents.

        var _temp14 = _forOf(mappingDigest.exportMeta, function (metaFragment) {
          var fragData = mappingDigest.exportBlockData[fragIndex].value;
          var docID = metaFragment.id ? metaFragment.id : metaFragment.name;
          var docType = metaFragment.dataSourceType ? metaFragment.dataSourceType : metaFragment.documentType;
          var isSource = typeof metaFragment.isSource === 'string' ? metaFragment.isSource.toLowerCase() === 'true' : metaFragment.isSource;
          return Promise.resolve(_this5.cfg.documentService.addDocument(fragData, docID, metaFragment.name, docType, metaFragment.inspectionType, isSource, metaFragment.inspectionParameters)).then(function () {
            _this5.updateStatus();

            fragIndex++;
          });
        });

        return Promise.resolve(_temp14 && _temp14.then ? _temp14.then(_temp13) : _temp13(_temp14));
      } catch (e) {
        return Promise.reject(e);
      }
    });
  }
  /**
   * Fetch mapping files and initialize user mappings in the canvas.
   *
   * @param mappingFiles
   */
  ;

  _proto.fetchMappings = function fetchMappings() {
    var _this6 = this;

    return new Promise(function (resolve) {
      try {
        var _temp17 = function _temp17() {
          if (mappingFiles.length === 0) {
            resolve(false);
          }

          _this6.cfg.mappingService.fetchMappings(mappingFiles, _this6.cfg.mappings).then(function () {
            _this6.cfg.initCfg.mappingInitialized = true;

            _this6.updateStatus();

            _this6.cfg.mappingService.notifyMappingUpdated().then(function () {
              return resolve(true);
            });
          });
        };

        if (_this6.cfg.mappings != null) {
          resolve(true);
          return Promise.resolve();
        }

        _this6.cfg.mappings = new MappingDefinition();
        var mappingFiles = _this6.cfg.mappingFiles;

        var _temp18 = function () {
          if (!_this6.cfg.mappingFiles || _this6.cfg.mappingFiles.length === 0) {
            return Promise.resolve(_this6.cfg.fileService.findMappingFiles('UI')).then(function (_this6$cfg$fileServic) {
              mappingFiles = _this6$cfg$fileServic;
            });
          }
        }();

        return Promise.resolve(_temp18 && _temp18.then ? _temp18.then(_temp17) : _temp17(_temp18));
      } catch (e) {
        return Promise.reject(e);
      }
    });
  };

  _proto.updateStatus = function updateStatus() {
    var documentCount = this.cfg.getAllDocs().length;
    var finishedDocCount = 0;

    for (var _iterator = _createForOfIteratorHelperLoose(this.cfg.getAllDocs()), _step; !(_step = _iterator()).done;) {
      var docDef = _step.value;

      if (docDef.initialized || docDef.errorOccurred) {
        finishedDocCount++;
      }
    }

    if (documentCount === finishedDocCount && this.cfg.fieldActionService.isInitialized) {
      if (this.cfg.preloadedMappingJson) {
        MappingSerializer.deserializeMappingServiceJSON(JSON.parse(this.cfg.preloadedMappingJson), this.cfg);
        this.cfg.preloadedMappingJson = null;
      }

      if (this.cfg.mappings) {
        LookupTableUtil.updateLookupTables(this.cfg.mappings);
        MappingUtil.updateDocumentNamespacesFromMappings(this.cfg);
        MappingUtil.updateMappingsFromDocuments(this.cfg);

        for (var _iterator2 = _createForOfIteratorHelperLoose(this.cfg.getAllDocs()), _step2; !(_step2 = _iterator2()).done;) {
          var d = _step2.value;
          d.updateFromMappings(this.cfg.mappings);
        }

        MappingUtil.removeStaleMappings(this.cfg);
        this.cfg.mappingService.updateMappingsTransition();
      }

      this.updateInitComplete();
    }
  };

  _proto.handleError = function handleError(message, error) {
    message = 'Data Mapper UI Initialization Error: ' + message;
    this.cfg.errorService.addError(new ErrorInfo({
      message: message,
      scope: ErrorScope.APPLICATION,
      level: ErrorLevel.ERROR,
      type: ErrorType.INTERNAL,
      object: error
    }));
    this.updateLoadingStatus(message);
    this.cfg.initCfg.initializationErrorOccurred = true;
    this.cfg.initCfg.initialized = true;
    this.systemInitializedSource.next();
  };

  _proto.updateInitComplete = function updateInitComplete() {
    this.updateLoadingStatus('Initialization complete.');
    this.cfg.initCfg.initialized = true;
    this.systemInitializedSource.next();
  };

  _proto.updateLoadingStatus = function updateLoadingStatus(status) {
    this.cfg.initCfg.loadingStatus = status;
    this.initializationStatusChangedSource.next();
  };

  _proto.initializeWithADMArchiveFile = function initializeWithADMArchiveFile(file) {
    var _this7 = this;

    return new Promise(function (resolve) {
      _this7.updateLoadingStatus('Importing ADM archive file');

      _this7.cfg.fileService.importADMArchive(file).then(function () {
        _this7.initialize().then(function (value) {
          resolve(value);
        });
      });
    });
  };

  _proto.resetAtlasMap = function resetAtlasMap() {
    var _this8 = this;

    return new Promise(function (resolve) {
      _this8.cfg.fileService.resetAll().then(function (value) {
        _this8.initialize().then(function (value2) {
          resolve(value && value2);
        });
      });
    });
  };

  return InitializationService;
}();

export { ATLAS_MAPPING_JSON_TYPE, AuditStatus, COLLECTION_JSON_TYPE, CONSTANT_FIELD_JSON_TYPE, CollectionType, CommonUtil, ConfigModel, CsvInspectionModel, CsvInspectionRequestModel, CsvInspectionRequestOptions, DATA_SOURCE_JSON_TYPE, DataMapperInitializationModel, DataSourceType, DocumentDefaultName, DocumentDefinition, DocumentInitializationModel, DocumentInspectionModel, DocumentInspectionRequestModel, DocumentInspectionRequestOptions, DocumentInspectionUtil, DocumentManagementService, DocumentType, EnumValue, ErrorHandlerService, ErrorInfo, ErrorLevel, ErrorScope, ErrorType, Examples, ExpressionModel, ExpressionNode, ExpressionUpdatedEvent, FIELD_GROUP_JSON_TYPE, FIELD_PATH_SEPARATOR, Field, FieldAction, FieldActionArgument, FieldActionArgumentValue, FieldActionDefinition, FieldActionService, FieldNode, FieldStatus, FieldType, FileManagementService, FileName, FileType, Guid, HTTP_STATUS_NO_CONTENT, HTTP_STATUS_OK, InitializationService, InspectionType, JAVA_CLASS_JSON_TYPE, JAVA_ENUM_FIELD_JSON_TYPE, JAVA_INSPECTION_REQUEST_JSON_TYPE, JAVA_MODEL_PACKAGE_PREFIX, JSON_DATA_SOURCE_JSON_TYPE, JSON_ENUM_FIELD_JSON_TYPE, JSON_INSPECTION_REQUEST_JSON_TYPE, JSON_MODEL_PACKAGE_PREFIX, JavaInspectionModel, JavaInspectionRequestModel, JavaInspectionRequestOptions, JsonInspectionModel, JsonInspectionRequestModel, JsonInspectionRequestOptions, LookupTable, LookupTableData, LookupTableEntry, LookupTableUtil, MAPPING_JSON_TYPE, MODEL_PACKAGE_PREFIX, MappedField, MappingDefinition, MappingDigestUtil, MappingExpressionService, MappingManagementService, MappingModel, MappingSerializer, MappingType, MappingUtil, Modifier, Multiplicity, NamespaceModel, PROCESS_MAPPING_REQUEST_JSON_TYPE, PROPERTY_FIELD_JSON_TYPE, PaddingField, TextNode, TransitionDelimiter, TransitionDelimiterModel, TransitionMode, TransitionModel, ValidationScope, ValidationStatus, XML_DATA_SOURCE_JSON_TYPE, XML_ENUM_FIELD_JSON_TYPE, XML_INSPECTION_REQUEST_JSON_TYPE, XML_MODEL_PACKAGE_PREFIX, XmlInspectionModel, XmlInspectionRequestModel, XmlInspectionRequestOptions, collectionTypes, constantTypes, getCsvParameterOptions, propertyTypes };
//# sourceMappingURL=core.esm.js.map
