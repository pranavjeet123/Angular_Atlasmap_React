import { MappedField, MappingModel } from './mapping.model';
import { ConfigModel } from './config.model';
import { IExpressionNode } from '../contracts/expression';
import { Subject } from 'rxjs';
export declare class ExpressionUpdatedEvent {
    node?: ExpressionNode | undefined;
    offset?: number | undefined;
    constructor(node?: ExpressionNode | undefined, offset?: number | undefined);
}
export declare abstract class ExpressionNode implements IExpressionNode {
    protected static sequence: number;
    readonly uuid: string;
    readonly str: string;
    constructor(prefix: string);
    getUuid(): string;
    abstract toText(): string;
    abstract toHTML(): string;
}
export declare class TextNode extends ExpressionNode {
    str: string;
    static readonly PREFIX = "expression-text-";
    constructor(str: string);
    toText(): string;
    toHTML(): string;
}
export declare class FieldNode extends ExpressionNode {
    private mapping;
    mappedField?: MappedField | null | undefined;
    metaStr?: string | undefined;
    collectionContextPath?: string | undefined;
    static readonly PREFIX = "expression-field-";
    constructor(mapping: MappingModel, mappedField?: MappedField | null | undefined, metaStr?: string | undefined, index?: number, collectionContextPath?: string | undefined);
    toText(): string;
    toHTML(): string;
    hasComplexField(): boolean;
}
export declare class ExpressionModel {
    private mapping;
    private cfg;
    expressionHTML: string;
    expressionUpdatedSource: Subject<ExpressionUpdatedEvent>;
    expressionUpdated$: import("rxjs").Observable<ExpressionUpdatedEvent>;
    private _hasComplexField;
    private _nodes;
    private textCache;
    constructor(mapping: MappingModel, cfg: ConfigModel);
    generateInitialExpression(): void;
    get hasComplexField(): boolean;
    set hasComplexField(value: boolean);
    get nodes(): ReadonlyArray<ExpressionNode>;
    getLastNodeIndex(): number;
    getLastNode(): ExpressionNode;
    getNode(nodeId?: string): any;
    setConfigModel(cfg: ConfigModel): void;
    /**
     * Clear all text from the specified TextNode offset range or from the '@' to
     * the end of the text node if no node ID is specified.
     *
     * Return the new UUID position indicator string or null.
     *
     * @param nodeId
     * @param startOffset
     * @param endOffset
     */
    clearText(nodeId?: string, startOffset?: number, endOffset?: number): TextNode | null;
    /**
     * Insert text into expression at specified position. If nodeId is not specified,
     * it will be added to the end of expression. It parses the string
     * and insert a set of TextNode & FieldNode if it contains field reference like ${0},
     * otherwise just one TextNode.
     * This emits ExpressionUpdatedEvent which contains the latest node and offset it
     * worked on, so that the subscriber can determine where to put the caret in
     * the expression input widget. If ExpressionUpdatedEvent is undefined, it means that
     * it worked on the end of the expression.
     * @param str string to insert
     * @param nodeId target node to insert the string
     * @param offset position offset in the target node to insert the string
     */
    insertText(str: string, nodeId?: string, offset?: number): void;
    /**
     * Insert an array of ExpressionNodes at the specified position. If insertPosition is
     * not specified the nodes will be appended to the end of the expression.
     * This emits an ExpressionUpdatedEvent which contains the latest node and offset it
     * worked on, so that the subscriber can determine where to put the caret in
     * the expression input widget. If ExpressionUpdatedEvent is undefined, it means that
     * it worked on the end of the expression.
     *
     * @param newNodes an array of ExpressionNode to add
     * @param insertPosition target node to insert the string
     * @param offset position offset in the target node to insert the string
     */
    insertNodes(newNodes: ExpressionNode[], insertPosition?: string, offset?: number): void;
    removeToken(tokenPosition?: string, offset?: number, removeNext?: boolean): void;
    /**
     * Replace the content of the last text node with a substring terminating at the
     * specified index.
     *
     * @param index
     */
    clearToEnd(index: number): void;
    /**
     * Reflect mapped source fields to the field references in the expression.
     * Selected source fields are inserted into or appended to the expression,
     * and unselected source fields are removed from expression.
     *
     * @param mapping Corresponding MappingModel object
     * @param insertPosition
     * @param offset
     */
    updateFieldReference(mapping: MappingModel, insertPosition?: string, offset?: number): void;
    clear(): void;
    toText(): string;
    toHTML(): string;
    addConditionalExpressionNode(mappedField: MappedField, nodeId: string, offset: number): void;
    private updateCache;
    /**
     * Translate an expression string into an array of text nodes and field nodes.  Handle
     * relative paths for collection-based field references.
     *
     * @param text
     */
    private createNodesFromText;
    private appendFieldNode;
}
//# sourceMappingURL=expression.model.d.ts.map