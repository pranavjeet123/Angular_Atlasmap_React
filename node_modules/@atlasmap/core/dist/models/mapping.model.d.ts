import { IField } from '../contracts/common';
import { ConfigModel } from './config.model';
import { Field } from './field.model';
import { FieldAction } from './field-action.model';
import { TransitionModel } from './transition.model';
export declare class MappedField {
    /**
     * The field properties read from mapping definition. This is a temporary object
     * when it's deserialized from mapping definition and once {@link field} is populated
     * this should not be used.
     * @todo Identify document field at once when it deserializes and remove this temporary
     * object.
     */
    mappingField: IField;
    /** The field object created from document field */
    field: Field | null;
    /** The field actions read from mapping and enriched through {@link FieldActionService} */
    actions: FieldAction[];
    static sortMappedFieldsByPath(mappedFields: MappedField[]): MappedField[];
    isPadField(): boolean;
    isSource(): boolean;
    removeAction(action: FieldAction): void;
}
export declare class MappingModel {
    cfg: ConfigModel;
    uuid: string;
    sourceFields: MappedField[];
    targetFields: MappedField[];
    referenceFields: MappedField[];
    transition: TransitionModel;
    constructor();
    getFirstCollectionField(isSource: boolean): Field | null;
    isLookupMode(): boolean;
    /**
     * Add the specified field to this field mapping.
     *
     * @param field - field to add to the mapping
     * @param first - if true add the field to the beginning of the array, last otherwise.
     */
    addField(field: Field, first: boolean): MappedField;
    /**
     * Remove the specified field from this field mapping.
     *
     * @param field
     */
    removeField(field: Field): void;
    /**
     * Return the number of user-defined (non-padding) fields in this mapping.
     *
     * @param field
     */
    getUserFieldCount(field: Field): number;
    hasMappedField(isSource: boolean): boolean;
    isEmpty(): boolean;
    isFullyMapped(): boolean;
    addMappedField(mappedField: MappedField, isSource: boolean): void;
    removeMappedField(mappedField: MappedField): void;
    getMappedFieldForField(field: Field): MappedField | null;
    /**
     * Return the MappedField associated with the specified field path and panel. The
     * document ID is optional identifier parameters used to distinguish the fields
     * with the same path in a different document. The first match will be returned
     * if not specified.
     *
     * @param fieldPath
     * @param isSource
     * @param identifier
     */
    getMappedFieldByPath(fieldPath: string, isSource: boolean, docId?: string): MappedField | null;
    getMappedFieldForIndex(index: string, isSource: boolean): MappedField | null;
    getIndexForMappedField(mappedField: MappedField): number | null;
    getField(docId: string, fieldPath: string): Field | null;
    /**
     * Create a reference field in the reference fields array for this mapping.
     *
     * @param field
     */
    createReferenceField(field: Field): MappedField | null;
    /**
     * Remove the specified reference field from the reference fields array.
     *
     * @param field
     */
    removeReferenceField(mappedField: MappedField): void;
    /**
     * Return true if a reference field exists in this mapping with the specified
     * document ID and field path, false otherwise.
     *
     * @param docId
     * @param fieldPath
     */
    referenceFieldExists(docId: string, fieldPath: string): boolean;
    /**
     * A reference field is a complex field which is referenced in a conditional
     * expression but does not exist as an explicit part of the mapping.  It is
     * typically used as a parameter to conditional functions/ constructs. If the
     * field already exists return it otherwise create it.
     *
     * @param docId
     * @param fieldPath
     */
    getReferenceField(docId: string, fieldPath: string): MappedField | null;
    /**
     * Return an array of user mapped fields for the specified panel in this
     * field pair instance.  No data-mapper generated padding fields will be
     * included.
     *
     * @param isSource - true source panel, false target panel
     */
    getUserMappedFields(isSource: boolean): MappedField[];
    getReferenceMappedFields(): MappedField[];
    getMappedFields(isSource: boolean): MappedField[];
    getLastMappedField(isSource: boolean): MappedField | null;
    getFields(isSource: boolean): Field[];
    getFieldNames(isSource: boolean): string[];
    getFieldPaths(isSource: boolean): string[];
    hasFieldActions(): boolean;
    getAllFields(): Field[];
    getAllMappedFields(): MappedField[];
    isFieldMapped(field: Field): boolean;
    hasTransformation(): boolean;
    /**
     * Walk all target field mappings and return one of corresponding source field name
     * if the specified field is already the target of a previous mapping, null otherwise.
     *
     * @param field
     */
    getMappedTarget(field: Field): string | null;
}
//# sourceMappingURL=mapping.model.d.ts.map