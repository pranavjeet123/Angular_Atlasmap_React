import { CollectionType, DocumentType, FieldType, InspectionType } from '../contracts/common';
import { Observable } from 'rxjs';
import { ConfigModel } from '../models/config.model';
import { DocumentDefinition } from '../models/document-definition.model';
import ky from 'ky';
/**
 * Manages Document object lifecycle. Import a Document source
 * such as JSON/XML schema/instance, request an inspection to the backend,
 * then enable it for mapping by consuming inspection result in UI.
 */
export declare class DocumentManagementService {
    private api;
    cfg: ConfigModel;
    private mappingUpdatedSubscription;
    private MAX_SEARCH_MATCH;
    constructor(api: typeof ky);
    initialize(): void;
    uninitialize(): void;
    /**
     * Request Document inspection for each {@link DocumentDefinition} object
     * stored in {@link ConfigModel} and populate it back with the inspection result.
     *
     * @returns
     */
    inspectDocuments(): Observable<DocumentDefinition>;
    private inspectDocument;
    getLibraryClassNames(): Promise<string[]>;
    /**
     * Import user uploaded Document source such as JSON/XML schema/instance, assign
     * a unique Document ID with using GUID and delegate to {@link addNonJavaDocument}
     * to make it available  as a Document for mappings.
     * @see addNonJavaDocument
     *
     * @param selectedFile - user selected file
     * @param isSource - true is source panel, false is target
     * @param isSchema- user specified instance/ schema (true === schema)
     * @param inspectionParameters - CSV parameters
     *
     */
    importNonJavaDocument(selectedFile: File, isSource: boolean, isSchema: boolean, inspectionParameters?: {
        [key: string]: string;
    }): Promise<boolean>;
    /**
     * Import a Java class as a Document source and delegate to {@link addJavaDocument}
     * to make it available  as a Document for mappings.
     * JAR file(s) have to be imported and be available in the backend classpath
     * before doing this.
     * @see addJavaDocument
     * @todo https://github.com/atlasmap/atlasmap/issues/2919
     * A unique Document ID should be assigned with using GUID.
     *
     * @param className
     * @param isSource
     * @param collectionType
     * @param collectionClassName
     */
    importJavaDocument(className: string, isSource: boolean, collectionType?: CollectionType, collectionClassName?: string): Promise<boolean>;
    /**
     * Add non-Java Document object into the {@link ConfigModel} store and
     * delegate to {@link doAddDocument}.
     * @see doAddDocument
     *
     * @param docBody
     * @param docId
     * @param docName
     * @param docType
     * @param inspectionType
     * @param isSource
     * @param parameters
     */
    addNonJavaDocument(docBody: any, docId: string, docName: string, docType: DocumentType, inspectionType: InspectionType, isSource: boolean, parameters?: {
        [key: string]: string;
    }): Promise<boolean>;
    /**
     * Add Java Document object into the {@link ConfigModel} store and
     * delegate to {@link doAddDocument}.
     * @see doAddDocument
     *
     * @param className
     * @param isSource
     * @param collectionType {@link CollectionType}
     * @param collectionClassName
     */
    addJavaDocument(className: string, isSource: boolean, collectionType?: CollectionType, collectionClassName?: string): Promise<boolean>;
    /**
     * An utility method to look at the {@link DocumentType} passed in as an argument
     * and see if it's a Java or non-Java Document, then delegate to
     * {@link addJavaDocument} or {@link addNonJavaDocument}.
     *
     * @todo https://github.com/atlasmap/atlasmap/issues/2918
     * {@link CollectionType} and collectionClassName has to be persisted into digest
     * so it could be restored here
     */
    addDocument(docBody: any, docId: string, docName: string, docType: DocumentType, inspectionType: InspectionType, isSource: boolean, parameters?: {
        [key: string]: string;
    }): Promise<boolean>;
    /**
     * Add or replace the {@link DocumentDefinition} object stored in {@link ConfigModel}
     * and delegate to {@link inspectDocument} to perform an inspection.
     * Then it gets available for mapping in the canvas.
     *
     * @param inspectionModel {@link DocumentInspectionModel}
     * @returns
     */
    private doAddDocument;
    private handleError;
    /**
     * Filter Document fields that is shwon in a Source/Target Document tree.
     * @todo Consolidate with expression field search and Document Details field
     * search - https://github.com/atlasmap/atlasmap/issues/603
     * @param searchFilter
     * @param isSource
     */
    filterDocumentFields(searchFilter: string | undefined, isSource: boolean): void;
    private markChildrenVisible;
    /**
     * Create a constant field.
     * @param constName
     * @param constValue
     * @param constType
     * @param addToActiveMapping
     */
    createConstant(constName: string, constValue: string, constType: string, addToActiveMapping?: boolean): void;
    /**
     * Delete a constant field.
     * @param constName
     */
    deleteConstant(constName: string): void;
    /**
     * Edit a constant field. Look for an existing constant field with the specified name
     * and update the properties. If {@link origName} is specified and different from
     * {@link constName}, the name of the constant field will be changed.
     * @param constName
     * @param constValue
     * @param constType
     * @param origName
     */
    editConstant(constName: string, constValue: string, constType: string, origName?: string): void;
    /**
     * Get a {@link FieldType} of the constant field.
     * @param constName
     */
    getConstantType(constName: string): FieldType;
    /**
     * Get an index of the constant field type.
     * @param constName
     */
    getConstantTypeIndex(constName: string): number;
    /**
     * Create a property field.
     * @param propName
     * @param propType
     * @param propScope
     * @param isSource
     * @param addToActiveMapping
     */
    createProperty(propName: string, propType: string, propScope: string, isSource: boolean, addToActiveMapping?: boolean): void;
    /**
     * Delete a property field.
     * @param propName
     * @param propScope
     * @param isSource
     */
    deleteProperty(propName: string, propScope: string, isSource: boolean): void;
    /**
     * Edit a property field. When editing a property, the propName/propScope
     * is needed to fetch the existing field.  The newName and newScope may or
     * may not be specified.
     *
     * @param propName
     * @param propType
     * @param propScope
     * @param isSource
     * @param newName
     * @param newScope
     */
    editProperty(propName: string, propType: string, propScope: string, isSource: boolean, newName?: string, newScope?: string): void;
    /**
     * Get a {@link FieldType} of the property field.
     * @param propName
     * @param propScope
     * @param isSource
     */
    getPropertyType(propName: string, propScope: string, isSource: boolean): FieldType;
    /**
     * Get an index of the property field type.
     * @param propName
     * @param propScope
     * @param isSource
     */
    getPropertyTypeIndex(propName: string, propScope: string, isSource: boolean): number;
    getPropertyPath(scope: string | undefined | null, name: string): string;
}
//# sourceMappingURL=document-management.service.d.ts.map