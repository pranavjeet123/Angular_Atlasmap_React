import { ErrorInfo, ErrorLevel, ErrorScope } from '../models/error.model';
import { Subject, Subscription } from 'rxjs';
import { MappingModel } from '../models/mapping.model';
/**
 * ErrorHandlerService handles global errors, mapping validation errors, preview errors,
 * mapped field level errors as well as instant form validation errors in a modal windows.
 * Global errors, mapping validation errors, preview errors and mapped field level errors
 * are stored in a same array at this moment. We might want to split them when we show
 * them grouped by {@link ErrorType}.
 * Errors with {@link ErrorScope.MAPPING} and {@link ErrorScope.FIELD} are cleared
 * everytime active mapping is switched. {@link ErrorScope.FIELD} errors are mostly
 * instant and cleared more frequently.
 * Form validation errors are supposed to be instant. Channel should be created by
 * {@link createFormErrorChannel()} when modal window is initialized, and should be
 * completed when modal window is closed.
 */
export declare class ErrorHandlerService {
    private errors;
    private formErrors;
    private errorUpdatedSource;
    private formErrorUpdatedSource;
    /**
     * FIlter an array of {@link ErrorInfo} with specified condition.
     * @param errors An array of {@link ErrorInfo} to filter
     * @param mapping {@link MappingModel} to filter {@link ErrorScope.MAPPING} errors
     * @param level {@link ErrorLevel} to filter with
     */
    static filterWith(errors: ErrorInfo[], mapping?: MappingModel, level?: ErrorLevel): ErrorInfo[];
    /**
     * Add one or more {@link ErrorInfo} object(s) into error store.
     * @param errors one or more {@link ErrorInfo} object(s)
     */
    addError(...errors: ErrorInfo[]): void;
    /**
     * An utility method to add backend error. It's a network error if {@link error.status} is 0.
     *
     * @param message error message to put if it's not a network error
     * @param error raw error object
     */
    addBackendError(message: string, error?: any): void;
    /**
     * Return all errors in the store.
     * @return An array of {@link ErrorInfo}
     */
    getErrors(): ErrorInfo[];
    /**
     * Remove one {@link ErrorInfo} by specifying ID.
     * @param identifier Error ID
     */
    removeError(identifier: string, scope?: ErrorScope): void;
    /**
     * Clear all global/mapping errors as well as form validation erros and its Subject
     * if it exists.
     */
    resetAll(): void;
    /**
     * Remova all errors except form validation errors.
     */
    clearAllErrors(): void;
    /**
     * Remove all preview errors.
     */
    clearPreviewErrors(): void;
    /**
     * Remove all mapping validation errors.
     */
    clearValidationErrors(mapping?: MappingModel): void;
    /**
     * Remove all field scoped errors.
     */
    clearFieldErrors(): void;
    /**
     * Remove all form validation errors.
     */
    clearFormErrors(): void;
    /**
     * Subscribe an error updated event. Observer will be notified
     * when an error is added or removed.
     * @param observer Observer
     */
    subscribe(observer: (errors: ErrorInfo[]) => void): Subscription;
    /**
     * Create a Subject for form validation error. This ErrorHandlerService assumes only
     * one form validation happens at once, as it's used in modal window. Revisit this if there
     * needs to be more than one channel and manage a list of {@link Subject}.
     */
    createFormErrorChannel(): Subject<ErrorInfo[]>;
    /**
     * Validate the specified field value in a form, generating a form validation error if not defined.
     * @param value - A form field to validate
     * @param fieldDescription - used in error diagnostic
     */
    isRequiredFieldValid(value: string | null, fieldDescription: string): boolean;
    private emitUpdatedEvent;
    private excludeByIdentifier;
}
//# sourceMappingURL=error-handler.service.d.ts.map