import { IAtlasMappingContainer } from '../contracts/mapping';
import { ADMDigest } from '../contracts/adm-digest';
import { ConfigModel } from '../models/config.model';
import ky from 'ky';
export declare enum FileName {
    DIGEST = "Mapping digest file",
    ADM = "ADM archive file",
    JAR = "Jar file"
}
export declare enum FileType {
    DIGEST = "GZ",
    ADM = "ZIP",
    JAR = "JAR"
}
/**
 * Handles file manipulation stored in the backend, including import/export via UI.
 */
export declare class FileManagementService {
    private api;
    _cfg: ConfigModel;
    constructor(api: typeof ky);
    get cfg(): ConfigModel;
    set cfg(cfg: ConfigModel);
    findMappingFiles(filter: string): Promise<string[]>;
    /**
     * Retrieve the current user data mappings digest file from the server as a GZIP compressed byte array buffer.
     */
    getCurrentMappingDigest(): Promise<ADMDigest | null>;
    getCurrentADMArchive(): Promise<Uint8Array | null>;
    private getCurrentFile;
    /**
     * Delete mapping files on the runtime.
     */
    resetMappings(): Promise<boolean>;
    /**
     * Delete user-defined JAR library files on the runtime.
     */
    resetLibs(): Promise<boolean>;
    /**
     * Clear error service and delete jar libraries, documents and mappings.
     */
    resetAll(): Promise<boolean>;
    /**
     * Commit the specified AtlasMapping object to the runtime service.  The mappings
     * are kept separate so they can be updated with minimal overhead.
     *
     * @param buffer - The stringified AtlasMapping JSON
     */
    setMappingToService(atlasMappingContainer: IAtlasMappingContainer): Promise<boolean>;
    /**
     * Commit the specified AtlasMapping JSON user mapping string to the runtime service.  The mappings
     * are kept separate so they can be updated with minimal overhead.
     *
     * @param buffer - The stringified AtlasMapping JSON
     */
    setMappingStringToService(jsonBuffer: string): Promise<boolean>;
    setMappingDigestToService(mappingDigest: ADMDigest): Promise<boolean>;
    private setADMArchiveFileToService;
    /**
     * The user has either exported their mappings or imported new mappings.
     * Either way we're saving them on the server.
     *
     * @param compressedBuffer
     */
    private setBinaryFileToService;
    /**
     * Push a user-defined Java archive file (JAR binary buffer) to the runtime.
     *
     * @param binaryBuffer - binary JAR file
     */
    importJarFile(binaryBuffer: BlobPart): Promise<boolean>;
    /**
     * Generate mapping digest file from current state and push it to the runtime.
     *
     * @returns {@link Promise}
     */
    updateDigestFile(): Promise<boolean>;
    /**
     * Update the current mapping files and export the ADM archive file with current mappings.
     *
     * Establish the mapping digest file content in JSON format (mappings + schema + instance-schema),
     * compress it (GZIP), update the runtime, then fetch the full ADM archive ZIP file from the runtime
     * and export it.
     *
     * @param event
     */
    exportADMArchive(mappingsFileName: string): Promise<boolean>;
    /**
     * Clean up all existing mappings, documents, libraries and import specified ADM archive file,
     * push it to the runtime and reflect back in UI. The ADM file is in (ZIP) file format.
     * Once pushed, we can retrieve from runtime the extracted compressed (GZIP) mappings
     * digest file as well as the mappings JSON file.  These files exist separately for performance reasons.
     *
     * Once the runtime has its ADM archive file, digest file and mappings file set then restart the DM.
     *
     * @param mappingsFileName - ADM archive file
     */
    importADMArchive(admFile: File): Promise<boolean>;
    /**
     * Retrieve the current user AtlasMap data mappings from the server as a JSON object.
     */
    getCurrentMappingJson(): Promise<IAtlasMappingContainer>;
}
//# sourceMappingURL=file-management.service.d.ts.map