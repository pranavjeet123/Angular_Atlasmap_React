import { MappingModel } from '../models/mapping.model';
import { ConfigModel } from '../models/config.model';
import { IExpressionNode } from '../contracts/expression';
/**
 * Manages conditional mapping expression.
 */
export declare class MappingExpressionService {
    cfg: ConfigModel;
    private mappingUpdatedSubscription?;
    willClearOutSourceFieldsOnTogglingExpression(): boolean;
    isExpressionEnabledForActiveMapping(): boolean;
    toggleExpressionMode(): void;
    updateExpression(mapping: MappingModel, position?: string, offset?: number): void;
    /**
     * Add the specified document ID/field path to the specified mapping/ expression.
     *
     * @param mapping
     * @param docId
     * @param fieldPath
     * @param newTextNode
     * @param atIndex
     * @param isTrailer
     */
    addFieldToExpression(mapping: MappingModel, docId: string, fieldPath: string, newTextNode: IExpressionNode, atIndex: number, isTrailer: boolean): void;
    /**
     * Return an array of strings representing display names of mapping fields based on the
     * specified filter.
     * @todo ATM this is specialized for listing up candidate fields for adding into expression.
     * We will need to consolidate with field filter on the Document tree when we implement server
     * side field search - https://github.com/atlasmap/atlasmap/issues/603
     *
     * @param filter
     */
    executeFieldSearch(configModel: ConfigModel, filter: string, isSource: boolean): string[][];
    /**
     * Return a string, in either text or HTML form, representing the
     * expression mapping of either the optionally specified mapping or
     * the active mapping if it exists, empty string otherwise.
     * @todo avoid any, use typed mapping object - https://github.com/atlasmap/atlasmap/issues/2975
     * @param asHTML
     * @param mapping
     */
    getMappingExpressionStr(asHTML: boolean, mapping?: any): string;
    /**
     * Create a conditional mapping expression from the specified mapping model.  Start
     * with a multiplicity action if applicable, then any field-specific field actions.
     *
     * @param mapping
     */
    createMappingExpression(mapping: MappingModel): string;
    private qualifiedExpressionRef;
    /**
     * Create a conditional expression fragment based on the specified field action
     * argument and type.
     *
     * @param actionArgument
     * @param actionArgType
     */
    private fieldActionArgumentToExpression;
    /**
     * Create a conditional expression fragment based on a single field action
     * and its arguments if any.
     *
     * @param mappedField
     * @param mfActionIndex
     */
    private fieldActionToExpression;
    /**
     * Create a conditional expression fragment based on the field actions of the specified
     * mapping model and the root field reference.
     *
     * @param mapping
     */
    private fieldActionsToExpression;
}
//# sourceMappingURL=mapping-expression.service.d.ts.map