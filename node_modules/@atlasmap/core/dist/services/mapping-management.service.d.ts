import { LookupTableData } from '../utils/lookup-table-util';
import { MappedField, MappingModel } from '../models/mapping.model';
import { Subject, Subscription } from 'rxjs';
import { ConfigModel } from '../models/config.model';
import { Field } from '../models/field.model';
import { MappingDefinition } from '../models/mapping-definition.model';
import ky from 'ky';
/**
 * Handles mapping updates. It restores mapping status from backend and reflect in UI,
 * and/or reflect mapping changes caused by the user action made in UI to the backend.
 */
export declare class MappingManagementService {
    private api;
    _cfg: ConfigModel;
    lineRefreshSource: Subject<void>;
    lineRefresh$: import("rxjs").Observable<void>;
    mappingUpdatedSource: Subject<void>;
    mappingUpdated$: import("rxjs").Observable<void>;
    debugMappingUpdatedSubscription?: Subscription;
    mappingSelectionRequiredSource: Subject<Field>;
    mappingSelectionRequired$: import("rxjs").Observable<Field>;
    constructor(api: typeof ky);
    get cfg(): ConfigModel;
    set cfg(cfg: ConfigModel);
    /**
     * Retrieve current mapping definition JSON file from backend, deserialize it and
     * load it into AtlasMap UI.
     *
     * @param mappingDefinition {@link MappingDefinition}
     * @returns
     */
    fetchMappings(_mappingFiles: string[], mappingDefinition: MappingDefinition): Promise<boolean>;
    updateMappingsTransition(): void;
    updateActiveMappingTransition(): void;
    /**
     * Remove the specified mapping model from the mappings array and update the runtime.
     *
     * @param mappingModel
     */
    removeMapping(mappingModel: MappingModel): Promise<boolean>;
    /**
     * Remove all mappings from the current session.
     */
    removeAllMappings(): Promise<boolean>;
    updateMappedField(mapping: MappingModel): Promise<boolean>;
    /**
     * Move the specified mapped field in the specified mapping to the specified index.
     *
     * @param mapping
     * @param insertedMappedField
     * @param targetIndex
     */
    moveMappedFieldTo(mapping: MappingModel, insertedMappedField: MappedField, targetIndex: number): void;
    /**
     * Given an index range, fill in the mappings gap with place-holder fields.
     *
     * @param count - number of padding fields to add
     * @param mapping - mapping to modify
     * @param basePadIndex - 0 based
     * @param isSource
     */
    addPlaceholders(count: number, mapping: MappingModel, basePadIndex: number, isSource: boolean): void;
    addFieldToActiveMapping(field: Field): void;
    getFieldSelectionExclusionReason(mapping: MappingModel, field: Field): string | null;
    isFieldSelectable(mapping: MappingModel, field: Field): boolean;
    /**
     * Instantiate a new mapping model and associate the selected field with it.
     * @param selectedField
     * @param compoundSelection - indicates a compound-selection (ctrl/cmd-M1) if true, standard mouse click if false.
     */
    addNewMapping(selectedField: Field, compoundSelection: boolean): void;
    /**
     * Instantiate a new mapping model.
     */
    newMapping(): void;
    selectMapping(mappingModel: MappingModel): void;
    deselectMapping(): void;
    /**
     * Remove any mappings referencing the specified document ID.
     *
     * @param docId - Specified document ID
     * @param cfg
     */
    removeDocumentReferenceFromAllMappings(docId: string): void;
    removeFieldFromAllMappings(field: Field): void;
    /**
     * Invoke the runtime service to validate the current active mapping.
     */
    private validateMappings;
    private processValidationResponse;
    /**
     * Notify the line machine to update the lines between panels.  Most widgets require a
     * small delay to allow the panel to complete forming so add it here.
     */
    notifyLineRefresh(): void;
    /**
     * Validate and save complete mappings.  Triggered either as an observable
     * or directly.
     */
    notifyMappingUpdated(): Promise<boolean>;
    /**
     * Update mode transition from a single mapping to multiple-mappings and back.
     *
     * @param mapping
     * @param position
     * @param offset
     */
    private updateTransition;
    /**
     * Remove any trailing padding fields for the mapped field array.  This occurs when a user moves
     * a mapped element above the last padding field.
     *
     * @param mappedFields
     * @param trailing - Remove trailing padding fields only
     */
    private clearExtraPaddingFields;
    /**
     * Get the enumeration values for the specified mapping and return it in
     * the form of a lookup table.
     *
     * @param cfg
     * @param mapping
     */
    getEnumerationValues(cfg: ConfigModel, mapping: MappingModel): LookupTableData[];
    /**
     * Set the enumeration field value based on the specified enumeration value index.
     *
     * @param enumerationField
     * @param enumerationValue
     */
    setEnumFieldValue(enumerationField: Field, enumerationValue: number): void;
    /**
     * Update the enumeration values for the specified mapping with the specified
     * enumeration values.
     *
     * @param cfg
     * @param mapping
     * @param enumerationValues
     */
    updateEnumerationValues(cfg: ConfigModel, mapping: MappingModel, enumerationValues: LookupTableData[]): void;
    /**
     * Return true if the specified mapping is an enumeration mapping, false otherwise.
     *
     * @param mapping
     */
    isEnumerationMapping(mapping: MappingModel): boolean;
}
//# sourceMappingURL=mapping-management.service.d.ts.map