import * as webcola from 'webcola';
import * as d3 from 'd3';
import { action } from 'mobx';
import { getGroupPadding } from '../utils/element-utils';
import { BaseLayout } from './BaseLayout';
import { ColaNode } from './ColaNode';
import { ColaGroup } from './ColaGroup';
import { ColaLink } from './ColaLink';
const COLA_LAYOUT_DEFAULTS = {
    maxTicks: 300,
    initialUnconstrainedIterations: 200,
    initialUserConstraintIterations: 50,
    initialAllConstraintsIterations: 150,
    gridSnapIterations: 50
};
class ColaLayout extends BaseLayout {
    constructor(graph, options) {
        super(graph, options);
        this.tickCount = 0;
        this.destroyed = false;
        this.simulationRunning = false;
        this.simulationStopped = false;
        this.restartOnEnd = undefined;
        this.addingNodes = false;
        this.getLinkDistance = (link) => {
            let distance = this.options.linkDistance + link.source.radius + link.target.radius;
            if (link.source.element.getParent() !== link.target.element.getParent()) {
                distance += getGroupPadding(link.source.element.getParent());
                distance += getGroupPadding(link.target.element.getParent());
            }
            return distance;
        };
        this.onSimulationEnd = () => {
            if (this.addingNodes) {
                if (!this.options.layoutOnDrag) {
                    this.forceSimulation.stopSimulation();
                }
                this.addingNodes = false;
            }
        };
        this.colaOptions = Object.assign(Object.assign({}, COLA_LAYOUT_DEFAULTS), options);
        this.initializeLayout();
    }
    initializeLayout() {
        this.d3Cola = webcola.d3adaptor(d3);
        this.d3Cola.handleDisconnected(true);
        this.d3Cola.avoidOverlaps(true);
        this.d3Cola.linkDistance(this.getLinkDistance);
        this.d3Cola.on('tick', () => {
            this.tickCount++;
            if (this.tickCount === 1 || this.tickCount % this.options.simulationSpeed === 0) {
                action(() => this.nodes.forEach(d => d.update()))();
            }
            if (this.colaOptions.maxTicks >= 0 && this.tickCount > this.colaOptions.maxTicks) {
                this.d3Cola.stop();
            }
        });
        this.d3Cola.on('end', () => {
            this.tickCount = 0;
            this.simulationRunning = false;
            action(() => {
                if (this.destroyed) {
                    return;
                }
                this.nodes.forEach(d => {
                    if (!this.simulationStopped) {
                        d.update();
                    }
                    d.setFixed(false);
                });
                if (this.options.layoutOnDrag) {
                    this.forceSimulation.useForceSimulation(this.nodes, this.edges, this.getFixedNodeDistance);
                }
                if (this.simulationStopped) {
                    this.simulationStopped = false;
                    if (this.restartOnEnd !== undefined) {
                        this.startColaLayout(this.restartOnEnd);
                        delete this.restartOnEnd;
                    }
                }
                else if (this.addingNodes) {
                    // One round of simulation to adjust for new nodes
                    this.forceSimulation.useForceSimulation(this.nodes, this.edges, this.getFixedNodeDistance);
                    this.forceSimulation.restart();
                }
            })();
        });
    }
    destroy() {
        super.destroy();
        this.destroyed = true;
        this.d3Cola.stop();
    }
    initDrag() {
        // Set the alpha to 0 to halt any ticks that may be occurring
        this.d3Cola.alpha(0);
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    getConstraints(nodes, groups, edges) {
        return [];
    }
    stopSimulation() {
        if (this.simulationRunning) {
            this.simulationStopped = true;
            this.d3Cola.stop();
        }
        super.stopSimulation();
    }
    createLayoutNode(node, nodeDistance, index) {
        return new ColaNode(node, nodeDistance, index);
    }
    createLayoutLink(edge, source, target) {
        return new ColaLink(edge, source, target);
    }
    createLayoutGroup(node, padding, index) {
        return new ColaGroup(node, padding, index);
    }
    setupLayout(graph, nodes, edges, groups) {
        const { width, height } = graph.getBounds();
        this.d3Cola.size([width, height]);
        // Get any custom constraints
        this.d3Cola.constraints(this.getConstraints(nodes, groups, edges));
        this.d3Cola.nodes(nodes);
        this.d3Cola.links(edges);
        this.d3Cola.groups(groups);
    }
    updateExistingNodes(existingNodes) {
        existingNodes.forEach(n => {
            n.fixed = 1;
        });
    }
    startColaLayout(addingNodes) {
        this.simulationRunning = true;
        this.d3Cola.alpha(0.2);
        this.tickCount = 0;
        this.addingNodes = addingNodes;
        this.d3Cola.start(addingNodes ? 0 : this.colaOptions.initialUnconstrainedIterations, addingNodes ? 0 : this.colaOptions.initialUserConstraintIterations, addingNodes ? 0 : this.colaOptions.initialAllConstraintsIterations, addingNodes ? 0 : this.colaOptions.gridSnapIterations, true, !addingNodes);
    }
    startLayout(graph, initialRun, addingNodes) {
        if (!this.simulationStopped) {
            this.startColaLayout(addingNodes);
        }
        else {
            this.restartOnEnd = addingNodes;
        }
    }
}
export { ColaLayout, ColaNode, ColaGroup, ColaLink };
//# sourceMappingURL=ColaLayout.js.map